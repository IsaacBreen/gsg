{
  "model_name": "models/gemini-1.5-flash-exp-0827",
  "generation_config": {
    "temperature": 0,
    "max_output_tokens": 8196,
    "response_mime_type": "application/json"
  },
  "system_prompt": "You are a helpful AI coding assistant designed to work within a specific program. \n                           The program allows users to send you messages and you respond with either text or JSON.\n                           When the user sends a message starting with '/plan', you are expected to generate a plan \n                           in JSON format according to the Plan schema. This plan will then be executed by the program.\n                           The plan should include a 'suggested_files_to_generate' field, which is a list of paths to all the files\n                           that still need to be generated, in a sensible order for the user to generate them.\n                           Don't include files that have already been generated unless they need to be modified again.\n                           Don't delete files that you are modifying; just overwrite them by adding them to the 'suggested_files_to_generate'.\n                           When the user sends a message starting with '/generate', you are expected to generate content\n                           for the specified files in JSON format.\n                           For all other messages, you should respond with helpful text, potentially including code blocks.\n                           If you get cut off mid code-block, open a new code block and continue writing code from where you left off. \n                           Do not start writing from the beginning of the file; just continue where you left off. \n                           Do not write anything else before doing so in such cases.\n\n                           When the user sends a message starting with '/generate', you can optionally include instructions \n                           after the file path enclosed in double quotes. For example:\n                           /generate path/to/file.txt \"These are instructions for generating file.txt\"\n                           If no instructions are provided, generate the file based on the context of the conversation.",
  "conversation": [
    {
      "role": "user",
      "content": "[{\"path\": \"src/_01_parse_state/frame_stack.rs\", \"tokens\": 2148, \"content\": \"use std::collections::BTreeSet;\\nuse std::hash::Hash;\\n\\nuse crate::U8Set;\\n\\n#[derive(Clone, PartialEq, Debug, Hash, PartialOrd, Ord, Eq)]\\npub struct FrameStack {\\n    frames: Vec<Frame>,\\n}\\n\\nimpl Default for FrameStack {\\n    fn default() -> Self {\\n        Self {\\n            frames: vec![Frame::default()],\\n        }\\n    }\\n}\\n\\n#[derive(Clone, PartialEq, Debug, Default, Eq, Hash, PartialOrd, Ord)]\\npub struct Frame {\\n    pos: BTreeSet<String>,\\n}\\n\\nimpl Frame {\\n    pub fn contains_prefix(&self, name_prefix: &str) -> bool {\\n        self.pos.iter().any(|name| name.starts_with(name_prefix))\\n    }\\n\\n    pub fn contains(&self, name: &str) -> bool {\\n        self.pos.contains(name)\\n    }\\n\\n    pub fn next_u8_given_contains(&self, name: &[u8]) -> (U8Set, bool) {\\n        let mut u8set = U8Set::none();\\n        let mut is_complete = false;\\n        for existing_name in self.pos.iter() {\\n            let existing_name = existing_name.as_bytes();\\n            if name.len() <= existing_name.len() && existing_name[..name.len()] == *name {\\n                let next = existing_name[name.len()..].iter().copied().next();\\n                if let Some(next) = next {\\n                    u8set.insert(next);\\n                } else {\\n                    is_complete = true;\\n                }\\n            }\\n        }\\n        (u8set, is_complete)\\n    }\\n\\n    pub fn push_name(&mut self, name: &[u8]) {\\n        let name: &str = std::str::from_utf8(name).unwrap();\\n        assert!(!self.contains(&name));\\n        self.pos.insert(name.to_string());\\n    }\\n\\n    pub fn pop_name(&mut self, name: &[u8]) {\\n        let name: &str = std::str::from_utf8(name).unwrap();\\n        assert!(self.contains(&name), \\\"{:?} not in {:?}\\\", name, self);\\n        self.pos.remove(name);\\n    }\\n}\\n\\nimpl FrameStack {\\n    pub fn contains_prefix_str(&self, name_prefix: &str) -> bool {\\n        self.frames.iter().any(|frame| frame.contains_prefix(name_prefix))\\n    }\\n\\n    pub fn contains_str(&self, name: &str) -> bool {\\n        self.frames.iter().any(|frame| frame.contains(name))\\n    }\\n\\n    pub fn next_u8_given_contains_u8slice(&self, name: &[u8]) -> (U8Set, bool) {\\n        let mut u8set = U8Set::none();\\n        let mut is_complete = false;\\n        for frame in self.frames.iter().rev() {\\n            let (frame_u8set, frame_is_complete) = frame.next_u8_given_contains(name);\\n            u8set |= frame_u8set;\\n            is_complete |= frame_is_complete;\\n        }\\n        (u8set, is_complete)\\n    }\\n\\n    pub fn contains_prefix_u8vec(&self, name_prefix: &[u8]) -> bool {\\n        self.contains_prefix_str(std::str::from_utf8(name_prefix).unwrap())\\n    }\\n\\n    pub fn contains_u8vec(&self, name: &[u8]) -> bool {\\n        self.contains_str(std::str::from_utf8(name).unwrap())\\n    }\\n\\n    pub fn push_frame(&mut self, new_frame: Frame) {\\n        self.frames.push(new_frame);\\n    }\\n\\n    pub fn push_empty_frame(&mut self) {\\n        self.push_frame(Frame::default());\\n    }\\n\\n    pub fn push_name(&mut self, name: &[u8]) {\\n        self.frames.last_mut().unwrap().push_name(name);\\n    }\\n\\n    pub fn pop_name(&mut self, name: &[u8]) {\\n        self.frames.last_mut().unwrap().pop_name(name);\\n    }\\n\\n    pub fn pop(&mut self) {\\n        self.frames.pop();\\n    }\\n\\n    pub fn filter(&mut self, predicate: impl Fn(&Frame) -> bool) {\\n        self.frames.retain(predicate);\\n    }\\n\\n    pub fn filter_contains(&mut self, name: &[u8]) {\\n        let name = std::str::from_utf8(name).unwrap();\\n        self.filter(|frame| frame.contains(name));\\n    }\\n\\n    pub fn filter_excludes(&mut self, name: &[u8]) {\\n        let name = std::str::from_utf8(name).unwrap();\\n        self.filter(|frame| !frame.contains(name));\\n    }\\n}\\n\\nimpl std::ops::BitOr for Frame {\\n    type Output = Frame;\\n\\n    fn bitor(self, other: Self) -> Frame {\\n        Frame { pos: self.pos.union(&other.pos).cloned().collect() }\\n    }\\n}\\n\\nimpl std::ops::BitOr for FrameStack {\\n    type Output = FrameStack;\\n\\n    fn bitor(self, other: Self) -> FrameStack {\\n        let new_frames = self.frames.iter()\\n            .zip(other.frames.iter())\\n            .map(|(f1, f2)| f1.clone() | f2.clone())\\n            .collect();\\n\\n        FrameStack {\\n            frames: new_frames,\\n        }\\n    }\\n}\"}, {\"path\": \"src/_01_parse_state/mod.rs\", \"tokens\": 50, \"content\": \"pub use parse_results::*;\\npub use right_data::*;\\npub use traits::*;\\n\\nmod parse_results;\\nmod right_data;\\nmod traits;\"}, {\"path\": \"src/_01_parse_state/parse_results.rs\", \"tokens\": 3328, \"content\": \"use crate::internal_vec::VecY;\\nuse crate::{vecy, Fields1, Fields2, RightData, RightDataGetters};\\n\\n#[derive(Debug, Clone, PartialEq, Eq, Hash)]\\npub struct UpData {\\n    right_data: RightData,\\n}\\n\\n#[derive(Debug, Clone, PartialEq, Eq, Hash)]\\npub struct OneShotUpData {\\n    right_data: RightData,\\n}\\n\\n#[derive(Debug, Clone, PartialEq, Eq, Hash)]\\npub struct ParseResults {\\n    pub up_data_vec: VecY<UpData>,\\n    pub done: bool,\\n}\\n\\n#[derive(Debug, Clone, PartialEq, Eq, Hash)]\\npub enum UnambiguousParseError {\\n    Incomplete,\\n    Ambiguous,\\n    Fail,\\n}\\n\\n#[derive(Debug, Clone, PartialEq, Eq, Hash)]\\npub enum ActuallyUnambiguousParseError {\\n    Incomplete,\\n    Fail,\\n}\\n\\npub type UnambiguousParseResults = Result<OneShotUpData, UnambiguousParseError>;\\n\\npub trait ParseResultTrait {\\n    fn done(&self) -> bool;\\n    fn succeeds_decisively(&self) -> bool;\\n    fn merge_assign(&mut self, p0: Self) where Self: Sized;\\n    fn merge(self, p0: Self) -> Self where Self: Sized;\\n    fn combine_seq(&mut self, p0: Self) where Self: Sized;\\n    fn new(up_data_vec: VecY<UpData>, done: bool) -> Self where Self: Sized;\\n    fn new_single(up_data_vec: UpData, done: bool) -> Self where Self: Sized;\\n    fn empty(done: bool) -> Self where Self: Sized;\\n    fn empty_unfinished() -> Self where Self: Sized;\\n    fn empty_finished() -> Self where Self: Sized;\\n}\\n\\nimpl From<ParseResults> for UnambiguousParseResults {\\n    fn from(value: ParseResults) -> Self {\\n        if !value.done() {\\n            return Err(UnambiguousParseError::Incomplete);\\n        }\\n        match value.up_data_vec.as_slice() {\\n            [] => Err(UnambiguousParseError::Fail),\\n            [up_data] => Ok(OneShotUpData { right_data: up_data.right_data.clone() }),\\n            [_, _, ..] => Err(UnambiguousParseError::Ambiguous),\\n        }\\n    }\\n}\\n\\nimpl ParseResultTrait for ParseResults {\\n    fn done(&self) -> bool {\\n        self.done\\n    }\\n    fn succeeds_decisively(&self) -> bool {\\n        self.done() && !self.up_data_vec.is_empty() && !self.up_data_vec.iter().any(|rd| rd.right_data.failable())\\n        // TODO: remove the below line and uncomment the above line\\n        // self.done() && !self.up_data_vec.is_empty()\\n    }\\n    fn new(up_data_vec: VecY<UpData>, done: bool) -> Self {\\n        ParseResults {\\n            up_data_vec,\\n            done,\\n        }\\n    }\\n    fn new_single(up_data: UpData, done: bool) -> Self {\\n        ParseResults {\\n            up_data_vec: vecy![up_data],\\n            done,\\n        }\\n    }\\n    fn empty(done: bool) -> Self {\\n        ParseResults {\\n            up_data_vec: VecY::new(),\\n            done,\\n        }\\n    }\\n    fn empty_unfinished() -> Self {\\n        ParseResults::empty(false)\\n    }\\n    fn empty_finished() -> Self {\\n        ParseResults::empty(true)\\n    }\\n    fn merge_assign(&mut self, mut p0: ParseResults) {\\n        self.up_data_vec.append(&mut p0.up_data_vec);\\n        self.done &= p0.done();\\n    }\\n    fn merge(mut self, p0: ParseResults) -> Self {\\n        self.merge_assign(p0);\\n        self\\n    }\\n    fn combine_seq(&mut self, mut p0: ParseResults) {\\n        self.up_data_vec.append(&mut p0.up_data_vec);\\n        self.done |= p0.done();\\n    }\\n}\\n\\nimpl ParseResultTrait for UnambiguousParseResults {\\n    fn done(&self) -> bool {\\n        match self {\\n            Ok(_) => true,\\n            Err(UnambiguousParseError::Incomplete) => false,\\n            Err(UnambiguousParseError::Ambiguous) => true,\\n            Err(UnambiguousParseError::Fail) => true,\\n        }\\n    }\\n    fn succeeds_decisively(&self) -> bool {\\n        self.is_ok()\\n    }\\n    fn new(up_data_vec: VecY<UpData>, done: bool) -> Self {\\n        match (up_data_vec.len(), done) {\\n            (1, true) => Ok(OneShotUpData { right_data: up_data_vec[0].right_data.clone() }),\\n            (1, false) => Err(UnambiguousParseError::Incomplete),\\n            _ => Err(UnambiguousParseError::Ambiguous),\\n        }\\n    }\\n    fn new_single(up_data: UpData, done: bool) -> Self {\\n        Self::new(vecy![up_data], done)\\n    }\\n    fn empty(done: bool) -> Self {\\n        if done {\\n            Err(UnambiguousParseError::Fail)\\n        } else {\\n            Err(UnambiguousParseError::Incomplete)\\n        }\\n    }\\n    fn empty_unfinished() -> Self {\\n        Err(UnambiguousParseError::Incomplete)\\n    }\\n    fn empty_finished() -> Self {\\n        Err(UnambiguousParseError::Fail)\\n    }\\n    fn merge_assign(&mut self, p0: Self) {\\n        // This is a bit of a hack, but it should work\\n        *self = self.clone().merge(p0);\\n    }\\n    fn merge(self, p0: Self) -> Self {\\n        match (self, p0) {\\n            (Ok(up_data1), Ok(up_data2)) => {\\n                if up_data1 == up_data2 {\\n                    Ok(up_data1)\\n                } else {\\n                    Err(UnambiguousParseError::Ambiguous)\\n                }\\n            },\\n            (Ok(up_data), Err(UnambiguousParseError::Incomplete)) => Ok(up_data),\\n            (Err(UnambiguousParseError::Incomplete), Ok(up_data)) => Ok(up_data),\\n            (Err(UnambiguousParseError::Incomplete), Err(UnambiguousParseError::Incomplete)) => Err(UnambiguousParseError::Incomplete),\\n            (Err(e), _) => Err(e),\\n            (_, Err(e)) => Err(e),\\n        }\\n    }\\n    fn combine_seq(&mut self, p0: Self) {\\n        // This is a bit of a hack, but it should work\\n        *self = self.clone().merge(p0);\\n    }\\n}\\n\\nimpl UpData {\\n    pub fn new(right_data: RightData) -> Self {\\n        Self { right_data }\\n    }\\n}\\n\\nimpl OneShotUpData {\\n    pub fn new(right_data: RightData) -> Self {\\n        Self { right_data }\\n    }\\n}\\n\\nimpl RightDataGetters for UpData {\\n    fn get_fields1(&self) -> &Fields1 { self.right_data.get_fields1() }\\n    fn get_fields1_mut(&mut self) -> &mut Fields1 { self.right_data.get_fields1_mut() }\\n    fn get_fields2(&self) -> &Fields2 { self.right_data.get_fields2() }\\n    fn get_fields2_mut(&mut self) -> &mut Fields2 { self.right_data.get_fields2_mut() }\\n    fn just_right_data(self) -> RightData { self.right_data }\\n}\\n\\nimpl RightDataGetters for OneShotUpData {\\n    fn get_fields1(&self) -> &Fields1 { self.right_data.get_fields1() }\\n    fn get_fields1_mut(&mut self) -> &mut Fields1 { self.right_data.get_fields1_mut() }\\n    fn get_fields2(&self) -> &Fields2 { self.right_data.get_fields2() }\\n    fn get_fields2_mut(&mut self) -> &mut Fields2 { self.right_data.get_fields2_mut() }\\n    fn just_right_data(self) -> RightData { self.right_data }\\n}\"}, {\"path\": \"src/_01_parse_state/right_data.rs\", \"tokens\": 1964, \"content\": \"use derivative::Derivative;\\nuse std::rc::Rc;\\n\\nuse crate::internal_vec::VecZ;\\nuse crate::{ForbidFollowsData, LookaheadData, PythonQuoteType};\\n\\n#[repr(packed(1))]\\n#[derive(Debug, Clone, Copy, Hash, PartialEq, Eq)]\\npub struct Fields1 {\\n    pub lookahead_data: LookaheadData,\\n    pub position: usize,\\n    pub forbidden_consecutive_matches: ForbidFollowsData,\\n    pub dedents: u8,\\n    pub scope_count: u8\\n}\\n\\n#[derive(Debug, Clone, PartialEq, Eq)]\\npub struct Fields2 {\\n    // #[derivative(Hash = \\\"ignore\\\")]\\n    // pub frame_stack: Option<FrameStack>,\\n    pub indents: VecZ<Vec<u8>>,\\n    pub fstring_start_stack: VecZ<PythonQuoteType>\\n}\\n\\n#[derive(Derivative)]\\n#[derivative(Debug, Clone, Hash, PartialEq, Eq)]\\npub struct RightDataInner {\\n    fields1: Fields1,\\n    #[derivative(Hash = \\\"ignore\\\")]\\n    fields2: Rc<Fields2>,\\n    // pub fields2: Box<Fields2>,\\n    // pub fields2: Fields2,\\n}\\n\\n#[derive(Derivative)]\\n#[derivative(Debug, Clone, Hash, PartialEq, Eq)]\\npub struct RightData {\\n    right_data_inner: Rc<RightDataInner>,\\n    // pub right_data_inner: Box<RightDataInner>,\\n    // pub right_data_inner: RightDataInner,\\n}\\n\\nimpl Default for RightData {\\n    fn default() -> Self {\\n        // Print the size of RightDataInner\\n        println!(\\\"RightDataInner size: {}\\\", std::mem::size_of::<RightDataInner>());\\n        Self {\\n            right_data_inner: RightDataInner {\\n                // frame_stack: None,\\n                fields2: Fields2 { indents: VecZ::new(), fstring_start_stack: VecZ::new() }.into(),\\n                fields1: Fields1 { dedents: 0, scope_count: 0, forbidden_consecutive_matches: ForbidFollowsData::default(), lookahead_data: LookaheadData::default(), position: 0 },\\n            }.into()\\n        }\\n    }\\n}\\n\\nimpl RightData {\\n    pub fn advance(&mut self, n: usize) {\\n        self.get_inner_mut().fields1.position += n;\\n    }\\n\\n    pub fn with_position(mut self, position: usize) -> Self {\\n        self.get_inner_mut().fields1.position = position;\\n        self\\n    }\\n\\n    pub fn failable(&self) -> bool {\\n        self.right_data_inner.fields1.lookahead_data.has_omitted_partial_lookaheads\\n    }\\n\\n    pub fn get_inner_mut(&mut self) -> &mut RightDataInner {\\n        Rc::make_mut(&mut self.right_data_inner)\\n        // &mut *self.right_data_inner\\n        // &mut self.right_data_inner\\n    }\\n}\\n\\npub trait RightDataGetters {\\n    fn get_fields1(&self) -> &Fields1;\\n    fn get_fields1_mut(&mut self) -> &mut Fields1;\\n    fn get_fields2(&self) -> &Fields2;\\n    fn get_fields2_mut(&mut self) -> &mut Fields2;\\n    fn just_right_data(self) -> RightData;\\n}\\n\\nimpl RightDataGetters for RightDataInner {\\n    fn get_fields1(&self) -> &Fields1 {\\n        &self.fields1\\n    }\\n\\n    fn get_fields1_mut(&mut self) -> &mut Fields1 {\\n        &mut self.fields1\\n    }\\n\\n    fn get_fields2(&self) -> &Fields2 {\\n        &self.fields2\\n    }\\n\\n    fn get_fields2_mut(&mut self) -> &mut Fields2 {\\n        Rc::make_mut(&mut self.fields2)\\n        // &mut *self.fields2\\n        // &mut self.fields2\\n    }\\n\\n    fn just_right_data(self) -> RightData {\\n        RightData { right_data_inner: Rc::new(self) }\\n    }\\n}\\n\\nimpl RightDataGetters for RightData {\\n    fn get_fields1(&self) -> &Fields1 {\\n        self.right_data_inner.get_fields1()\\n    }\\n\\n    fn get_fields1_mut(&mut self) -> &mut Fields1 {\\n        Rc::make_mut(&mut self.right_data_inner).get_fields1_mut()\\n    }\\n\\n    fn get_fields2(&self) -> &Fields2 {\\n        self.right_data_inner.get_fields2()\\n    }\\n\\n    fn get_fields2_mut(&mut self) -> &mut Fields2 {\\n        Rc::make_mut(&mut self.right_data_inner).get_fields2_mut()\\n    }\\n\\n    fn just_right_data(self) -> RightData {\\n        RightData { right_data_inner: self.right_data_inner }\\n    }\\n}\"}, {\"path\": \"src/_01_parse_state/traits.rs\", \"tokens\": 2874, \"content\": \"use crate::{RightData, RightDataGetters};\\nuse crate::{profile, LookaheadData, ParseResultTrait, ParseResults, UpData, VecY};\\nuse std::collections::{HashMap, HashSet};\\nuse std::hash::{Hash, Hasher};\\n\\n// macro_rules! profile {\\n//     ($tag:expr, $body:expr) => {{\\n//         $crate::profile!($tag, $body)\\n//     }};\\n// }\\n\\n// macro_rules! profile {\\n//     ($tag:expr, $body:expr) => {{\\n//         $body\\n//     }};\\n// }\\n\\nconst SQUASH_THRESHOLD: usize = 1;\\n\\npub trait Squash {\\n    type Output;\\n    fn squashed(self) -> Self::Output;\\n    fn squash(&mut self);\\n}\\n\\nimpl Squash for VecY<UpData> {\\n    type Output = VecY<UpData>;\\n    fn squashed(self) -> Self::Output {\\n        if self.len() > SQUASH_THRESHOLD {\\n            profile!(\\\"RightDataSquasher::squashed\\\", {\\n                // let mut squasher = RightDataSquasher::new();\\n                // squasher.extend(self.into_iter());\\n                // squasher.finish()\\n                self.into_iter().collect::<HashSet<_>>().into_iter().collect()\\n            })\\n        } else {\\n            self\\n        }\\n    }\\n    fn squash(&mut self) {\\n        if self.len() > SQUASH_THRESHOLD {\\n            *self = self.drain(..).collect::<VecY<UpData>>().squashed()\\n        }\\n    }\\n}\\n\\nimpl Squash for ParseResults {\\n    type Output = ParseResults;\\n    fn squashed(self) -> Self::Output {\\n        if self.up_data_vec.len() > SQUASH_THRESHOLD {\\n            profile!(\\\"ParseResults::squashed\\\", {\\n                    let done = self.done();\\n                    ParseResults::new(self.up_data_vec.squashed(), done)\\n                }\\n            )\\n        } else {\\n            self\\n        }\\n    }\\n    fn squash(&mut self) {\\n        profile!(\\\"ParseResults::squash\\\", {\\n        if self.up_data_vec.len() > SQUASH_THRESHOLD {\\n            // *self.right_data_vec = std::mem::take(&mut self.right_data_vec).squashed();\\n            *self = self.clone().squashed();\\n        }\\n            })\\n    }\\n}\\n\\n#[derive(Debug, Default, Clone, PartialEq, Eq)]\\npub struct RightDataSquasher {\\n    decomposed: HashMap<RightData, LookaheadData>,\\n}\\n\\nimpl Hash for RightDataSquasher {\\n    fn hash<H: Hasher>(&self, state: &mut H) {\\n        self.decomposed.len().hash(state);\\n    }\\n}\\n\\nimpl RightDataSquasher {\\n    pub fn new() -> Self {\\n        Self {\\n            decomposed: HashMap::new(),\\n        }\\n    }\\n\\n    pub fn push(&mut self, mut right_data: RightData) {\\n        let lookahead_data = std::mem::take(&mut right_data.get_inner_mut().get_fields1_mut().lookahead_data);\\n        let mut existing_lookahead_data = self.decomposed.entry(right_data).or_insert_with_key(|_| lookahead_data.clone());\\n        // TODO: In general, all the lookaheads needs to be satisfied, i.e. it's an AND operation between Vecs of lookaheads. But this implies OR.\\n        existing_lookahead_data.has_omitted_partial_lookaheads &= lookahead_data.has_omitted_partial_lookaheads;\\n    }\\n\\n    pub fn extend(&mut self, right_data_vec: impl IntoIterator<Item = RightData>) {\\n        profile!(\\\"RightDataSquasher::extend\\\", {\\n        for right_data in right_data_vec {\\n            self.push(right_data);\\n        }\\n            })\\n    }\\n\\n    pub fn finish(self) -> VecY<UpData> {\\n        profile!(\\\"RightDataSquasher::finish\\\", {\\n            let mut result = VecY::new();\\n            for (mut right_data, lookahead_data) in self.decomposed {\\n                right_data.get_inner_mut().get_fields1_mut().lookahead_data = lookahead_data;\\n                result.push(UpData::new(right_data));\\n            }\\n            result\\n        })\\n    }\\n}\\n\\nimpl From<Vec<RightData>> for RightDataSquasher {\\n    fn from(right_data_vec: Vec<RightData>) -> Self {\\n        profile!(\\\"RightDataSquasher::from\\\", {\\n            let mut squasher = RightDataSquasher::new();\\n            squasher.extend(right_data_vec);\\n            squasher\\n        })\\n    }\\n}\\n\\nimpl RightDataSquasher {\\n    pub fn into_iter(self) -> RightDataSquasherIterator {\\n        RightDataSquasherIterator {\\n            inner: self.decomposed.into_iter()\\n        }\\n    }\\n}\\n\\npub struct RightDataSquasherIterator {\\n    inner: std::collections::hash_map::IntoIter<RightData, LookaheadData>,\\n}\\n\\nimpl Iterator for RightDataSquasherIterator {\\n    type Item = (RightData, LookaheadData);\\n\\n    fn next(&mut self) -> Option<Self::Item> {\\n        self.inner.next()\\n    }\\n}\\n\\nimpl IntoIterator for RightDataSquasher {\\n    type Item = (RightData, LookaheadData);\\n    type IntoIter = RightDataSquasherIterator;\\n\\n    fn into_iter(self) -> Self::IntoIter {\\n        self.into_iter()\\n    }\\n}\\n\\npub struct RightDataSquasherIteratorMut<'a> {\\n    inner: std::collections::hash_map::IterMut<'a, RightData, LookaheadData>,\\n}\\n\\nimpl<'a> Iterator for RightDataSquasherIteratorMut<'a> {\\n    type Item = (&'a RightData, &'a mut LookaheadData);\\n\\n    fn next(&mut self) -> Option<Self::Item> {\\n        self.inner.next()\\n    }\\n}\\n\\nimpl RightDataSquasher {\\n    pub fn iter(&self) -> RightDataSquasherIterator {\\n        RightDataSquasherIterator {\\n            inner: self.decomposed.clone().into_iter()\\n        }\\n    }\\n\\n    pub fn iter_mut(&mut self) -> RightDataSquasherIteratorMut {\\n        RightDataSquasherIteratorMut {\\n            inner: self.decomposed.iter_mut()\\n        }\\n    }\\n\\n    pub fn is_empty(&self) -> bool {\\n        self.decomposed.is_empty()\\n    }\\n\\n    pub fn len(&self) -> usize {\\n        self.decomposed.len()\\n    }\\n\\n    pub fn clear(&mut self) {\\n        self.decomposed.clear();\\n    }\\n\\n    pub fn append(&mut self, right_data_squasher: &mut RightDataSquasher) {\\n        profile!(\\\"RightDataSquasher::append\\\", {\\n        for right_data in right_data_squasher.decomposed.drain() {\\n            self.push(right_data.0);\\n        }\\n            })\\n    }\\n\\n    pub fn retain(&mut self, f: impl Fn(&RightData) -> bool) {\\n        self.decomposed.retain(|right_data, _| f(right_data));\\n    }\\n}\"}, {\"path\": \"src/_02_traits/combinator.rs\", \"tokens\": 3078, \"content\": \"\\n// src/_02_traits/combinator.rs\\nuse crate::{ParseResultTrait, ParseResults, RightData, RightDataGetters, U8Set, UnambiguousParseResults, UpData, OneShotUpData};\\nuse std::fmt::Display;\\n\\n#[macro_export]\\nmacro_rules! match_enum {\\n    ($expr:expr, $enum:ident, $inner:ident => $arm:expr, $($variant:ident),*) => {\\n        match $expr {\\n            $(\\n                $enum::$variant($inner) => $arm,\\n            )*\\n        }\\n    };\\n}\\n\\n// Removed Parser enum\\npub trait CombinatorTrait: BaseCombinatorTrait + DynCombinatorTrait + std::fmt::Debug {\\n    type Parser<'a>: ParserTrait where Self: 'a;\\n    type Output;\\n    type PartialOutput;\\n\\n    fn old_parse<'a>(&'a self, right_data: RightData, bytes: &[u8]) -> (Self::Parser<'a>, ParseResults);\\n    fn parse<'a>(&'a self, right_data: RightData, bytes: &[u8]) -> (Self::Parser<'a>, ParseResults) {\\n        self.old_parse(right_data, bytes)\\n    }\\n    fn one_shot_parse(&self, right_data: RightData, bytes: &[u8]) -> UnambiguousParseResults;\\n}\\n\\npub trait DynCombinatorTrait: BaseCombinatorTrait + std::fmt::Debug {\\n    fn parse_dyn<'a>(&'a self, right_data: RightData, bytes: &[u8]) -> (Box<dyn ParserTrait + 'a>, ParseResults);\\n    fn one_shot_parse_dyn<'a>(&'a self, right_data: RightData, bytes: &[u8]) -> UnambiguousParseResults;\\n}\\n\\npub trait BaseCombinatorTrait {\\n    fn as_any(&self) -> &dyn std::any::Any where Self: 'static;\\n    fn type_name(&self) -> &str {\\n        std::any::type_name::<Self>()\\n    }\\n    fn apply_to_children(&self, f: &mut dyn FnMut(&dyn BaseCombinatorTrait)) {}\\n    fn compile(mut self) -> Self\\n    where\\n        Self: Sized\\n    {\\n        self.compile_inner();\\n        self\\n    }\\n    fn compile_inner(&self) {\\n        self.apply_to_children(&mut |combinator| combinator.compile_inner());\\n    }\\n}\\n\\npub fn dumb_one_shot_parse<T: CombinatorTrait>(combinator: &T, right_data: RightData, bytes: &[u8]) -> UnambiguousParseResults {\\n    let (parser, parse_results) = combinator.old_parse(right_data, bytes);\\n    UnambiguousParseResults::from(parse_results)\\n}\\n\\npub trait ParserTrait: std::fmt::Debug {\\n    fn get_u8set(&self) -> U8Set;\\n    fn parse(&mut self, bytes: &[u8]) -> ParseResults;\\n    fn autoparse(&mut self, right_data: RightData, max_length: usize) -> (Vec<u8>, ParseResults) {\\n        let mut prefix = Vec::new();\\n        let mut parse_results = ParseResults::empty_finished();\\n        while prefix.len() < max_length {\\n            let u8set = self.get_u8set();\\n            if u8set.len() == 1 {\\n                let c = u8set.iter().next().unwrap();\\n                let new_parse_results = self.parse(&[c]);\\n                parse_results.combine_seq(new_parse_results);\\n                prefix.push(c);\\n            } else {\\n                break;\\n            }\\n        }\\n        (prefix, parse_results)\\n    }\\n}\\n\\nimpl<T: DynCombinatorTrait + ?Sized> DynCombinatorTrait for Box<T> {\\n    fn parse_dyn(&self, right_data: RightData, bytes: &[u8]) -> (Box<dyn ParserTrait + '_>, ParseResults) {\\n        (**self).parse_dyn(right_data, bytes)\\n    }\\n\\n    fn one_shot_parse_dyn<'a>(&'a self, right_data: RightData, bytes: &[u8]) -> UnambiguousParseResults {\\n        (**self).one_shot_parse_dyn(right_data, bytes)\\n    }\\n}\\n\\nimpl<T: CombinatorTrait + ?Sized> CombinatorTrait for Box<T> {\\n    type Parser<'a> = T::Parser<'a> where Self: 'a;\\n    type Output = T::Output;\\n    type PartialOutput = T::PartialOutput;\\n\\n    fn one_shot_parse(&self, right_data: RightData, bytes: &[u8]) -> UnambiguousParseResults {\\n        (**self).one_shot_parse(right_data, bytes)\\n    }\\n\\n    fn old_parse(&self, right_data: RightData, bytes: &[u8]) -> (Self::Parser<'_>, ParseResults) {\\n        (**self).old_parse(right_data, bytes)\\n    }\\n\\n    fn parse(&self, right_data: RightData, bytes: &[u8]) -> (Self::Parser<'_>, ParseResults) {\\n        (**self).parse(right_data, bytes)\\n    }\\n\\n}\\n\\nimpl<T: BaseCombinatorTrait + ?Sized> BaseCombinatorTrait for Box<T> {\\n    fn as_any(&self) -> &dyn std::any::Any where Self: 'static {\\n        (**self).as_any()\\n    }\\n    fn type_name(&self) -> &str {\\n        (**self).type_name()\\n    }\\n    fn apply_to_children(&self, f: &mut dyn FnMut(&dyn BaseCombinatorTrait)) {\\n        (**self).apply_to_children(f);\\n    }\\n    fn compile_inner(&self) {\\n        (**self).compile_inner();\\n    }\\n}\\n\\nimpl<'a> ParserTrait for Box<dyn ParserTrait + 'a> {\\n    fn get_u8set(&self) -> U8Set {\\n        (**self).get_u8set()\\n    }\\n\\n    fn parse(&mut self, bytes: &[u8]) -> ParseResults {\\n        (**self).parse(bytes)\\n    }\\n}\\n\\nimpl<'b> CombinatorTrait for Box<dyn DynCombinatorTrait + 'b> {\\n    type Parser<'a> = Box<dyn ParserTrait + 'a> where Self: 'a;\\n    type Output = Box<dyn std::any::Any>;\\n    type PartialOutput = Box<dyn std::any::Any>;\\n\\n    fn one_shot_parse(&self, right_data: RightData, bytes: &[u8]) -> UnambiguousParseResults {\\n        (**self).one_shot_parse_dyn(right_data, bytes)\\n    }\\n\\n    fn old_parse(&self, right_data: RightData, bytes: &[u8]) -> (Self::Parser<'_>, ParseResults) {\\n        (**self).parse_dyn(right_data, bytes)\\n    }\\n}\\n\\n// Removed ParserTrait implementation for Parser enum\\n\\npub trait CombinatorTraitExt: CombinatorTrait {\\n    fn parser(&self, right_data: RightData) -> (Self::Parser<'_>, ParseResults) {\\n        self.old_parse(right_data, &[])\\n    }\\n}\\n\\npub trait ParserTraitExt: ParserTrait {\\n    fn step(&mut self, c: u8) -> ParseResults {\\n        self.parse(&[c])\\n    }\\n}\\n\\nimpl<T: CombinatorTrait> CombinatorTraitExt for T {}\\nimpl<T: ParserTrait> ParserTraitExt for T {}\"}, {\"path\": \"src/_02_traits/convert.rs\", \"tokens\": 768, \"content\": \"use crate::tokenizer::finite_automata::Expr;\\n// src/convert.rs\\nuse crate::{fast_combinator, CombinatorTrait, DynCombinatorTrait, FastCombinatorWrapper, StrongRef, Symbol};\\n\\npub trait IntoCombinator {\\n    type Output: CombinatorTrait;\\n    fn into_combinator(self) -> Self::Output;\\n}\\n\\nimpl<T: CombinatorTrait> IntoCombinator for T {\\n    type Output = Self;\\n    fn into_combinator(self) -> Self::Output {\\n        self\\n    }\\n}\\n\\n// impl<T: IntoCombinator, F: Fn() -> T> IntoCombinator for F {\\n//     type Output = T::Output;\\n//     fn into_combinator(self) -> Self::Output {\\n//         self().into_combinator()\\n//     }\\n// }\\n\\nimpl<T: CombinatorTrait> IntoCombinator for &Symbol<T> {\\n    type Output = Symbol<T>;\\n    fn into_combinator(self) -> Self::Output {\\n        self.clone()\\n    }\\n}\\n\\nimpl<T: CombinatorTrait> IntoCombinator for &StrongRef<T> {\\n    type Output = StrongRef<T>;\\n    fn into_combinator(self) -> Self::Output {\\n        self.clone()\\n    }\\n}\\n\\nimpl IntoCombinator for Expr {\\n    type Output = FastCombinatorWrapper;\\n    fn into_combinator(self) -> Self::Output {\\n        fast_combinator(self)\\n    }\\n}\\n\\npub trait IntoDyn<'a> {\\n    fn into_dyn(self) -> Box<dyn DynCombinatorTrait + 'a>;\\n}\\n\\nimpl<'a, T: CombinatorTrait + 'a> IntoDyn<'a> for T {\\n    fn into_dyn(self) -> Box<dyn DynCombinatorTrait + 'a> {\\n        Box::new(self)\\n    }\\n}\"}, {\"path\": \"src/_03_combinators/cache.rs\", \"tokens\": 6422, \"content\": \"\\n// src/_03_combinators/cache.rs\\nuse crate::RightData;\\n// src/combinators/cache.rs\\n// src/combinators/cache.rs\\nuse crate::{BaseCombinatorTrait, DynCombinatorTrait, UnambiguousParseResults, UpData, OneShotUpData};\\nuse std::cell::RefCell;\\nuse std::collections::HashMap;\\nuse std::hash::{Hash, Hasher};\\nuse std::intrinsics::transmute;\\nuse std::num::NonZeroUsize;\\nuse std::rc::Rc;\\n\\nuse crate::{count_hit, profile, profile_internal, CombinatorTrait, IntoCombinator, ParseResultTrait, ParseResults, ParserTrait, Squash, U8Set};\\nuse derivative::Derivative;\\nuse lru::LruCache;\\n\\n\\n// macro_rules! profile {\\n//     ($tag:expr, $body:expr) => {{\\n//         $body\\n//     }};\\n// }\\n\\n// macro_rules! count_hit { ($tag:expr) => {} }\\n\\nthread_local! {\\n    pub static GLOBAL_CACHE: RefCell<GlobalCache> = RefCell::new(GlobalCache::new());\\n}\\n\\n#[derive(Debug)]\\nstruct GlobalCache {\\n    new_parsers: HashMap<usize, LruCache<CacheKey, Rc<RefCell<CacheEntry>>>>,\\n    pub(crate) entries: HashMap<usize, Vec<Rc<RefCell<CacheEntry>>>>,\\n    pub one_shot_results: HashMap<usize, LruCache<CacheKey, UnambiguousParseResults>>,\\n    pub(crate) parse_id_counter: usize,\\n    pub(crate) parse_id: Option<usize>,\\n}\\n\\nimpl GlobalCache {\\n    fn new() -> Self {\\n        Self {\\n            new_parsers: HashMap::new(),\\n            entries: HashMap::new(),\\n            one_shot_results: HashMap::new(),\\n            parse_id_counter: 0,\\n            parse_id: None,\\n        }\\n    }\\n\\n    fn cleanup(&mut self) {\\n        let parse_id = self.parse_id.take().unwrap();\\n        self.new_parsers.get_mut(&parse_id).unwrap().clear();\\n        self.entries.get_mut(&parse_id).unwrap().retain(|entry| !entry.borrow().maybe_parse_results.as_ref().unwrap().done());\\n    }\\n\\n    fn one_shot_cleanup(&mut self) {\\n        let parse_id = self.parse_id.take().unwrap();\\n        self.one_shot_results.get_mut(&parse_id).unwrap().clear();\\n    }\\n}\\n\\n#[derive(Debug)]\\nstruct CacheKey {\\n    combinator: *const dyn DynCombinatorTrait,\\n    right_data: RightData,\\n}\\n\\nimpl Hash for CacheKey {\\n    fn hash<H: Hasher>(&self, state: &mut H) {\\n        self.combinator.hash(state);\\n        self.right_data.hash(state);\\n    }\\n}\\n\\nimpl PartialEq for CacheKey {\\n    fn eq(&self, other: &Self) -> bool {\\n        self.combinator == other.combinator && self.right_data == other.right_data\\n    }\\n}\\n\\nimpl Eq for CacheKey {}\\n\\n#[derive(Derivative)]\\n#[derivative(Debug)]\\nstruct CacheEntry {\\n    pub(crate) parser: Option<Box<dyn ParserTrait>>,\\n    maybe_parse_results: Option<ParseResults>,\\n    maybe_u8set: Option<U8Set>,\\n}\\n\\n#[derive(Debug)]\\npub struct CacheContext<T: CombinatorTrait> {\\n    pub inner: T,\\n}\\n\\n#[derive(Debug)]\\npub struct Cached<T: CombinatorTrait> {\\n    pub inner: T,\\n}\\n\\n#[derive(Debug)]\\npub struct CachedParser {\\n    pub entry: Rc<RefCell<CacheEntry>>,\\n}\\n\\nimpl Hash for CachedParser {\\n    fn hash<H: Hasher>(&self, state: &mut H) {\\n        std::ptr::hash(self.entry.as_ref() as *const RefCell<CacheEntry>, state);\\n    }\\n}\\n\\nimpl PartialEq for CachedParser {\\n    fn eq(&self, other: &Self) -> bool {\\n        Rc::ptr_eq(&self.entry, &other.entry)\\n    }\\n}\\n\\n#[derive(Derivative)]\\n#[derivative(Debug)]\\npub struct CacheContextParser<'a> {\\n    pub inner: Box<dyn ParserTrait + 'a>,\\n    pub(crate) parse_id: usize,\\n}\\n\\nimpl<T: CombinatorTrait> DynCombinatorTrait for CacheContext<T> {\\n    fn parse_dyn(&self, right_data: RightData, bytes: &[u8]) -> (Box<dyn ParserTrait + '_>, ParseResults) {\\n        let (parser, parse_results) = self.parse(right_data, bytes);\\n        (Box::new(parser), parse_results)\\n    }\\n\\n    fn one_shot_parse_dyn<'a>(&'a self, right_data: RightData, bytes: &[u8]) -> UnambiguousParseResults {\\n        self.one_shot_parse(right_data, bytes)\\n    }\\n}\\n\\nimpl<T: CombinatorTrait> CombinatorTrait for CacheContext<T> {\\n    type Parser<'a> = CacheContextParser<'a> where Self: 'a;\\n    type Output = T::Output;\\n    type PartialOutput = T::PartialOutput;\\n\\n    fn one_shot_parse(&self, right_data: RightData, bytes: &[u8]) -> UnambiguousParseResults {\\n        profile!(\\\"CacheContext.one_shot_parse: start\\\", {\\n        GLOBAL_CACHE.with(|cache| {\\n            let parse_id = {\\n                let mut global_cache = cache.borrow_mut();\\n                let parse_id = global_cache.parse_id_counter;\\n                global_cache.new_parsers.insert(parse_id, LruCache::new(NonZeroUsize::new(64).unwrap()));\\n                global_cache.entries.insert(parse_id, Vec::new());\\n                global_cache.one_shot_results.insert(parse_id, LruCache::new(NonZeroUsize::new(64).unwrap()));\\n                global_cache.parse_id = Some(global_cache.parse_id_counter);\\n                global_cache.parse_id_counter += 1;\\n                parse_id\\n            };\\n            let parse_result = self.inner.one_shot_parse(right_data, bytes);\\n            let mut global_cache = cache.borrow_mut();\\n            global_cache.one_shot_cleanup();\\n            parse_result\\n        })\\n            })\\n    }\\n\\n    fn old_parse(&self, right_data: RightData, bytes: &[u8]) -> (Self::Parser<'_>, ParseResults) {\\n        profile!(\\\"CacheContext.old_parse: start\\\", {\\n        GLOBAL_CACHE.with(|cache| {\\n            let parse_id = {\\n                let mut global_cache = cache.borrow_mut();\\n                let parse_id = global_cache.parse_id_counter;\\n                global_cache.new_parsers.insert(parse_id, LruCache::new(NonZeroUsize::new(64).unwrap()));\\n                global_cache.entries.insert(parse_id, Vec::new());\\n                global_cache.one_shot_results.insert(parse_id, LruCache::new(NonZeroUsize::new(64).unwrap()));\\n                global_cache.parse_id = Some(global_cache.parse_id_counter);\\n                global_cache.parse_id_counter += 1;\\n                parse_id\\n            };\\n            let (parser, results) = profile!(\\\"CacheContext.parse: inner.parse\\\", self.inner.parse(right_data, bytes));\\n            let mut global_cache = cache.borrow_mut();\\n            global_cache.entries.get_mut(&parse_id).unwrap().reverse();\\n            global_cache.cleanup();\\n            let cache_context_parser = CacheContextParser { inner: Box::new(parser), parse_id };\\n            (cache_context_parser, results)\\n        })\\n        })\\n    }\\n}\\n\\nimpl<T: CombinatorTrait> BaseCombinatorTrait for CacheContext<T> {\\n    fn as_any(&self) -> &dyn std::any::Any where Self: 'static {\\n        self\\n    }\\n    fn apply_to_children(&self, f: &mut dyn FnMut(&dyn BaseCombinatorTrait)) {\\n        f(&self.inner);\\n    }\\n}\\n\\nimpl ParserTrait for CacheContextParser<'_> {\\n    fn get_u8set(&self) -> U8Set {\\n        self.inner.as_ref().get_u8set()\\n    }\\n\\n    fn parse(&mut self, bytes: &[u8]) -> ParseResults {\\n        profile!(\\\"CacheContextParser.parse: start\\\", {\\n        GLOBAL_CACHE.with(|cache| {\\n            {\\n                let mut global_cache = cache.borrow_mut();\\n                global_cache.parse_id = Some(self.parse_id);\\n                global_cache.entries.get_mut(&self.parse_id).unwrap().iter_mut().for_each(|entry| {\\n                    entry.borrow_mut().maybe_parse_results.take();\\n                    entry.borrow_mut().maybe_u8set.take();\\n                });\\n            }\\n            let num_entries_initial = cache.borrow_mut().entries[&self.parse_id].len();\\n            for i in (0..num_entries_initial).rev() {\\n                let entry_refcell = cache.borrow_mut().entries[&self.parse_id][i].clone();\\n                let mut entry = entry_refcell.borrow_mut();\\n                let parse_results = profile!(\\\"CacheContextParser.parse: entry.parser.parse\\\", entry.parser.as_mut().unwrap().parse(bytes));\\n                entry.maybe_parse_results = Some(parse_results);\\n            }\\n\\n            let parse_result = profile!(\\\"CacheContextParser.parse: inner.parse\\\", self.inner.as_mut().parse(bytes));\\n\\n            let mut global_cache = cache.borrow_mut();\\n            let mut new_entries = global_cache.entries.get_mut(&self.parse_id).unwrap().split_off(num_entries_initial);\\n            new_entries.reverse();\\n            global_cache.entries.get_mut(&self.parse_id).unwrap().append(&mut new_entries);\\n            global_cache.cleanup();\\n            parse_result\\n        })\\n        })\\n    }\\n}\\n\\nimpl<T: CombinatorTrait> DynCombinatorTrait for Cached<T> {\\n    fn parse_dyn(&self, right_data: RightData, bytes: &[u8]) -> (Box<dyn ParserTrait + '_>, ParseResults) {\\n        let (parser, parse_results) = self.parse(right_data, bytes);\\n        (Box::new(parser), parse_results)\\n    }\\n\\n    fn one_shot_parse_dyn<'a>(&'a self, right_data: RightData, bytes: &[u8]) -> UnambiguousParseResults {\\n        self.one_shot_parse(right_data, bytes)\\n    }\\n}\\n\\nimpl<T: CombinatorTrait> CombinatorTrait for Cached<T> {\\n    type Parser<'a> = CachedParser where Self: 'a;\\n    type Output = T::Output;\\n    type PartialOutput = T::PartialOutput;\\n\\n    fn one_shot_parse(&self, right_data: RightData, bytes: &[u8]) -> UnambiguousParseResults {\\n        GLOBAL_CACHE.with(move |cache| {\\n            let key = CacheKey { combinator: std::ptr::addr_of!(self.inner) as *const dyn DynCombinatorTrait, right_data: right_data.clone() };\\n\\n            let mut global_cache = cache.borrow_mut();\\n            let parse_id = global_cache.parse_id.unwrap();\\n            if let Some(entry) = profile!(\\\"Cached.parse: check cache: get entry\\\", {\\n                global_cache.one_shot_results.get_mut(&parse_id).unwrap().get(&key).cloned()\\n            }) {\\n                count_hit!(\\\"Cached.parse: cache hit\\\");\\n                return entry;\\n            }\\n            drop(global_cache);\\n\\n            count_hit!(\\\"Cached.parse: cache miss\\\");\\n            let inner = &self.inner;\\n            let parse_result: UnambiguousParseResults = profile!(\\\"Cached.parse: inner.one_shot_parse\\\", inner.one_shot_parse(right_data, bytes));\\n            let mut global_cache = cache.borrow_mut();\\n            let parse_id = global_cache.parse_id.unwrap();\\n            global_cache.one_shot_results.get_mut(&parse_id).unwrap().put(key, parse_result.clone());\\n            parse_result\\n        })\\n    }\\n\\n    fn old_parse(&self, right_data: RightData, bytes: &[u8]) -> (Self::Parser<'_>, ParseResults) {\\n        GLOBAL_CACHE.with(move |cache| {\\n            let key = CacheKey { combinator: std::ptr::addr_of!(self.inner) as *const dyn DynCombinatorTrait, right_data: right_data.clone() };\\n\\n            let mut global_cache = cache.borrow_mut();\\n            let parse_id = global_cache.parse_id.unwrap();\\n            if let Some(entry) = profile!(\\\"Cached.parse: check cache: get entry\\\", {\\n                global_cache.new_parsers.get_mut(&parse_id).unwrap().get(&key).cloned()\\n            }) {\\n                count_hit!(\\\"Cached.parse: cache hit\\\");\\n                let parse_results = entry.borrow().maybe_parse_results.clone().expect(\\\"CachedParser.parser: parse_results is None\\\");\\n                return (CachedParser { entry }, parse_results);\\n            }\\n            drop(global_cache);\\n\\n            count_hit!(\\\"Cached.parse: cache miss\\\");\\n            let entry = Rc::new(RefCell::new(CacheEntry {\\n                parser: None,\\n                maybe_parse_results: None,\\n                maybe_u8set: None,\\n            }));\\n            // let inner: &'static T = unsafe { transmute(&self.inner) };\\n            // let (parser, mut parse_results): (_, ParseResults) = profile!(\\\"Cached.parse: inner.parse\\\", inner.parse(right_data, bytes));\\n            // let (parser, mut parse_results) = inner.parse_dyn(right_data, bytes);\\n            let (parser, mut parse_results) = self.inner.parse_dyn(right_data, bytes);\\n            let parser: Box<dyn ParserTrait + 'static> = unsafe { transmute(parser) };\\n            // profile!(\\\"Cached.parse: parse_results.squash\\\", parse_results.squash());\\n\\n            let mut global_cache = cache.borrow_mut();\\n            let parse_id = global_cache.parse_id.unwrap();\\n            global_cache.new_parsers.get_mut(&parse_id).unwrap().put(key, entry.clone());\\n            if !parse_results.done() {\\n                global_cache.entries.get_mut(&parse_id).unwrap().push(entry.clone());\\n            }\\n            *entry.borrow_mut() = CacheEntry { parser: Some(parser), maybe_parse_results: Some(parse_results.clone()), maybe_u8set: None };\\n            (CachedParser { entry }, parse_results)\\n        })\\n    }\\n}\\n\\nimpl<T: CombinatorTrait> BaseCombinatorTrait for Cached<T> {\\n    fn as_any(&self) -> &dyn std::any::Any where Self: 'static {\\n        self\\n    }\\n    fn apply_to_children(&self, f: &mut dyn FnMut(&dyn BaseCombinatorTrait)) {\\n        f(&self.inner);\\n    }\\n}\\n\\nimpl ParserTrait for CachedParser {\\n    fn get_u8set(&self) -> U8Set {\\n        if self.entry.borrow().maybe_u8set.is_some() {\\n            self.entry.borrow().maybe_u8set.clone().unwrap()\\n        } else {\\n            let u8set = self.entry.borrow().parser.as_ref().unwrap().get_u8set();\\n            self.entry.borrow_mut().maybe_u8set = Some(u8set.clone());\\n            u8set\\n        }\\n    }\\n\\n    fn parse(&mut self, bytes: &[u8]) -> ParseResults {\\n        self.entry.borrow().maybe_parse_results.clone().expect(\\\"CachedParser.steps: parse_results is None\\\")\\n    }\\n}\\n\\npub fn cache_context<'a, T: IntoCombinator>(a: T)-> impl CombinatorTrait where T::Output: 'static {\\n    profile_internal(\\\"cache_context\\\", CacheContext { inner: a.into_combinator() })\\n    // a.into_combinator()\\n}\\n\\n// todo: do we really need to make this 'static?\\npub fn cached<T: IntoCombinator>(a: T)-> impl CombinatorTrait where T::Output: 'static {\\n    profile_internal(\\\"cached\\\", Cached { inner: a.into_combinator() })\\n    // a.into_combinator()\\n}\"}, {\"path\": \"src/_03_combinators/core/choice.rs\", \"tokens\": 2494, \"content\": \"use crate::_01_parse_state::{ParseResultTrait, RightData, RightDataGetters, UpData};\\nuse crate::{profile_internal, BaseCombinatorTrait, CombinatorTrait, DynCombinatorTrait, ParseResults, ParserTrait, U8Set, UnambiguousParseError, UnambiguousParseResults, VecX, OneShotUpData};\\n\\n#[derive(Debug)]\\npub struct Choice<'a> {\\n    pub(crate) children: VecX<Box<dyn DynCombinatorTrait + 'a>>,\\n    pub(crate) greedy: bool,\\n}\\n\\n#[derive(Debug)]\\npub struct ChoiceParser<'a> {\\n    pub(crate) parsers: Vec<Box<dyn ParserTrait + 'a>>,\\n    pub(crate) greedy: bool,\\n}\\n\\nimpl DynCombinatorTrait for Choice<'_> {\\n    fn parse_dyn<'a>(&'a self, right_data: RightData, bytes: &[u8]) -> (Box<dyn ParserTrait + 'a>, ParseResults) {\\n        let (parser, parse_results) = self.parse(right_data, bytes);\\n        (Box::new(parser), parse_results)\\n    }\\n\\n    fn one_shot_parse_dyn<'a>(&'a self, right_data: RightData, bytes: &[u8]) -> UnambiguousParseResults {\\n        self.one_shot_parse(right_data, bytes)\\n    }\\n}\\n\\nimpl CombinatorTrait for Choice<'_> {\\n    type Parser<'a> = ChoiceParser<'a> where Self: 'a;\\n    type Output = Box<dyn std::any::Any>;\\n    type PartialOutput = Box<dyn std::any::Any>;\\n\\n\\n    fn one_shot_parse(&self, right_data: RightData, bytes: &[u8]) -> UnambiguousParseResults {\\n        if self.greedy {\\n            for parser in self.children.iter() {\\n                let parse_result = parser.one_shot_parse(right_data.clone(), bytes);\\n                match parse_result {\\n                    Ok(one_shot_up_data) => {\\n                        return Ok(OneShotUpData::new(one_shot_up_data.just_right_data()));\\n                    }\\n                    Err(UnambiguousParseError::Incomplete | UnambiguousParseError::Ambiguous) => {\\n                        return parse_result;\\n                    }\\n                    Err(UnambiguousParseError::Fail) => {}\\n                }\\n            }\\n            Err(UnambiguousParseError::Fail)\\n        } else {\\n            for (i, parser) in self.children.iter().enumerate() {\\n                let parse_result = parser.one_shot_parse(right_data.clone(), bytes);\\n                match parse_result {\\n                    Ok(one_shot_up_data) => {\\n                        for parser2 in self.children[i+1..].iter() {\\n                            let parse_result2 = parser2.one_shot_parse(right_data.clone(), bytes);\\n                            match parse_result2 {\\n                                Ok(_) => {\\n                                    return Err(UnambiguousParseError::Ambiguous);\\n                                }\\n                                Err(UnambiguousParseError::Incomplete | UnambiguousParseError::Ambiguous) => {\\n                                    return parse_result2;\\n                                }\\n                                Err(UnambiguousParseError::Fail) => {}\\n                            }\\n                        }\\n                        return Ok(OneShotUpData::new(one_shot_up_data.just_right_data()));\\n                    }\\n                    Err(UnambiguousParseError::Incomplete | UnambiguousParseError::Ambiguous) => {\\n                        return parse_result;\\n                    }\\n                    Err(UnambiguousParseError::Fail) => {}\\n                }\\n            };\\n            Err(UnambiguousParseError::Fail)\\n        }\\n    }\\n\\n    fn old_parse(&self, right_data: RightData, bytes: &[u8]) -> (Self::Parser<'_>, ParseResults) {\\n        let mut parsers = Vec::new();\\n        let mut combined_results = ParseResults::empty_finished();\\n\\n        for child in &self.children {\\n            let (parser, parse_results) = child.as_ref().parse_dyn(right_data.clone(), bytes);\\n            if !parse_results.done {\\n                parsers.push(parser);\\n            }\\n            let discard_rest = self.greedy && parse_results.succeeds_decisively();\\n            combined_results.merge_assign(parse_results);\\n            if discard_rest {\\n                break;\\n            }\\n        }\\n\\n        (\\n            ChoiceParser { parsers, greedy: self.greedy },\\n            combined_results\\n        )\\n    }\\n}\\n\\nimpl BaseCombinatorTrait for Choice<'_> {\\n    fn as_any(&self) -> &dyn std::any::Any where Self: 'static {\\n        self\\n    }\\n    fn apply_to_children(&self, f: &mut dyn FnMut(&dyn BaseCombinatorTrait)) {\\n        for child in self.children.iter() {\\n            f(child);\\n        }\\n    }\\n}\\n\\nimpl ParserTrait for ChoiceParser<'_> {\\n    fn get_u8set(&self) -> U8Set {\\n        let mut u8set = U8Set::none();\\n        for parser in &self.parsers {\\n            u8set |= parser.get_u8set();\\n        }\\n        u8set\\n    }\\n\\n    fn parse(&mut self, bytes: &[u8]) -> ParseResults {\\n        let mut parse_result = ParseResults::empty_finished();\\n        let mut discard_rest = false;\\n\\n        self.parsers.retain_mut(|mut parser| {\\n            if discard_rest {\\n                return false;\\n            }\\n            let parse_results = parser.parse(bytes);\\n            discard_rest = self.greedy && parse_results.succeeds_decisively();\\n            let done = parse_results.done();\\n            parse_result.merge_assign(parse_results);\\n            !done\\n        });\\n        parse_result\\n    }\\n\\n}\\n\\npub fn _choice<'a>(v: Vec<Box<dyn DynCombinatorTrait + 'a>>) -> impl CombinatorTrait + 'a {\\n    Choice {\\n        children: v.into_iter().collect(),\\n        greedy: false,\\n    }\\n}\\n\\npub fn _choice_greedy<'a>(v: Vec<Box<dyn DynCombinatorTrait + 'a>>) -> impl CombinatorTrait + 'a {\\n    profile_internal(\\\"choice\\\", Choice {\\n        children: v.into_iter().collect(),\\n        greedy: true,\\n    })\\n}\"}, {\"path\": \"src/_03_combinators/core/choice_macro.rs\", \"tokens\": 6590, \"content\": \"use crate::IntoCombinator;\\n\\npub fn choicen_helper<T: IntoCombinator>(x: T) -> T::Output {\\n        IntoCombinator::into_combinator(x)\\n}\\n\\n#[macro_export]\\nmacro_rules! choice_generalised {\\n    ($greedy:expr, $c0:expr, $c1:expr $(,)?) => {{\\n        use $crate::choicen_helper as h;\\n        $crate::Choice2 {\\n            c0: $crate::IntoCombinator::into_combinator($c0),\\n            c1: h($c1),\\n            greedy: $greedy,\\n        }\\n    }};\\n    ($greedy:expr, $c0:expr, $c1:expr, $c2:expr $(,)?) => {{\\n        use $crate::choicen_helper as h;\\n        $crate::Choice3 {\\n            c0: $crate::IntoCombinator::into_combinator($c0),\\n            c1: h($c1),\\n            c2: h($c2),\\n            greedy: $greedy,\\n        }\\n    }};\\n    ($greedy:expr, $c0:expr, $c1:expr, $c2:expr, $c3:expr $(,)?) => {{\\n        use $crate::choicen_helper as h;\\n        $crate::Choice4 {\\n            c0: $crate::IntoCombinator::into_combinator($c0),\\n            c1: h($c1),\\n            c2: h($c2),\\n            c3: h($c3),\\n            greedy: $greedy,\\n        }\\n    }};\\n    ($greedy:expr, $c0:expr, $c1:expr, $c2:expr, $c3:expr, $c4:expr $(,)?) => {{\\n        use $crate::choicen_helper as h;\\n        $crate::Choice5 {\\n            c0: $crate::IntoCombinator::into_combinator($c0),\\n            c1: h($c1),\\n            c2: h($c2),\\n            c3: h($c3),\\n            c4: h($c4),\\n            greedy: $greedy,\\n        }\\n    }};\\n    ($greedy:expr, $c0:expr, $c1:expr, $c2:expr, $c3:expr, $c4:expr, $c5:expr $(,)?) => {{\\n        use $crate::choicen_helper as h;\\n        $crate::Choice6 {\\n            c0: $crate::IntoCombinator::into_combinator($c0),\\n            c1: h($c1),\\n            c2: h($c2),\\n            c3: h($c3),\\n            c4: h($c4),\\n            c5: h($c5),\\n            greedy: $greedy,\\n        }\\n    }};\\n    ($greedy:expr, $c0:expr, $c1:expr, $c2:expr, $c3:expr, $c4:expr, $c5:expr, $c6:expr $(,)?) => {{\\n        use $crate::choicen_helper as h;\\n        $crate::Choice7 {\\n            c0: $crate::IntoCombinator::into_combinator($c0),\\n            c1: h($c1),\\n            c2: h($c2),\\n            c3: h($c3),\\n            c4: h($c4),\\n            c5: h($c5),\\n            c6: h($c6),\\n            greedy: $greedy,\\n        }\\n    }};\\n    ($greedy:expr, $c0:expr, $c1:expr, $c2:expr, $c3:expr, $c4:expr, $c5:expr, $c6:expr, $c7:expr $(,)?) => {{\\n        use $crate::choicen_helper as h;\\n        $crate::Choice8 {\\n            c0: $crate::IntoCombinator::into_combinator($c0),\\n            c1: h($c1),\\n            c2: h($c2),\\n            c3: h($c3),\\n            c4: h($c4),\\n            c5: h($c5),\\n            c6: h($c6),\\n            c7: h($c7),\\n            greedy: $greedy,\\n        }\\n    }};\\n    ($greedy:expr, $c0:expr, $c1:expr, $c2:expr, $c3:expr, $c4:expr, $c5:expr, $c6:expr, $c7:expr, $c8:expr $(,)?) => {{\\n        use $crate::choicen_helper as h;\\n        $crate::Choice9 {\\n            c0: $crate::IntoCombinator::into_combinator($c0),\\n            c1: h($c1),\\n            c2: h($c2),\\n            c3: h($c3),\\n            c4: h($c4),\\n            c5: h($c5),\\n            c6: h($c6),\\n            c7: h($c7),\\n            c8: h($c8),\\n            greedy: $greedy,\\n        }\\n    }};\\n    ($greedy:expr, $c0:expr, $c1:expr, $c2:expr, $c3:expr, $c4:expr, $c5:expr, $c6:expr, $c7:expr, $c8:expr, $c9:expr $(,)?) => {{\\n        use $crate::choicen_helper as h;\\n        $crate::Choice10 {\\n            c0: $crate::IntoCombinator::into_combinator($c0),\\n            c1: h($c1),\\n            c2: h($c2),\\n            c3: h($c3),\\n            c4: h($c4),\\n            c5: h($c5),\\n            c6: h($c6),\\n            c7: h($c7),\\n            c8: h($c8),\\n            c9: h($c9),\\n            greedy: $greedy,\\n        }\\n    }};\\n    ($greedy:expr, $c0:expr, $c1:expr, $c2:expr, $c3:expr, $c4:expr, $c5:expr, $c6:expr, $c7:expr, $c8:expr, $c9:expr, $c10:expr $(,)?) => {{\\n        use $crate::choicen_helper as h;\\n        $crate::Choice11 {\\n            c0: $crate::IntoCombinator::into_combinator($c0),\\n            c1: h($c1),\\n            c2: h($c2),\\n            c3: h($c3),\\n            c4: h($c4),\\n            c5: h($c5),\\n            c6: h($c6),\\n            c7: h($c7),\\n            c8: h($c8),\\n            c9: h($c9),\\n            c10: h($c10),\\n            greedy: $greedy,\\n        }\\n    }};\\n    ($greedy:expr, $c0:expr, $c1:expr, $c2:expr, $c3:expr, $c4:expr, $c5:expr, $c6:expr, $c7:expr, $c8:expr, $c9:expr, $c10:expr, $c11:expr $(,)?) => {{\\n        use $crate::choicen_helper as h;\\n        $crate::Choice12 {\\n            c0: $crate::IntoCombinator::into_combinator($c0),\\n            c1: h($c1),\\n            c2: h($c2),\\n            c3: h($c3),\\n            c4: h($c4),\\n            c5: h($c5),\\n            c6: h($c6),\\n            c7: h($c7),\\n            c8: h($c8),\\n            c9: h($c9),\\n            c10: h($c10),\\n            c11: h($c11),\\n            greedy: $greedy,\\n        }\\n    }};\\n    ($greedy:expr, $c0:expr, $c1:expr, $c2:expr, $c3:expr, $c4:expr, $c5:expr, $c6:expr, $c7:expr, $c8:expr, $c9:expr, $c10:expr, $c11:expr, $c12:expr $(,)?) => {{\\n        use $crate::choicen_helper as h;\\n        $crate::Choice13 {\\n            c0: $crate::IntoCombinator::into_combinator($c0),\\n            c1: h($c1),\\n            c2: h($c2),\\n            c3: h($c3),\\n            c4: h($c4),\\n            c5: h($c5),\\n            c6: h($c6),\\n            c7: h($c7),\\n            c8: h($c8),\\n            c9: h($c9),\\n            c10: h($c10),\\n            c11: h($c11),\\n            c12: h($c12),\\n            greedy: $greedy,\\n        }\\n    }};\\n    ($greedy:expr, $c0:expr, $c1:expr, $c2:expr, $c3:expr, $c4:expr, $c5:expr, $c6:expr, $c7:expr, $c8:expr, $c9:expr, $c10:expr, $c11:expr, $c12:expr, $c13:expr $(,)?) => {{\\n        use $crate::choicen_helper as h;\\n        $crate::Choice14 {\\n            c0: $crate::IntoCombinator::into_combinator($c0),\\n            c1: h($c1),\\n            c2: h($c2),\\n            c3: h($c3),\\n            c4: h($c4),\\n            c5: h($c5),\\n            c6: h($c6),\\n            c7: h($c7),\\n            c8: h($c8),\\n            c9: h($c9),\\n            c10: h($c10),\\n            c11: h($c11),\\n            c12: h($c12),\\n            c13: h($c13),\\n            greedy: $greedy,\\n        }\\n    }};\\n    ($greedy:expr, $c0:expr, $c1:expr, $c2:expr, $c3:expr, $c4:expr, $c5:expr, $c6:expr, $c7:expr, $c8:expr, $c9:expr, $c10:expr, $c11:expr, $c12:expr, $c13:expr, $c14:expr $(,)?) => {{\\n        use $crate::choicen_helper as h;\\n        $crate::Choice15 {\\n            c0: $crate::IntoCombinator::into_combinator($c0),\\n            c1: h($c1),\\n            c2: h($c2),\\n            c3: h($c3),\\n            c4: h($c4),\\n            c5: h($c5),\\n            c6: h($c6),\\n            c7: h($c7),\\n            c8: h($c8),\\n            c9: h($c9),\\n            c10: h($c10),\\n            c11: h($c11),\\n            c12: h($c12),\\n            c13: h($c13),\\n            c14: h($c14),\\n            greedy: $greedy,\\n        }\\n    }};\\n    ($greedy:expr, $c0:expr, $c1:expr, $c2:expr, $c3:expr, $c4:expr, $c5:expr, $c6:expr, $c7:expr, $c8:expr, $c9:expr, $c10:expr, $c11:expr, $c12:expr, $c13:expr, $c14:expr, $c15:expr $(,)?) => {{\\n        use $crate::choicen_helper as h;\\n        $crate::Choice16 {\\n            c0: $crate::IntoCombinator::into_combinator($c0),\\n            c1: h($c1),\\n            c2: h($c2),\\n            c3: h($c3),\\n            c4: h($c4),\\n            c5: h($c5),\\n            c6: h($c6),\\n            c7: h($c7),\\n            c8: h($c8),\\n            c9: h($c9),\\n            c10: h($c10),\\n            c11: h($c11),\\n            c12: h($c12),\\n            c13: h($c13),\\n            c14: h($c14),\\n            c15: h($c15),\\n            greedy: $greedy,\\n        }\\n    }};\\n    ($greedy:expr, $c0:expr, $c1:expr, $c2:expr, $c3:expr, $c4:expr, $c5:expr, $c6:expr, $c7:expr, $c8:expr, $c9:expr, $c10:expr, $c11:expr, $c12:expr, $c13:expr, $c14:expr, $c15:expr, $($rest:expr),+ $(,)?) => {{\\n        fn convert<T: $crate::IntoCombinator>(x: T) -> Box<dyn $crate::CombinatorTrait> where T::Output {\\n            Box::new(x.into_combinator())\\n        }\\n        if $greedy {\\n            $crate::_choice_greedy(vec![convert($c0), convert($c1), convert($c2), convert($c3), convert($c4), convert($c5), convert($c6), convert($c7), convert($c8), convert($c9), convert($c10), convert($c11), convert($c12), convert($c13), convert($c14), convert($c15), $(convert($rest)),+])\\n        } else {\\n            $crate::_choice(vec![convert($c0), convert($c1), convert($c2), convert($c3), convert($c4), convert($c5), convert($c6), convert($c7), convert($c8), convert($c9), convert($c10), convert($c11), convert($c12), convert($c13), convert($c14), convert($c15), $(convert($rest)),+])\\n        }\\n    }};\\n}\\n\\n#[macro_export]\\nmacro_rules! choice {\\n    ($($rest:expr),+ $(,)?) => {{\\n        $crate::choice_generalised!(false, $($rest),+)\\n    }};\\n}\\n\\n#[macro_export]\\nmacro_rules! choice_greedy {\\n    ($($rest:expr),+ $(,)?) => {{\\n        $crate::choice_generalised!(true, $($rest),+)\\n    }};\\n}\"}, {\"path\": \"src/_03_combinators/core/choicen.rs\", \"tokens\": 5352, \"content\": \"\\n// src/_03_combinators/core/choicen.rs\\nuse crate::{BaseCombinatorTrait, CombinatorTrait, IntoCombinator, ParseResultTrait, ParseResults, ParserTrait, RightData, RightDataGetters, Squash, U8Set, UnambiguousParseResults, UpData, OneShotUpData};\\n\\nmacro_rules! profile {\\n    ($tag:expr, $body:expr) => {{\\n        $body\\n    }};\\n}\\n\\n#[macro_export]\\nmacro_rules! define_choice {\\n    ($choice_name:ident, $choice_parser_name:ident, $choice_enum_name:ident, $choice_partial_enum_name:ident, $first:ident, $($rest:ident),+) => {\\n        #[derive(Debug)]\\n        pub struct $choice_name<$first, $($rest),+> {\\n            pub(crate) $first: $first,\\n            $(pub(crate) $rest: $rest,)+\\n            pub(crate) greedy: bool,\\n        }\\n\\n        #[derive(Debug)]\\n        pub struct $choice_parser_name<'a, $first, $($rest),+>\\n        where\\n            $first: CombinatorTrait,\\n            $($rest: CombinatorTrait),+\\n        {\\n            pub(crate) combinator: &'a $choice_name<$first, $($rest),+>,\\n            pub(crate) $first: Vec<$first::Parser<'a>>,\\n            $(pub(crate) $rest: Vec<$rest::Parser<'a>>,)+\\n            pub(crate) position: usize,\\n        }\\n\\n        pub struct $choice_enum_name<$first, $($rest),+>\\n        where\\n            $first: CombinatorTrait,\\n            $($rest: CombinatorTrait),+\\n        {\\n            pub(crate) $first: $first::Output,\\n            $(pub(crate) $rest: $rest::Output,)+\\n        }\\n\\n        pub struct $choice_partial_enum_name<$first, $($rest),+>\\n        where\\n            $first: CombinatorTrait,\\n            $($rest: CombinatorTrait),+\\n        {\\n            pub(crate) $first: Option<$first::PartialOutput>,\\n            $(pub(crate) $rest: Option<$rest::PartialOutput>,)+\\n        }\\n\\n        impl<$first, $($rest),+> $crate::DynCombinatorTrait for $choice_name<$first, $($rest),+>\\n        where\\n            $first: CombinatorTrait,\\n            $($rest: CombinatorTrait),+,\\n        {\\n            fn parse_dyn(&self, right_data: RightData, bytes: &[u8]) -> (Box<dyn ParserTrait + '_>, ParseResults) {\\n                let (parser, parse_results) = self.parse(right_data, bytes);\\n                (Box::new(parser), parse_results)\\n            }\\n\\n            fn one_shot_parse_dyn(&self, right_data: RightData, bytes: &[u8]) -> UnambiguousParseResults {\\n                self.one_shot_parse(right_data, bytes)\\n            }\\n        }\\n\\n        impl<$first, $($rest),+> CombinatorTrait for $choice_name<$first, $($rest),+>\\n        where\\n            $first: CombinatorTrait,\\n            $($rest: CombinatorTrait),+,\\n        {\\n            type Parser<'a> = $choice_parser_name<'a, $first, $($rest),+> where Self: 'a;\\n            type Output = $choice_enum_name<$first, $($rest),+>;\\n            type PartialOutput = $choice_partial_enum_name<$first, $($rest),+>;\\n\\n            fn one_shot_parse(&self, right_data: RightData, bytes: &[u8]) -> $crate::UnambiguousParseResults {\\n                use $crate::{UnambiguousParseResults, UnambiguousParseError};\\n                if self.greedy {\\n                    let first_combinator = &self.$first;\\n                    let parse_result = first_combinator.one_shot_parse(right_data.clone(), bytes);\\n                    if matches!(parse_result, Ok(_) | Err(UnambiguousParseError::Ambiguous | UnambiguousParseError::Incomplete)) {\\n                        return parse_result;\\n                    }\\n\\n                    $(\\n                        let next_combinator = &self.$rest;\\n                        let parse_result = next_combinator.one_shot_parse(right_data.clone(), bytes);\\n                        if matches!(parse_result, Ok(_) | Err(UnambiguousParseError::Ambiguous | UnambiguousParseError::Incomplete)) {\\n                            return parse_result;\\n                        }\\n                    )+\\n\\n                    Err(UnambiguousParseError::Fail)\\n                } else {\\n                    let first_combinator = &self.$first;\\n                    let mut final_parse_result = first_combinator.one_shot_parse(right_data.clone(), bytes);\\n                    if matches!(final_parse_result, Err(UnambiguousParseError::Ambiguous | UnambiguousParseError::Incomplete)) {\\n                        return final_parse_result;\\n                    }\\n\\n                    $(\\n                        let next_combinator = &self.$rest;\\n                        let parse_result = next_combinator.one_shot_parse(right_data.clone(), bytes);\\n                        match (&parse_result, &final_parse_result) {\\n                            (Err(UnambiguousParseError::Ambiguous | UnambiguousParseError::Incomplete), _) => {\\n                                return parse_result;\\n                            },\\n                            (Ok(_), Ok(_)) => {\\n                                return parse_result;\\n                            },\\n                            (Ok(_), Err(UnambiguousParseError::Fail)) => {\\n                                final_parse_result = parse_result;\\n                            },\\n                            (Ok(_), Err(UnambiguousParseError::Incomplete | UnambiguousParseError::Ambiguous)) => unreachable!(),\\n                            (Err(UnambiguousParseError::Fail), _) => {},\\n                        }\\n                    )+\\n\\n                    final_parse_result\\n                }\\n            }\\n\\n            fn old_parse<'a>(&'a self, right_data: RightData, bytes: &[u8]) -> (Self::Parser<'a>, ParseResults) {\\n                let start_position = right_data.get_fields1().position;\\n\\n                let mut combined_results = ParseResults::empty_finished();\\n\\n                let (first_parser, first_parse_results) = self.$first.parse(right_data.clone(), bytes);\\n                let mut parser = $choice_parser_name {\\n                    combinator: self,\\n                    $first: vec![],\\n                    $($rest: vec![],)+\\n                    position: start_position + bytes.len(),\\n                };\\n                if !first_parse_results.done {\\n                    parser.$first.push(first_parser);\\n                }\\n                let discard_rest = self.greedy && first_parse_results.succeeds_decisively();\\n                combined_results.merge_assign(first_parse_results);\\n\\n                $(\\n                    if discard_rest {\\n                        return (parser, combined_results);\\n                    }\\n                    let (next_parser, next_parse_results) = self.$rest.parse(right_data.clone(), bytes);\\n                    if !next_parse_results.done() {\\n                        parser.$rest.push(next_parser);\\n                    }\\n                    let discard_rest = self.greedy && next_parse_results.succeeds_decisively();\\n                    combined_results.merge_assign(next_parse_results);\\n                )+\\n\\n                (parser, combined_results)\\n            }\\n        }\\n\\n        impl<'a, $first, $($rest),+> ParserTrait for $choice_parser_name<'a, $first, $($rest),+>\\n        where\\n            $first: CombinatorTrait,\\n            $($rest: CombinatorTrait),+\\n        {\\n            fn get_u8set(&self) -> U8Set {\\n                let mut u8set = U8Set::none();\\n                for parser in &self.$first {\\n                    u8set = u8set.union(&parser.get_u8set());\\n                }\\n                $(\\n                    for parser in &self.$rest {\\n                        u8set = u8set.union(&parser.get_u8set());\\n                    }\\n                )+\\n                u8set\\n            }\\n\\n            fn parse(&mut self, bytes: &[u8]) -> ParseResults {\\n                profile!(stringify!($choice_parser_name, \\\"::parse\\\"), {\\n                    let mut parse_result = ParseResults::empty_finished();\\n                    let mut discard_rest = false;\\n\\n                    // First child\\n                    self.$first.retain_mut(|parser| {\\n                        if discard_rest {\\n                            return false;\\n                        }\\n                        let parse_results = parser.parse(bytes);\\n                        let done = parse_results.done;\\n                        discard_rest = self.combinator.greedy && parse_results.succeeds_decisively();\\n                        parse_result.merge_assign(parse_results);\\n                        !done\\n                    });\\n\\n                    // Rest of the children\\n                    $(\\n                        if discard_rest {\\n                            return parse_result;\\n                        }\\n\\n                        self.$rest.retain_mut(|parser| {\\n                            if discard_rest {\\n                                return false;\\n                            }\\n                            let parse_results = parser.parse(bytes);\\n                            let done = parse_results.done;\\n                            discard_rest = self.combinator.greedy && parse_results.succeeds_decisively();\\n                            parse_result.merge_assign(parse_results);\\n                            !done\\n                        });\\n                    )+\\n\\n                    parse_result\\n                })\\n            }\\n        }\\n\\n        impl<$first, $($rest),+> BaseCombinatorTrait for $choice_name<$first, $($rest),+>\\n        where\\n            $first: BaseCombinatorTrait,\\n            $($rest: BaseCombinatorTrait),+,\\n        {\\n            fn as_any(&self) -> &dyn std::any::Any where Self: 'static {\\n                self\\n            }\\n\\n            fn apply_to_children(&self, f: &mut dyn FnMut(&dyn BaseCombinatorTrait)) {\\n                f(&self.$first);\\n                $(f(&self.$rest);)+\\n            }\\n        }\\n    };\\n}\\n\\ndefine_choice!(Choice2, Choice2Parser, Choice2Enum, Choice2PartialEnum, c0, c1);\\ndefine_choice!(Choice3, Choice3Parser, Choice3Enum, Choice3PartialEnum, c0, c1, c2);\\ndefine_choice!(Choice4, Choice4Parser, Choice4Enum, Choice4PartialEnum, c0, c1, c2, c3);\\ndefine_choice!(Choice5, Choice5Parser, Choice5Enum, Choice5PartialEnum, c0, c1, c2, c3, c4);\\ndefine_choice!(Choice6, Choice6Parser, Choice6Enum, Choice6PartialEnum, c0, c1, c2, c3, c4, c5);\\ndefine_choice!(Choice7, Choice7Parser, Choice7Enum, Choice7PartialEnum, c0, c1, c2, c3, c4, c5, c6);\\ndefine_choice!(Choice8, Choice8Parser, Choice8Enum, Choice8PartialEnum, c0, c1, c2, c3, c4, c5, c6, c7);\\ndefine_choice!(Choice9, Choice9Parser, Choice9Enum, Choice9PartialEnum, c0, c1, c2, c3, c4, c5, c6, c7, c8);\\ndefine_choice!(Choice10, Choice10Parser, Choice10Enum, Choice10PartialEnum, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9);\\ndefine_choice!(Choice11, Choice11Parser, Choice11Enum, Choice11PartialEnum, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, c10);\\ndefine_choice!(Choice12, Choice12Parser, Choice12Enum, Choice12PartialEnum, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11);\\ndefine_choice!(Choice13, Choice13Parser, Choice13Enum, Choice13PartialEnum, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12);\\ndefine_choice!(Choice14, Choice14Parser, Choice14Enum, Choice14PartialEnum, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13);\\ndefine_choice!(Choice15, Choice15Parser, Choice15Enum, Choice15PartialEnum, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14);\\ndefine_choice!(Choice16, Choice16Parser, Choice16Enum, Choice16PartialEnum, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15);\"}, {\"path\": \"src/_03_combinators/core/eat.rs\", \"tokens\": 3720, \"content\": \"\\n// src/_03_combinators/core/eat.rs\\nuse crate::internal_vec::VecY;\\nuse crate::_01_parse_state::{RightData, UpData};\\nuse crate::{RightDataGetters, UnambiguousParseError};\\nuse crate::{BaseCombinatorTrait, DynCombinatorTrait, UnambiguousParseResults, OneShotUpData};\\nuse crate::{CombinatorTrait, ParseResultTrait, ParseResults, ParserTrait, U8Set};\\nuse std::ops::RangeBounds;\\n\\n#[derive(Copy, Debug, Clone, PartialEq, Eq, Hash)]\\npub struct EatU8 {\\n    pub(crate) u8set: U8Set,\\n}\\n\\n#[derive(Debug)]\\npub struct EatU8Parser {\\n    pub(crate) u8set: U8Set,\\n    pub(crate) right_data: Option<RightData>,\\n}\\n\\nimpl DynCombinatorTrait for EatU8 {\\n    fn parse_dyn(&self, right_data: RightData, bytes: &[u8]) -> (Box<dyn ParserTrait + '_>, ParseResults) {\\n        let (parser, parse_results) = self.parse(right_data, bytes);\\n        (Box::new(parser), parse_results)\\n    }\\n\\n    fn one_shot_parse_dyn<'a>(&'a self, right_data: RightData, bytes: &[u8]) -> UnambiguousParseResults {\\n        self.one_shot_parse(right_data, bytes)\\n    }\\n}\\n\\nimpl CombinatorTrait for EatU8 {\\n    type Parser<'a> = EatU8Parser;\\n    type Output = ();\\n    type PartialOutput = ();\\n\\n    fn one_shot_parse(&self, right_data: RightData, bytes: &[u8]) -> UnambiguousParseResults {\\n        if bytes.is_empty() {\\n            return ParseResultTrait::empty_unfinished();\\n        }\\n\\n        let mut right_data = right_data;\\n        if self.u8set.contains(bytes[0]) {\\n            right_data.advance(1);\\n            Ok(OneShotUpData::new(right_data))\\n        } else {\\n            ParseResultTrait::empty_finished()\\n        }\\n    }\\n\\n    fn old_parse(&self, right_data: RightData, bytes: &[u8]) -> (Self::Parser<'_>, ParseResults) {\\n        let mut parser = EatU8Parser {\\n            u8set: self.u8set.clone(),\\n            right_data: Some(right_data),\\n        };\\n        let parse_results = parser.parse(bytes);\\n        (parser, parse_results)\\n    }\\n}\\n\\nimpl BaseCombinatorTrait for EatU8 {\\n    fn as_any(&self) -> &dyn std::any::Any where Self: 'static {\\n        self\\n    }\\n}\\n\\nimpl ParserTrait for EatU8Parser {\\n    fn get_u8set(&self) -> U8Set {\\n        assert!(self.right_data.is_some(), \\\"EatU8Parser.get_u8set() called but right_data is None\\\");\\n        return self.u8set.clone();\\n    }\\n\\n    fn parse(&mut self, bytes: &[u8]) -> ParseResults {\\n        if bytes.is_empty() {\\n            return ParseResults::empty_unfinished();\\n        }\\n\\n        let mut right_data = self.right_data.take().unwrap();\\n        if self.u8set.contains(bytes[0]) {\\n            right_data.advance(1);\\n            ParseResults::new_single(UpData::new(right_data), true)\\n        } else {\\n            ParseResults::empty_finished()\\n        }\\n    }\\n}\\n\\npub fn eat_byte(byte: u8) -> EatU8 {\\n    EatU8 {\\n        u8set: U8Set::from_byte(byte),\\n    }\\n}\\n\\npub fn eat_char(c: char) -> EatU8 {\\n    eat_byte(c as u8)\\n}\\n\\npub fn eat_any_byte() -> EatU8 {\\n    EatU8 {\\n        u8set: U8Set::all(),\\n    }\\n}\\n\\npub fn eat_char_choice(chars: &str) -> EatU8 {\\n    EatU8 {\\n        u8set: U8Set::from_chars(chars),\\n    }\\n}\\n\\npub fn eat_char_negation_choice(chars: &str) -> EatU8 {\\n    EatU8 {\\n        u8set: U8Set::from_chars_negation(chars),\\n    }\\n}\\n\\npub fn eat_byte_choice(bytes: &[u8]) -> EatU8 {\\n    EatU8 {\\n        u8set: U8Set::from_bytes(bytes),\\n    }\\n}\\n\\npub fn eat_byte_range(start: u8, end: u8) -> EatU8 {\\n    EatU8 {\\n        u8set: U8Set::from_range(start, end),\\n    }\\n}\\n\\npub fn eat_char_negation(c: char) -> EatU8 {\\n    EatU8 {\\n        u8set: U8Set::from_char_negation(c),\\n    }\\n}\\n\\npub fn eat_char_range(range: impl IntoIterator<Item=u8>) -> EatU8 {\\n    EatU8 { u8set: U8Set::from_byte_range(range) }\\n}\\n\\npub fn eat_byte_negation_range(range: impl IntoIterator<Item=u8>) -> EatU8 {\\n    EatU8 { u8set: U8Set::from_char_negation_range(range) }\\n}\\n\\npub fn eat_match_fn<F>(f: F) -> EatU8\\nwhere\\n    F: Fn(u8) -> bool,\\n{\\n    EatU8 {\\n        u8set: U8Set::from_match_fn(f),\\n    }\\n}\\n\\n\\n#[derive(Debug)]\\npub struct EatString {\\n    pub(crate) string: Vec<u8>,\\n}\\n\\n#[derive(Debug)]\\npub struct EatStringParser<'a> {\\n    pub(crate) string: &'a [u8],\\n    index: usize,\\n    pub(crate) right_data: Option<RightData>,\\n}\\n\\nimpl DynCombinatorTrait for EatString {\\n    fn parse_dyn(&self, right_data: RightData, bytes: &[u8]) -> (Box<dyn ParserTrait + '_>, ParseResults) {\\n        let (parser, parse_results) = self.parse(right_data, bytes);\\n        (Box::new(parser), parse_results)\\n    }\\n\\n    fn one_shot_parse_dyn<'a>(&'a self, right_data: RightData, bytes: &[u8]) -> UnambiguousParseResults {\\n        self.one_shot_parse(right_data, bytes)\\n    }\\n}\\n\\nimpl CombinatorTrait for EatString {\\n    type Parser<'a> = EatStringParser<'a>;\\n    type Output = ();\\n    type PartialOutput = ();\\n\\n    fn one_shot_parse(&self, right_data: RightData, bytes: &[u8]) -> UnambiguousParseResults {\\n        if bytes.len() < self.string.len() {\\n            return Err(UnambiguousParseError::Incomplete);\\n        }\\n\\n        if self.string == bytes[..self.string.len()] {\\n            let mut right_data = right_data;\\n            right_data.advance(self.string.len());\\n            Ok(OneShotUpData::new(right_data))\\n        } else {\\n            Err(UnambiguousParseError::Fail)\\n        }\\n    }\\n\\n    fn old_parse(&self, right_data: RightData, bytes: &[u8]) -> (Self::Parser<'_>, ParseResults) {\\n        let mut parser = EatStringParser {\\n            string: self.string.as_slice(),\\n            index: 0,\\n            right_data: Some(right_data),\\n        };\\n        let parse_results = parser.parse(bytes);\\n        (parser, parse_results)\\n    }\\n}\\n\\nimpl BaseCombinatorTrait for EatString {\\n    fn as_any(&self) -> &dyn std::any::Any where Self: 'static {\\n        self\\n    }\\n}\\n\\nimpl ParserTrait for EatStringParser<'_> {\\n    fn get_u8set(&self) -> U8Set {\\n        U8Set::from_byte(self.string[self.index])\\n    }\\n\\n    fn parse(&mut self, bytes: &[u8]) -> ParseResults {\\n        if bytes.is_empty() {\\n            return ParseResults::empty_unfinished();\\n        }\\n\\n        let mut up_data_vec = VecY::new();\\n        let mut done = false;\\n\\n        for &byte in bytes {\\n            if self.string[self.index] == byte {\\n                self.index += 1;\\n                if self.index == self.string.len() {\\n                    let mut right_data = self.right_data.take().expect(\\\"right_data already taken\\\");\\n                    right_data.advance(self.string.len());\\n                    up_data_vec.push(UpData::new(right_data));\\n                    done = true;\\n                    break;\\n                }\\n            } else {\\n                done = true;\\n                self.right_data.take();\\n                break;\\n            }\\n        }\\n\\n        ParseResults::new(up_data_vec, done)\\n    }\\n}\\n\\npub fn eat_string(string: &str) -> EatString {\\n    EatString { string: string.as_bytes().to_vec() }\\n}\\n\\npub fn eat_bytes(bytes: &[u8]) -> EatString {\\n    EatString { string: bytes.to_vec() }\\n}\\n\\npub fn eat(string: impl Into<String>) -> EatString {\\n    EatString { string: string.into().into_bytes() }\\n}\"}, {\"path\": \"src/_03_combinators/core/fast.rs\", \"tokens\": 2450, \"content\": \"\\n// src/_03_combinators/core/fast.rs\\nuse crate::tokenizer::finite_automata::{Expr, Regex, RegexState};\\nuse crate::tokenizer::{choice_fast, eat_bytestring_fast, eat_string_fast};\\nuse crate::BaseCombinatorTrait;\\nuse crate::*;\\n// src/combinators/fast.rs\\nuse std::fmt::{Debug, Formatter};\\nuse std::hash::Hash;\\n\\npub struct FastCombinatorWrapper {\\n    pub(crate) regex: Regex,\\n}\\n\\npub struct FastParserWrapper<'a> {\\n    pub(crate) regex_state: RegexState<'a>,\\n    pub(crate) right_data: Option<RightData>,\\n}\\n\\nimpl Debug for FastCombinatorWrapper {\\n    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {\\n        f.debug_struct(\\\"FastCombinatorWrapper\\\").finish_non_exhaustive()\\n    }\\n}\\n\\nimpl Debug for FastParserWrapper<'_> {\\n    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {\\n        f.debug_struct(\\\"FastParserWrapper\\\").finish_non_exhaustive()\\n    }\\n}\\n\\nimpl DynCombinatorTrait for FastCombinatorWrapper {\\n    fn parse_dyn(&self, right_data: RightData, bytes: &[u8]) -> (Box<dyn ParserTrait + '_>, ParseResults) {\\n        let (parser, parse_results) = self.parse(right_data, bytes);\\n        (Box::new(parser), parse_results)\\n    }\\n\\n    fn one_shot_parse_dyn<'a>(&'a self, right_data: RightData, bytes: &[u8]) -> UnambiguousParseResults {\\n        self.one_shot_parse(right_data, bytes)\\n    }\\n}\\n\\nimpl CombinatorTrait for FastCombinatorWrapper {\\n    type Parser<'a> = FastParserWrapper<'a>;\\n    type Output = ();\\n    type PartialOutput = ();\\n\\n    fn one_shot_parse(&self, right_data: RightData, bytes: &[u8]) -> UnambiguousParseResults {\\n        let mut regex_state = self.regex.init();\\n        regex_state.execute(bytes);\\n        if !regex_state.done() {\\n            Err(UnambiguousParseError::Incomplete)\\n        } else if let Some(new_match) = regex_state.prev_match() {\\n            let mut right_data = right_data;\\n            let position = new_match.position;\\n            #[cfg(debug_assertions)]\\n            if position == 0 {\\n                panic!(\\\"FastCombinatorWrapper::one_shot_parse: regex matched the empty string\\\");\\n            }\\n            right_data.advance(position);\\n            Ok(OneShotUpData::new(right_data))\\n        } else {\\n            assert!(regex_state.failed());\\n            Err(UnambiguousParseError::Fail)\\n        }\\n    }\\n\\n    fn old_parse(&self, right_data: RightData, bytes: &[u8]) -> (Self::Parser<'_>, ParseResults) {\\n        let mut regex_state = self.regex.init();\\n        regex_state.execute(bytes);\\n        if regex_state.failed() {\\n            (FastParserWrapper { regex_state, right_data: None }, ParseResults::empty_finished())\\n        } else {\\n            let mut up_data_vec: VecY<UpData> = vecy![];\\n            let done = regex_state.done();\\n            if let Some(new_match) = regex_state.prev_match() {\\n                let mut right_data = right_data.clone();\\n                let position = new_match.position;\\n                #[cfg(debug_assertions)]\\n                if position == 0 {\\n                    panic!(\\\"FastCombinatorWrapper::old_parse: regex matched the empty string\\\");\\n                }\\n                right_data.advance(position);\\n                up_data_vec.push(UpData::new(right_data));\\n            }\\n            (FastParserWrapper { regex_state, right_data: Some(right_data) }, ParseResults::new(up_data_vec, done))\\n        }\\n    }\\n}\\n\\nimpl BaseCombinatorTrait for FastCombinatorWrapper {\\n    fn as_any(&self) -> &dyn std::any::Any where Self: 'static {\\n        self\\n    }\\n}\\n\\nimpl ParserTrait for FastParserWrapper<'_> {\\n    fn get_u8set(&self) -> U8Set {\\n        profile!(\\\"FastParserWrapper.get_u8set\\\", self.regex_state.get_u8set())\\n}\\n\\nfn parse(&mut self, bytes: &[u8]) -> ParseResults {\\n        let mut regex_state = &mut self.regex_state;\\n        let prev_match = regex_state.prev_match();\\n        regex_state.execute(bytes);\\n        if regex_state.failed() {\\n            ParseResults::empty_finished()\\n        } else {\\n            let mut up_data_vec: VecY<UpData> = vecy![];\\n            let done = regex_state.done();\\n            if let Some(new_match) = regex_state.prev_match() {\\n                if Some(new_match) != prev_match {\\n                    let mut right_data = self.right_data.clone().unwrap();\\n                    let position = new_match.position;\\n                    if position == 0 {\\n                        panic!(\\\"FastParserWrapper::parse: regex matched the empty string\\\");\\n                    }\\n                    right_data.advance(position);\\n                    up_data_vec.push(UpData::new(right_data));\\n                }\\n            }\\n            ParseResults::new(up_data_vec, done)\\n        }\\n    }\\n}\\n\\npub fn fast_combinator(expr: Expr) -> FastCombinatorWrapper {\\n    let regex = expr.build();\\n    FastCombinatorWrapper { regex }\\n}\\n\\npub fn eat_bytestring_choice(bytestrings: Vec<Vec<u8>>) -> FastCombinatorWrapper {\\n    // Convert into a regex.\\n    let mut children = vec![];\\n    for bytes in bytestrings {\\n        children.push(eat_bytestring_fast(bytes));\\n    }\\n    fast_combinator(choice_fast(children))\\n}\\n\\npub fn eat_string_choice(strings: &[&str]) -> FastCombinatorWrapper {\\n    let mut children = vec![];\\n    for s in strings {\\n        children.push(eat_string_fast(s));\\n    }\\n    fast_combinator(choice_fast(children))\\n}\"}, {\"path\": \"src/_03_combinators/core/mod.rs\", \"tokens\": 186, \"content\": \"\\n// src/_03_combinators/core/mod.rs\\nmod choicen;\\nmod choice;\\nmod eat;\\nmod fast;\\nmod opt;\\nmod repeat1;\\nmod seq;\\nmod seqn;\\nmod choice_macro;\\nmod seq_macro;\\n\\npub use choice::*;\\npub use choicen::*;\\npub use eat::*;\\npub use fast::*;\\n\\npub use opt::*;\\npub use repeat1::*;\\npub use seq::*;\\npub use seqn::*;\\npub use choice_macro::*;\\npub use seq_macro::*;\"}, {\"path\": \"src/_03_combinators/core/opt.rs\", \"tokens\": 1460, \"content\": \"\\n// src/_03_combinators/core/opt.rs\\nuse crate::BaseCombinatorTrait;\\nuse crate::*;\\n\\n#[derive(Debug)]\\npub struct Opt<T: CombinatorTrait> {\\n    pub(crate) inner: T,\\n    pub(crate) greedy: bool,\\n}\\n\\nimpl<T: CombinatorTrait> DynCombinatorTrait for Opt<T> {\\n    fn parse_dyn(&self, right_data: RightData, bytes: &[u8]) -> (Box<dyn ParserTrait + '_>, ParseResults) {\\n        let (parser, parse_results) = self.parse(right_data, bytes);\\n        (Box::new(parser), parse_results)\\n    }\\n\\n    fn one_shot_parse_dyn<'a>(&'a self, right_data: RightData, bytes: &[u8]) -> UnambiguousParseResults {\\n        self.one_shot_parse(right_data, bytes)\\n    }\\n}\\n\\nimpl<T: CombinatorTrait> CombinatorTrait for Opt<T> {\\n    type Parser<'a> = T::Parser<'a> where Self: 'a;\\n    type Output = Option<T::Output>;\\n    type PartialOutput = Option<T::PartialOutput>;\\n\\n    fn one_shot_parse(&self, right_data: RightData, bytes: &[u8]) -> UnambiguousParseResults {\\n        let parse_result = self.inner.one_shot_parse(right_data.clone(), bytes);\\n        if self.greedy {\\n            match parse_result {\\n                Ok(one_shot_up_data) => Ok(OneShotUpData::new(one_shot_up_data.just_right_data())),\\n                Err(UnambiguousParseError::Fail) => Ok(OneShotUpData::new(right_data)),\\n                Err(UnambiguousParseError::Incomplete | UnambiguousParseError::Ambiguous) => parse_result,\\n            }\\n        } else {\\n            match parse_result {\\n                Ok(_) => Err(UnambiguousParseError::Ambiguous),\\n                Err(UnambiguousParseError::Fail) => Ok(OneShotUpData::new(right_data)),\\n                Err(UnambiguousParseError::Incomplete | UnambiguousParseError::Ambiguous) => parse_result,\\n            }\\n        }\\n    }\\n\\n    fn old_parse(&self, right_data: RightData, bytes: &[u8]) -> (Self::Parser<'_>, ParseResults) {\\n        let (parser, mut parse_results) = self.inner.parse(right_data.clone(), bytes);\\n        if !(self.greedy && parse_results.succeeds_decisively()) {\\n            // TODO: remove the condition below. It's a hack.\\n            // if parse_results.up_data_vec.is_empty() {  // TODO: remove this line\\n                parse_results.up_data_vec.push(UpData::new(right_data));\\n            // }\\n        }\\n        (parser, parse_results)\\n    }\\n}\\n\\nimpl<T: CombinatorTrait> BaseCombinatorTrait for Opt<T> {\\n    fn as_any(&self) -> &dyn std::any::Any where Self: 'static {\\n        self\\n    }\\n    fn apply_to_children(&self, f: &mut dyn FnMut(&dyn BaseCombinatorTrait)) {\\n        f(&self.inner);\\n    }\\n}\\n\\npub fn opt<T: IntoCombinator>(a: T) -> Opt<T::Output> {\\n    Opt { inner: a.into_combinator(), greedy: false }\\n}\\n\\npub fn opt_greedy(a: impl IntoCombinator)-> impl CombinatorTrait {\\n    profile_internal(\\\"opt_greedy\\\", Opt { inner: a.into_combinator(), greedy: true })\\n}\"}, {\"path\": \"src/_03_combinators/core/repeat1.rs\", \"tokens\": 5604, \"content\": \"\\n// src/_03_combinators/core/repeat1.rs\\n// src/combinators/repeat1.rs\\nuse crate::{seq, BaseCombinatorTrait, DynCombinatorTrait, UnambiguousParseError, UnambiguousParseResults, RightData, UpData, OneShotUpData};\\n\\nuse crate::_01_parse_state::{ParseResultTrait, RightDataGetters};\\nuse crate::{profile_internal, vecy, CombinatorTrait, IntoCombinator, Opt, ParseResults, ParserTrait, Squash, U8Set, VecY};\\n\\n#[derive(Debug)]\\npub struct Repeat1<T> {\\n    pub(crate) a: T,\\n    pub(crate) greedy: bool,\\n    // pub(crate) _phantom: std::marker::PhantomData<&'a T>,\\n}\\n\\n#[derive(Debug)]\\npub struct Repeat1Parser<'a, T> where T: CombinatorTrait {\\n    // TODO: store a_parsers in a Vec<Vec<Parser>> where the index of each inner vec is the repetition count of those parsers. That way, we can easily discard earlier parsers when we get a decisively successful parse result.\\n    pub(crate) a: &'a T,\\n    pub(crate) a_parsers: Vec<T::Parser<'a>>,\\n    pub(crate) position: usize,\\n    pub(crate) greedy: bool,\\n}\\n\\nimpl<T: CombinatorTrait> DynCombinatorTrait for Repeat1<T> {\\n    fn parse_dyn(&self, right_data: RightData, bytes: &[u8]) -> (Box<dyn ParserTrait + '_>, ParseResults) {\\n        let (parser, parse_results) = self.parse(right_data, bytes);\\n        (Box::new(parser), parse_results)\\n    }\\n\\n    fn one_shot_parse_dyn(&self, right_data: RightData, bytes: &[u8]) -> UnambiguousParseResults {\\n        self.one_shot_parse(right_data, bytes)\\n    }\\n}\\n\\nimpl<'b, T: CombinatorTrait > CombinatorTrait for Repeat1<T> {\\n    type Parser<'a> = Repeat1Parser<'a, T> where Self: 'a;\\n    type Output = Vec<T::Output>;\\n    type PartialOutput = Vec<T::PartialOutput>;\\n\\n    fn one_shot_parse(&self, right_data: RightData, bytes: &[u8]) -> UnambiguousParseResults {\\n        let mut right_data = right_data;\\n        let start_position = right_data.get_fields1().position;\\n        let mut prev_parse_result = Err(UnambiguousParseError::Fail);\\n        loop {\\n            let offset = right_data.get_fields1().position - start_position;\\n            let parse_result = self.a.one_shot_parse(right_data.clone(), &bytes[offset..]);\\n            match parse_result {\\n                Ok(one_shot_up_data) => {\\n                    if !self.greedy && prev_parse_result.is_ok() {\\n                        return Err(UnambiguousParseError::Ambiguous);\\n                    }\\n                    right_data = one_shot_up_data.clone().just_right_data();\\n                    prev_parse_result = Ok(one_shot_up_data);\\n                }\\n                Err(UnambiguousParseError::Fail) => {\\n                    return prev_parse_result;\\n                }\\n                Err(UnambiguousParseError::Ambiguous | UnambiguousParseError::Incomplete) => {\\n                    return parse_result;\\n                }\\n            }\\n        }\\n    }\\n\\n    fn parse(&self, right_data: RightData, bytes: &[u8]) -> (Self::Parser<'_>, ParseResults) {\\n        // return self.old_parse(right_data, bytes);\\n        let mut right_data = right_data;\\n        let start_position = right_data.get_fields1().position;\\n        let mut prev_parse_result = Err(UnambiguousParseError::Fail);\\n        loop {\\n            let offset = right_data.get_fields1().position - start_position;\\n            let parse_result = self.a.one_shot_parse(right_data.clone(), &bytes[offset..]);\\n            match parse_result {\\n                Ok(one_shot_up_data) => {\\n                    if !self.greedy && prev_parse_result.is_ok() {\\n                        let (parser, mut parse_results_rest) = self.old_parse(right_data.clone(), &bytes[offset..]);\\n                        let prev_right_data = parse_results_rest.up_data_vec.pop().unwrap().just_right_data();\\n                        parse_results_rest.up_data_vec.push(UpData::new(prev_right_data));\\n                        return (parser, parse_results_rest);\\n                    }\\n                    right_data = one_shot_up_data.clone().just_right_data();\\n                    prev_parse_result = Ok(one_shot_up_data);\\n                }\\n                Err(UnambiguousParseError::Fail) => {\\n                    if let Ok(one_shot_up_data) = prev_parse_result {\\n                        return (Repeat1Parser {\\n                            a: &self.a,\\n                            a_parsers: vec![],\\n                            position: start_position + bytes.len(),\\n                            greedy: self.greedy\\n                        }, ParseResults::new_single(UpData::new(one_shot_up_data.just_right_data()), true));\\n                    } else {\\n                        return (Repeat1Parser {\\n                            a: &self.a,\\n                            a_parsers: vec![],\\n                            position: start_position + bytes.len(),\\n                            greedy: self.greedy\\n                        }, ParseResults::empty_finished());\\n                    }\\n                }\\n                Err(UnambiguousParseError::Ambiguous) => {\\n                    let (parser, mut parse_results_rest) = self.old_parse(right_data, &bytes[offset..]);\\n                    if let Ok(one_shot_up_data) = prev_parse_result {\\n                        parse_results_rest.up_data_vec.push(UpData::new(one_shot_up_data.just_right_data()));\\n                    }\\n                    return (parser, parse_results_rest);\\n                }\\n                Err(UnambiguousParseError::Incomplete) => {\\n                    let (parser, mut parse_results_rest) = self.old_parse(right_data, &bytes[offset..]);\\n                    if let Ok(one_shot_up_data) = prev_parse_result {\\n                        parse_results_rest.up_data_vec.push(UpData::new(one_shot_up_data.just_right_data()));\\n                    }\\n                    return (parser, parse_results_rest);\\n                }\\n            }\\n        }\\n    }\\n\\n    fn old_parse(&self, right_data: RightData, bytes: &[u8]) -> (Self::Parser<'_>, ParseResults) {\\n        let start_position = right_data.get_fields1().position;\\n        let (parser, parse_results) = self.a.parse(right_data, bytes);\\n        if parse_results.done() && parse_results.up_data_vec.is_empty() {\\n            // Shortcut\\n            return (Repeat1Parser {\\n                a: &self.a,\\n                a_parsers: vec![],\\n                position: start_position + bytes.len(),\\n                greedy: self.greedy\\n            }, parse_results);\\n        } else if parse_results.up_data_vec.is_empty() {\\n            return (Repeat1Parser {\\n                a: &self.a,\\n                a_parsers: vec![parser],\\n                position: start_position + bytes.len(),\\n                greedy: self.greedy\\n            }, ParseResults::new(vecy![], false));\\n        }\\n        let mut parsers = if parse_results.done() {\\n            vec![]\\n        } else {\\n            vec![parser]\\n        };\\n        let mut all_prev_succeeded_decisively = parse_results.succeeds_decisively();\\n        let mut up_data_vec = parse_results.up_data_vec;\\n\\n        let mut next_up_data = up_data_vec.clone();\\n        while next_up_data.len() > 0 {\\n            for up_data in std::mem::take(&mut next_up_data) {\\n                #[cfg(feature = \\\"debug\\\")]\\n                let new_right_data2 = new_right_data.clone();\\n                let offset = up_data.get_fields1().position - start_position;\\n                let (parser, parse_results) = self.a.parse(up_data.just_right_data(), &bytes[offset..]);\\n                if !parse_results.done() {\\n                    parsers.push(parser);\\n                }\\n                all_prev_succeeded_decisively &= parse_results.succeeds_decisively();\\n                if self.greedy && all_prev_succeeded_decisively {\\n                    up_data_vec.clear();\\n                    parsers.clear();\\n                }\\n                // if !(self.greedy && parse_results.succeeds_decisively()) && parse_results.up_data_vec.len() > 0 && up_data_vec.len() > 0 {\\n                //     println!(\\\"parse_results: {:?}\\\", parse_results);\\n                // }\\n                #[cfg(feature = \\\"debug\\\")]\\n                for UpData { right_data } in &parse_results.up_data_vec {\\n                    if &new_right_data2 == right_data {\\n                        panic!(\\\"Repeat1Parser::old_parse: loop detected. new_right_data == right_data. This can happen if you repeat a parser that can match the empty string?\\\");\\n                    }\\n                }\\n                next_up_data.extend(parse_results.up_data_vec);\\n            }\\n            if !up_data_vec.is_empty() && !next_up_data.is_empty() {\\n                let end_pos = start_position + bytes.len();\\n                let pos1 = up_data_vec[0].get_fields1().position;\\n                let pos2 = next_up_data[0].get_fields1().position;\\n                if end_pos < pos1 + 1000 || end_pos < pos2 + 1000 {\\n                    up_data_vec.clear();\\n                }\\n            }\\n            up_data_vec.extend(next_up_data.clone());\\n        }\\n\\n        let done = parsers.is_empty();\\n\\n        (\\n            Repeat1Parser {\\n                a: &self.a,\\n                a_parsers: parsers,\\n                position: start_position + bytes.len(),\\n                greedy: self.greedy\\n            },\\n            ParseResults::new(up_data_vec, done)\\n        )\\n    }\\n}\\n\\nimpl<'a, T: BaseCombinatorTrait> BaseCombinatorTrait for Repeat1<T> {\\n    fn as_any(&self) -> &dyn std::any::Any where Self: 'static {\\n        self\\n    }\\n    fn apply_to_children(&self, f: &mut dyn FnMut(&dyn BaseCombinatorTrait)) {\\n        f(&self.a);\\n    }\\n}\\n\\nimpl<'a, T> ParserTrait for Repeat1Parser<'a, T> where T: CombinatorTrait {\\n    fn get_u8set(&self) -> U8Set {\\n        if self.a_parsers.is_empty() {\\n            U8Set::none()\\n        } else {\\n            let mut u8set = U8Set::none();\\n            for p in &self.a_parsers {\\n                u8set = u8set | p.get_u8set();\\n            }\\n            u8set\\n        }\\n    }\\n\\n    fn parse(&mut self, bytes: &[u8]) -> ParseResults {\\n        let mut up_data_as = VecY::new();\\n        // let mut up_data_as: BTreeMap<usize, RightData, RightDataGettersSquasher> = BTreeMap::new();\\n\\n        self.a_parsers.retain_mut(|mut a_parser| {\\n            let parse_results = a_parser.parse(bytes);\\n            // up_data_as.entry(parse_results.up_data_vec.len()).or_default().extend(parse_results.up_data_vec);\\n            up_data_as.extend(parse_results.up_data_vec);\\n            !parse_results.done\\n        });\\n\\n        up_data_as.squash();\\n\\n        let mut i = 0;\\n        while i < up_data_as.len() {\\n            let up_data_a = up_data_as[i].clone();\\n            let offset = up_data_a.get_fields1().position - self.position;\\n            let (a_parser, parse_results) = self.a.parse(up_data_a.just_right_data(), &bytes[offset..]);\\n            if !parse_results.done() {\\n                self.a_parsers.push(a_parser);\\n            }\\n            // up_data_as.entry(i).or_default().extend(parse_results.up_data_vec);\\n            up_data_as.extend(parse_results.up_data_vec);\\n            i += 1;\\n        }\\n\\n        self.position += bytes.len();\\n\\n        ParseResults::new(up_data_as, self.a_parsers.is_empty())\\n    }\\n}\\n\\npub fn Repeat1<T: IntoCombinator>(a: T)-> impl CombinatorTrait {\\n    // profile_internal(\\\"repeat1\\\", Repeat1 {\\n    //     a: a.into_combinator(),\\n    //     greedy: false,\\n    // })\\n    Repeat1 {\\n        a: a.into_combinator(),\\n        greedy: false,\\n        // _phantom: std::marker::PhantomData,\\n    }\\n}\\n\\npub fn repeat1<T: IntoCombinator>(a: T)-> impl CombinatorTrait {\\n    Repeat1 {\\n        a: a.into_combinator(),\\n        greedy: false,\\n    }\\n}\\n\\npub fn repeat1_greedy<T: IntoCombinator>(a: T)-> impl CombinatorTrait {\\n    profile_internal(\\\"repeat1_greedy\\\", Repeat1 {\\n        a: a.into_combinator(),\\n        greedy: true,\\n        // _phantom: std::marker::PhantomData,\\n    })\\n}\\n\\npub fn repeat0<T: IntoCombinator>(a: T)-> impl CombinatorTrait {\\n    Opt { inner: Repeat1 { a: a.into_combinator(), greedy: false }, greedy: false }\\n}\\n\\npub fn repeat0_greedy<T: IntoCombinator>(a: T)-> impl CombinatorTrait {\\n    Opt { inner: Repeat1 { a: a.into_combinator(), greedy: true }, greedy: true }\\n}\\n\\npub fn seprep1<T: IntoCombinator + Clone, U: IntoCombinator>(a: T, b: U)-> impl CombinatorTrait {\\n    seq!(a.clone(), repeat0(seq!(b, a)))\\n}\"}, {\"path\": \"src/_03_combinators/core/seq.rs\", \"tokens\": 4126, \"content\": \"\\nuse crate::{RightData, RightDataGetters};\\nuse crate::VecX;\\nuse crate::{profile_internal, CombinatorTrait, ParseResultTrait, ParseResults, ParserTrait, U8Set, VecY, UpData, OneShotUpData};\\n// src/combinators/seq.rs\\nuse crate::{BaseCombinatorTrait, DynCombinatorTrait, UnambiguousParseResults};\\nuse std::collections::BTreeMap;\\nuse std::hash::Hash;\\n\\nmacro_rules! profile {\\n    ($name:expr, $expr:expr) => {\\n        $expr\\n    };\\n}\\n\\n#[derive(Debug)]\\npub struct Seq<'a> {\\n    pub(crate) children: VecX<Box<dyn DynCombinatorTrait + 'a>>,\\n    pub(crate) start_index: usize,\\n}\\n\\n#[derive(Debug)]\\npub struct SeqParser<'a> {\\n    pub(crate) parsers: Vec<(usize, Box<dyn ParserTrait + 'a>)>,\\n    pub(crate) combinators: &'a VecX<Box<dyn DynCombinatorTrait + 'a>>,\\n    pub(crate) position: usize,\\n}\\n\\nimpl DynCombinatorTrait for Seq<'_> {\\n    fn parse_dyn(&self, right_data: RightData, bytes: &[u8]) -> (Box<dyn ParserTrait + '_>, ParseResults) {\\n        let (parser, parse_results) = self.parse(right_data, bytes);\\n        (Box::new(parser), parse_results)\\n    }\\n\\n    fn one_shot_parse_dyn<'a>(&'a self, right_data: RightData, bytes: &[u8]) -> UnambiguousParseResults {\\n        self.one_shot_parse(right_data, bytes)\\n    }\\n}\\nimpl CombinatorTrait for Seq<'_> {\\n    type Parser<'a> = SeqParser<'a> where Self: 'a;\\n    type Output = Vec<Box<dyn std::any::Any>>;\\n    type PartialOutput = Vec<Option<Box<dyn std::any::Any>>>;\\n\\n    fn one_shot_parse(&self, right_data: RightData, bytes: &[u8]) -> UnambiguousParseResults {\\n        let mut right_data = right_data;\\n        let start_position = right_data.get_fields1().position;\\n        for combinator in self.children.iter() {\\n            let offset = right_data.get_fields1().position - start_position;\\n            let result = combinator.one_shot_parse(right_data, &bytes[offset..]);\\n            match result {\\n                Ok(one_shot_up_data) => {\\n                    right_data = one_shot_up_data.just_right_data();\\n                },\\n                Err(err) => {\\n                    return Err(err);\\n                }\\n            }\\n        }\\n        Ok(OneShotUpData::new(right_data))\\n    }\\n\\n    fn old_parse(&self, right_data: RightData, bytes: &[u8]) -> (Self::Parser<'_>, ParseResults) {\\n        let start_position = right_data.get_fields1().position;\\n\\n        let mut combinator_index = self.start_index;\\n\\n        // if combinator_index >= self.children.len() {\\n        //     return (Parser::FailParser(FailParser), ParseResults::new_single(right_data, true));\\n        // }\\n\\n        let combinator = &self.children[combinator_index];\\n        let (parser, parse_results) = profile!(\\\"seq first child parse\\\", {\\n            combinator.parse(right_data, &bytes)\\n        });\\n        let done = parse_results.done();\\n        if done && parse_results.up_data_vec.is_empty() {\\n            // Shortcut\\n            return (SeqParser {\\n                parsers: vec![],\\n                combinators: &self.children,\\n                position: start_position + bytes.len(),\\n            }, parse_results);\\n        }\\n        let mut parsers: Vec<(usize, Box<dyn ParserTrait>)> = if done {\\n            vec![]\\n        } else {\\n            vec![(combinator_index, parser)]\\n        };\\n        let mut final_up_data: VecY<UpData>;\\n        let mut next_up_data_vec: VecY<UpData>;\\n        if combinator_index + 1 < self.children.len() {\\n            next_up_data_vec = parse_results.up_data_vec;\\n            final_up_data = VecY::new();\\n        } else {\\n            next_up_data_vec = VecY::new();\\n            final_up_data = parse_results.up_data_vec;\\n        }\\n\\n        combinator_index += 1;\\n\\n        let mut helper = |right_data: RightData, combinator_index: usize| {\\n            let offset = right_data.get_fields1().position - start_position;\\n            let combinator = &self.children[combinator_index];\\n            let (parser, parse_results) = profile!(\\\"seq other child parse\\\", {\\n                combinator.parse(right_data, &bytes[offset..])\\n            });\\n            if !parse_results.done() {\\n                parsers.push((combinator_index, parser));\\n            }\\n            if combinator_index + 1 < self.children.len() {\\n                parse_results.up_data_vec\\n            } else {\\n                final_up_data.extend(parse_results.up_data_vec);\\n                VecY::new()\\n            }\\n        };\\n\\n        while combinator_index < self.children.len() && !next_up_data_vec.is_empty() {\\n            if next_up_data_vec.len() == 1 {\\n                let up_data = next_up_data_vec.pop().unwrap();\\n                next_up_data_vec = helper(up_data.just_right_data(), combinator_index);\\n            } else {\\n                let mut next_next_up_data_vec = VecY::new();\\n                for up_data in next_up_data_vec {\\n                    next_next_up_data_vec.extend(helper(up_data.just_right_data(), combinator_index));\\n                }\\n                next_up_data_vec = next_next_up_data_vec;\\n            }\\n            combinator_index += 1;\\n        }\\n\\n        if parsers.is_empty() {\\n            return (SeqParser {\\n                parsers: vec![],\\n                combinators: &self.children,\\n                position: start_position + bytes.len(),\\n            }, ParseResults::new(final_up_data, true));\\n        }\\n\\n        let parser = SeqParser {\\n            parsers,\\n            combinators: &self.children,\\n            position: start_position + bytes.len(),\\n        };\\n\\n        let parse_results = ParseResults::new(final_up_data, false);\\n\\n        (parser, parse_results)\\n    }\\n}\\n\\nimpl BaseCombinatorTrait for Seq<'_> {\\n    fn as_any(&self) -> &dyn std::any::Any where Self: 'static {\\n        self\\n    }\\n    fn apply_to_children(&self, f: &mut dyn FnMut(&dyn BaseCombinatorTrait)) {\\n        for child in self.children.iter() {\\n            f(child);\\n        }\\n    }\\n}\\n\\nimpl ParserTrait for SeqParser<'_> {\\n    fn get_u8set(&self) -> U8Set {\\n        let mut u8set = U8Set::none();\\n        for (_, parser) in &self.parsers {\\n            u8set = u8set.union(&parser.get_u8set());\\n        }\\n        u8set\\n    }\\n\\n    fn parse(&mut self, bytes: &[u8]) -> ParseResults {\\n        profile!(\\\"SeqParser::parse\\\", {\\n        let mut final_up_data: VecY<UpData> = VecY::new();\\n        // let mut parser_initialization_queue: BTreeMap<usize, RightData, RightDataGettersSquasher> = BTreeMap::new();\\n        let mut parser_initialization_queue: BTreeMap<usize, Vec<UpData>> = BTreeMap::new();\\n\\n        // Eliminate duplicate parsers\\n        // if self.parsers.len() > 10 {\\n        //     self.parsers = std::mem::take(&mut self.parsers).into_iter().collect::<HashSet<_>>().into_iter().collect();\\n        // }\\n\\n        profile!(\\\"SeqParser::parse part 1\\\", {\\n        self.parsers.retain_mut(|(combinator_index, parser)| {\\n            let parse_results = profile!(\\\"SeqParser::parse child Parser::parse\\\", {\\n                parser.parse(bytes)\\n            });\\n            let done = parse_results.done();\\n            if *combinator_index + 1 < self.combinators.len() {\\n                profile!(\\\"SeqParser::parse extend parser_initialization_queue\\\", {\\n                    parser_initialization_queue.entry(*combinator_index + 1).or_default().extend(parse_results.up_data_vec);\\n                });\\n            } else {\\n                profile!(\\\"SeqParser::parse extend final_up_data\\\", {\\n                    final_up_data.extend(parse_results.up_data_vec);\\n                });\\n            }\\n            !done\\n        });\\n        });\\n\\n        profile!(\\\"SeqParser::parse part 2\\\", {\\n        while let Some((combinator_index, up_data_vec)) = parser_initialization_queue.pop_first() {\\n            // for right_data in right_data_squasher.finish() {\\n            for up_data in up_data_vec {\\n                let offset = up_data.get_fields1().position - self.position;\\n                let combinator = &self.combinators[combinator_index];\\n                let (parser, parse_results) = profile!(\\\"SeqParser::parse child Combinator::parse\\\", {\\n                    combinator.parse(up_data.just_right_data(), &bytes[offset..])\\n                });\\n                if !parse_results.done() {\\n                    self.parsers.push((combinator_index, parser));\\n                }\\n                if combinator_index + 1 < self.combinators.len() {\\n                    profile!(\\\"SeqParser::parse extend parser_initialization_queue\\\", {\\n                        parser_initialization_queue.entry(combinator_index + 1).or_default().extend(parse_results.up_data_vec);\\n                    });\\n                } else {\\n                    final_up_data.extend(parse_results.up_data_vec);\\n                }\\n            }\\n        }\\n        });\\n\\n        self.position += bytes.len();\\n\\n        ParseResults::new(final_up_data, self.parsers.is_empty())\\n            })\\n    }\\n}\\n\\npub fn _seq(v: Vec<Box<dyn DynCombinatorTrait>>) -> impl CombinatorTrait {\\n    profile_internal(\\\"seq\\\", Seq {\\n        children: v.into_iter().collect(),\\n        start_index: 0,\\n    })\\n}\"}, {\"path\": \"src/_03_combinators/core/seq_macro.rs\", \"tokens\": 5832, \"content\": \"use crate::IntoCombinator;\\n\\npub fn seqn_helper<T: IntoCombinator>(x: T) -> T::Output {\\n    IntoCombinator::into_combinator(x)\\n}\\n\\n#[macro_export]\\nmacro_rules! seq {\\n    ($c0:expr $(,)?) => {{\\n        $c0\\n    }};\\n    ($c0:expr, $c1:expr $(,)?) => {{\\n        use $crate::seqn_helper as h;\\n        $crate::Seq2 {\\n            c0: $crate::IntoCombinator::into_combinator($c0),\\n            c1: h($c1),\\n        }\\n    }};\\n    ($c0:expr, $c1:expr, $c2:expr $(,)?) => {{\\n        use $crate::seqn_helper as h;\\n        $crate::Seq3 {\\n            c0: $crate::IntoCombinator::into_combinator($c0),\\n            c1: h($c1),\\n            c2: h($c2),\\n        }\\n    }};\\n    ($c0:expr, $c1:expr, $c2:expr, $c3:expr $(,)?) => {{\\n        use $crate::seqn_helper as h;\\n        $crate::Seq4 {\\n            c0: $crate::IntoCombinator::into_combinator($c0),\\n            c1: h($c1),\\n            c2: h($c2),\\n            c3: h($c3),\\n        }\\n    }};\\n    ($c0:expr, $c1:expr, $c2:expr, $c3:expr, $c4:expr $(,)?) => {{\\n        use $crate::seqn_helper as h;\\n        $crate::Seq5 {\\n            c0: $crate::IntoCombinator::into_combinator($c0),\\n            c1: h($c1),\\n            c2: h($c2),\\n            c3: h($c3),\\n            c4: h($c4),\\n        }\\n    }};\\n    ($c0:expr, $c1:expr, $c2:expr, $c3:expr, $c4:expr, $c5:expr $(,)?) => {{\\n        use $crate::seqn_helper as h;\\n        $crate::Seq6 {\\n            c0: $crate::IntoCombinator::into_combinator($c0),\\n            c1: h($c1),\\n            c2: h($c2),\\n            c3: h($c3),\\n            c4: h($c4),\\n            c5: h($c5),\\n        }\\n    }};\\n    ($c0:expr, $c1:expr, $c2:expr, $c3:expr, $c4:expr, $c5:expr, $c6:expr $(,)?) => {{\\n        use $crate::seqn_helper as h;\\n        $crate::Seq7 {\\n            c0: $crate::IntoCombinator::into_combinator($c0),\\n            c1: h($c1),\\n            c2: h($c2),\\n            c3: h($c3),\\n            c4: h($c4),\\n            c5: h($c5),\\n            c6: h($c6),\\n        }\\n    }};\\n    ($c0:expr, $c1:expr, $c2:expr, $c3:expr, $c4:expr, $c5:expr, $c6:expr, $c7:expr $(,)?) => {{\\n        use $crate::seqn_helper as h;\\n        $crate::Seq8 {\\n            c0: $crate::IntoCombinator::into_combinator($c0),\\n            c1: h($c1),\\n            c2: h($c2),\\n            c3: h($c3),\\n            c4: h($c4),\\n            c5: h($c5),\\n            c6: h($c6),\\n            c7: h($c7),\\n        }\\n    }};\\n    ($c0:expr, $c1:expr, $c2:expr, $c3:expr, $c4:expr, $c5:expr, $c6:expr, $c7:expr, $c8:expr $(,)?) => {{\\n        use $crate::seqn_helper as h;\\n        $crate::Seq9 {\\n            c0: $crate::IntoCombinator::into_combinator($c0),\\n            c1: h($c1),\\n            c2: h($c2),\\n            c3: h($c3),\\n            c4: h($c4),\\n            c5: h($c5),\\n            c6: h($c6),\\n            c7: h($c7),\\n            c8: h($c8),\\n        }\\n    }};\\n    ($c0:expr, $c1:expr, $c2:expr, $c3:expr, $c4:expr, $c5:expr, $c6:expr, $c7:expr, $c8:expr, $c9:expr $(,)?) => {{\\n        use $crate::seqn_helper as h;\\n        $crate::Seq10 {\\n            c0: $crate::IntoCombinator::into_combinator($c0),\\n            c1: h($c1),\\n            c2: h($c2),\\n            c3: h($c3),\\n            c4: h($c4),\\n            c5: h($c5),\\n            c6: h($c6),\\n            c7: h($c7),\\n            c8: h($c8),\\n            c9: h($c9),\\n        }\\n    }};\\n    ($c0:expr, $c1:expr, $c2:expr, $c3:expr, $c4:expr, $c5:expr, $c6:expr, $c7:expr, $c8:expr, $c9:expr, $c10:expr $(,)?) => {{\\n        use $crate::seqn_helper as h;\\n        $crate::Seq11 {\\n            c0: $crate::IntoCombinator::into_combinator($c0),\\n            c1: h($c1),\\n            c2: h($c2),\\n            c3: h($c3),\\n            c4: h($c4),\\n            c5: h($c5),\\n            c6: h($c6),\\n            c7: h($c7),\\n            c8: h($c8),\\n            c9: h($c9),\\n            c10: h($c10),\\n        }\\n    }};\\n    ($c0:expr, $c1:expr, $c2:expr, $c3:expr, $c4:expr, $c5:expr, $c6:expr, $c7:expr, $c8:expr, $c9:expr, $c10:expr, $c11:expr $(,)?) => {{\\n        use $crate::seqn_helper as h;\\n        $crate::Seq12 {\\n            c0: $crate::IntoCombinator::into_combinator($c0),\\n            c1: h($c1),\\n            c2: h($c2),\\n            c3: h($c3),\\n            c4: h($c4),\\n            c5: h($c5),\\n            c6: h($c6),\\n            c7: h($c7),\\n            c8: h($c8),\\n            c9: h($c9),\\n            c10: h($c10),\\n            c11: h($c11),\\n        }\\n    }};\\n    ($c0:expr, $c1:expr, $c2:expr, $c3:expr, $c4:expr, $c5:expr, $c6:expr, $c7:expr, $c8:expr, $c9:expr, $c10:expr, $c11:expr, $c12:expr $(,)?) => {{\\n        use $crate::seqn_helper as h;\\n        $crate::Seq13 {\\n            c0: $crate::IntoCombinator::into_combinator($c0),\\n            c1: h($c1),\\n            c2: h($c2),\\n            c3: h($c3),\\n            c4: h($c4),\\n            c5: h($c5),\\n            c6: h($c6),\\n            c7: h($c7),\\n            c8: h($c8),\\n            c9: h($c9),\\n            c10: h($c10),\\n            c11: h($c11),\\n            c12: h($c12),\\n        }\\n    }};\\n    ($c0:expr, $c1:expr, $c2:expr, $c3:expr, $c4:expr, $c5:expr, $c6:expr, $c7:expr, $c8:expr, $c9:expr, $c10:expr, $c11:expr, $c12:expr, $c13:expr $(,)?) => {{\\n        use $crate::seqn_helper as h;\\n        $crate::Seq14 {\\n            c0: $crate::IntoCombinator::into_combinator($c0),\\n            c1: h($c1),\\n            c2: h($c2),\\n            c3: h($c3),\\n            c4: h($c4),\\n            c5: h($c5),\\n            c6: h($c6),\\n            c7: h($c7),\\n            c8: h($c8),\\n            c9: h($c9),\\n            c10: h($c10),\\n            c11: h($c11),\\n            c12: h($c12),\\n            c13: h($c13),\\n        }\\n    }};\\n    ($c0:expr, $c1:expr, $c2:expr, $c3:expr, $c4:expr, $c5:expr, $c6:expr, $c7:expr, $c8:expr, $c9:expr, $c10:expr, $c11:expr, $c12:expr, $c13:expr, $c14:expr $(,)?) => {{\\n        use $crate::seqn_helper as h;\\n        $crate::Seq15 {\\n            c0: $crate::IntoCombinator::into_combinator($c0),\\n            c1: h($c1),\\n            c2: h($c2),\\n            c3: h($c3),\\n            c4: h($c4),\\n            c5: h($c5),\\n            c6: h($c6),\\n            c7: h($c7),\\n            c8: h($c8),\\n            c9: h($c9),\\n            c10: h($c10),\\n            c11: h($c11),\\n            c12: h($c12),\\n            c13: h($c13),\\n            c14: h($c14),\\n        }\\n    }};\\n    ($c0:expr, $c1:expr, $c2:expr, $c3:expr, $c4:expr, $c5:expr, $c6:expr, $c7:expr, $c8:expr, $c9:expr, $c10:expr, $c11:expr, $c12:expr, $c13:expr, $c14:expr, $c15:expr $(,)?) => {{\\n        use $crate::seqn_helper as h;\\n        $crate::Seq16 {\\n            c0: $crate::IntoCombinator::into_combinator($c0),\\n            c1: h($c1),\\n            c2: h($c2),\\n            c3: h($c3),\\n            c4: h($c4),\\n            c5: h($c5),\\n            c6: h($c6),\\n            c7: h($c7),\\n            c8: h($c8),\\n            c9: h($c9),\\n            c10: h($c10),\\n            c11: h($c11),\\n            c12: h($c12),\\n            c13: h($c13),\\n            c14: h($c14),\\n            c15: h($c15),\\n        }\\n    }};\\n    ($c0:expr, $c1:expr, $c2:expr, $c3:expr, $c4:expr, $c5:expr, $c6:expr, $c7:expr, $c8:expr, $c9:expr, $c10:expr, $c11:expr, $c12:expr, $c13:expr, $c14:expr, $c15:expr, $($rest:expr),+ $(,)?) => {{\\n        fn convert<T: $crate::IntoCombinator>(x: T) -> Box<dyn $crate::CombinatorTrait> where T::Output {\\n            Box::new(x.into_combinator())\\n        }\\n\\n        $crate::_seq(vec![convert($c0), convert($c1), convert($c2), convert($c3), convert($c4), convert($c5), convert($c6), convert($c7), convert($c8), convert($c9), convert($c10), convert($c11), convert($c12), convert($c13), convert($c14), convert($c15), $(convert($rest)),+])\\n    }};\\n}\"}, {\"path\": \"src/_03_combinators/core/seqn.rs\", \"tokens\": 5594, \"content\": \"\\n// src/_03_combinators/core/seqn.rs\\nuse crate::{BaseCombinatorTrait, CombinatorTrait, IntoCombinator, ParseResultTrait, ParseResults, ParserTrait, RightData, RightDataGetters, Squash, U8Set, UnambiguousParseResults, VecY, UpData, OneShotUpData};\\n\\nmacro_rules! profile {\\n    ($name:expr, $expr:expr) => {\\n        $expr\\n    };\\n}\\n\\nmacro_rules! count_hit { ($tag:expr) => {} }\\n\\n#[macro_export]\\nmacro_rules! define_seq {\\n    ($seq_name:ident, $seq_parser_name:ident, $seq_enum_name:ident, $seq_partial_enum_name:ident, $first:ident, $($rest:ident),+ $(,)?) => {\\n        #[derive(Debug)]\\n        pub struct $seq_name<$first, $($rest),+>\\n        where\\n            $($rest: CombinatorTrait),+\\n        {\\n            pub(crate) $first: $first,\\n            $(pub(crate) $rest: $rest),+\\n        }\\n\\n        #[derive(Debug)]\\n        pub struct $seq_parser_name<'a, $first, $($rest),+>\\n        where\\n            $first: CombinatorTrait,\\n            $($rest: CombinatorTrait),+\\n        {\\n            pub(crate) combinator: &'a $seq_name<$first, $($rest),+>,\\n            pub(crate) $first: Option<$first::Parser<'a>>,\\n            $(pub(crate) $rest: Vec<$rest::Parser<'a>>,)+\\n            pub(crate) position: usize,\\n        }\\n\\n        #[derive(Debug)]\\n        pub struct $seq_enum_name<$first, $($rest),+>\\n        where\\n            $first: CombinatorTrait,\\n            $($rest: CombinatorTrait),+\\n        {\\n            pub(crate) $first: $first::Output,\\n            $(pub(crate) $rest: $rest::Output),+\\n        }\\n\\n        #[derive(Debug)]\\n        pub struct $seq_partial_enum_name<$first, $($rest),+>\\n        where\\n            $first: CombinatorTrait,\\n            $($rest: CombinatorTrait),+\\n        {\\n            pub(crate) $first: Option<$first::PartialOutput>,\\n            $(pub(crate) $rest: Option<$rest::PartialOutput>),+\\n        }\\n\\n        impl<$first, $($rest),+> $crate::DynCombinatorTrait for $seq_name<$first, $($rest),+>\\n        where\\n            $first: CombinatorTrait,\\n            $($rest: CombinatorTrait),+,\\n        {\\n            fn parse_dyn(&self, right_data: RightData, bytes: &[u8]) -> (Box<dyn ParserTrait + '_>, ParseResults) {\\n                let (parser, parse_results) = self.parse(right_data, bytes);\\n                (Box::new(parser), parse_results)\\n            }\\n\\n            fn one_shot_parse_dyn(&self, right_data: RightData, bytes: &[u8]) -> UnambiguousParseResults {\\n                self.one_shot_parse(right_data, bytes)\\n            }\\n        }\\n\\n        impl<$first, $($rest),+> CombinatorTrait for $seq_name<$first, $($rest),+>\\n        where\\n            $first: CombinatorTrait,\\n            $($rest: CombinatorTrait),+,\\n        {\\n            type Parser<'a> = $seq_parser_name<'a, $first, $($rest),+> where Self: 'a;\\n            type Output = $seq_enum_name<$first, $($rest),+>;\\n            type PartialOutput = $seq_partial_enum_name<$first, $($rest),+>;\\n\\n            fn one_shot_parse(&self, right_data: RightData, bytes: &[u8]) -> $crate::UnambiguousParseResults {\\n                let mut right_data = right_data;\\n                let start_position = right_data.get_fields1().position;\\n                let result = self.$first.one_shot_parse(right_data, bytes);\\n                match result {\\n                    Ok(one_shot_up_data) => {\\n                        right_data = one_shot_up_data.just_right_data();\\n                    },\\n                    Err(err) => {\\n                        return Err(err);\\n                    }\\n                }\\n                $(\\n                    let offset = right_data.get_fields1().position - start_position;\\n                    let result = self.$rest.one_shot_parse(right_data, &bytes[offset..]);\\n                    match result {\\n                        Ok(one_shot_up_data) => {\\n                            right_data = one_shot_up_data.just_right_data();\\n                        },\\n                        Err(err) => {\\n                            return Err(err);\\n                        }\\n                    }\\n                )+\\n                $crate::UnambiguousParseResults::Ok(OneShotUpData::new(right_data))\\n            }\\n\\n            fn old_parse(&self, right_data: RightData, bytes: &[u8]) -> (Self::Parser<'_>, ParseResults) {\\n                let start_position = right_data.get_fields1().position;\\n\\n                let first_combinator = &self.$first;\\n                let (first_parser, first_parse_results) = profile!(stringify!($seq_name, \\\" first child parse\\\"), {\\n                    first_combinator.parse(right_data, &bytes)\\n                });\\n\\n                let mut all_done = first_parse_results.done();\\n                if all_done && first_parse_results.up_data_vec.is_empty() {\\n                    // Shortcut\\n                    return (\\n                        $seq_parser_name {\\n                            combinator: self,\\n                            $first: None,\\n                            $($rest: vec![],)+\\n                            position: start_position + bytes.len(),\\n                        },\\n                        first_parse_results\\n                    );\\n                }\\n                let first_parser_vec = if all_done { None } else { Some(first_parser) };\\n\\n                let mut next_up_data_vec = first_parse_results.up_data_vec;\\n\\n                fn helper<'a, T: CombinatorTrait>(right_data: RightData, next_combinator: &'a T, bytes: &[u8], start_position: usize) -> (T::Parser<'a>, ParseResults) {\\n                    let offset = right_data.get_fields1().position - start_position;\\n                    profile!(stringify!($seq_name, \\\" child parse\\\"), {\\n                        next_combinator.parse(right_data, &bytes[offset..])\\n                    })\\n                }\\n\\n                let mut seqn_parser = $seq_parser_name {\\n                    combinator: self,\\n                    $first: first_parser_vec,\\n                    $($rest: vec![],)+\\n                    position: start_position + bytes.len(),\\n                };\\n\\n                // process each child combinator\\n                $(\\n                    if next_up_data_vec.is_empty() {\\n                        return (seqn_parser, ParseResults::empty(all_done));\\n                    }\\n\\n                    let mut next_next_up_data_vec = VecY::new();\\n                    for up_data in next_up_data_vec {\\n                        let (parser, parse_results) = helper(up_data.just_right_data(), &self.$rest, &bytes, start_position);\\n                        if !parse_results.done() {\\n                            all_done = false;\\n                            seqn_parser.$rest.push(parser);\\n                        }\\n                        next_next_up_data_vec.extend(parse_results.up_data_vec);\\n                    }\\n                    next_up_data_vec = next_next_up_data_vec;\\n                )+\\n\\n                let parse_results = ParseResults::new(next_up_data_vec, all_done);\\n\\n                (seqn_parser, parse_results)\\n            }\\n        }\\n\\n        impl<'a, $first, $($rest),+> ParserTrait for $seq_parser_name<'a, $first, $($rest),+>\\n        where\\n            $first: CombinatorTrait,\\n            $($rest: CombinatorTrait),+\\n        {\\n            fn get_u8set(&self) -> U8Set {\\n                let mut u8set = U8Set::none();\\n                if let Some(parser) = &self.$first {\\n                    u8set = u8set.union(&parser.get_u8set());\\n                }\\n                $(\\n                    for parser in &self.$rest {\\n                        u8set = u8set.union(&parser.get_u8set());\\n                    }\\n                )+\\n                u8set\\n            }\\n\\n            fn parse(&mut self, bytes: &[u8]) -> ParseResults {\\n                profile!(stringify!($seq_parser_name, \\\"::parse\\\"), {\\n                    let mut new_up_data: VecY<UpData> = VecY::new();\\n\\n                    // first child\\n                    if let Some(parser) = &mut self.$first {\\n                        let parse_results = profile!(stringify!($seq_parser_name, \\\"::parse child Parser::parse\\\"), { parser.parse(bytes) });\\n                        new_up_data.extend(parse_results.up_data_vec);\\n                        if parse_results.done {\\n                            self.$first = None;\\n                        }\\n                    }\\n\\n                    let mut all_done = self.$first.is_none();\\n\\n                    // rest of the children\\n                    $(\\n                        let mut up_data_to_init_this_child = std::mem::take(&mut new_up_data);\\n                        // TODO: Squashing after each sequent is good for performance (~5% gain on Python parser), but makes it difficult to reason about building the parse tree.\\n                        //  So, I'm leaving it out for now. But it'd be good to revisit this and see if we could bring it back.\\n                        // up_data_to_init_this_child.squash();\\n\\n                        // step existing parsers for this child\\n                        self.$rest.retain_mut(|parser| {\\n                            let parse_results = profile!(stringify!($seq_parser_name, \\\"::parse child Parser::parse\\\"), {\\n                                parser.parse(bytes)\\n                            });\\n                            new_up_data.extend(parse_results.up_data_vec);\\n                            !parse_results.done\\n                        });\\n\\n                        // new parsers for this child, one for each right_data emitted by the previous child\\n                        for up_data in up_data_to_init_this_child {\\n                            let offset = up_data.get_fields1().position - self.position;\\n                            let combinator = &self.combinator.$rest;\\n                            let (parser, parse_results) = profile!(stringify!($seq_parser_name, \\\"::parse child Combinator::parse\\\"), {\\n                                combinator.parse(up_data.just_right_data(), &bytes[offset..])\\n                            });\\n                            if !parse_results.done() {\\n                                self.$rest.push(parser);\\n                            }\\n                            new_up_data.extend(parse_results.up_data_vec);\\n                        }\\n\\n                        all_done &= self.$rest.is_empty();\\n                    )+\\n\\n                    self.position += bytes.len();\\n\\n                    ParseResults::new(new_up_data, all_done)\\n                })\\n            }\\n        }\\n\\n        impl<$first, $($rest),+> BaseCombinatorTrait for $seq_name<$first, $($rest),+>\\n        where\\n            $first: CombinatorTrait,\\n            $($rest: CombinatorTrait),+,\\n        {\\n            fn as_any(&self) -> &dyn std::any::Any where Self: 'static {\\n                self\\n            }\\n\\n            fn apply_to_children(&self, f: &mut dyn FnMut(&dyn BaseCombinatorTrait)) {\\n                f(&self.$first);\\n                $(f(&self.$rest);)+\\n            }\\n        }\\n    };\\n}\\n\\ndefine_seq!(Seq2, Seq2Parser, Seq2Enum, Seq2PartialEnum, c0, c1);\\ndefine_seq!(Seq3, Seq3Parser, Seq3Enum, Seq3PartialEnum, c0, c1, c2);\\ndefine_seq!(Seq4, Seq4Parser, Seq4Enum, Seq4PartialEnum, c0, c1, c2, c3);\\ndefine_seq!(Seq5, Seq5Parser, Seq5Enum, Seq5PartialEnum, c0, c1, c2, c3, c4);\\ndefine_seq!(Seq6, Seq6Parser, Seq6Enum, Seq6PartialEnum, c0, c1, c2, c3, c4, c5);\\ndefine_seq!(Seq7, Seq7Parser, Seq7Enum, Seq7PartialEnum, c0, c1, c2, c3, c4, c5, c6);\\ndefine_seq!(Seq8, Seq8Parser, Seq8Enum, Seq8PartialEnum, c0, c1, c2, c3, c4, c5, c6, c7);\\ndefine_seq!(Seq9, Seq9Parser, Seq9Enum, Seq9PartialEnum, c0, c1, c2, c3, c4, c5, c6, c7, c8);\\ndefine_seq!(Seq10, Seq10Parser, Seq10Enum, Seq10PartialEnum, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9);\\ndefine_seq!(Seq11, Seq11Parser, Seq11Enum, Seq11PartialEnum, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, c10);\\ndefine_seq!(Seq12, Seq12Parser, Seq12Enum, Seq12PartialEnum, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11);\\ndefine_seq!(Seq13, Seq13Parser, Seq13Enum, Seq13PartialEnum, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12);\"}, {\"path\": \"src/_03_combinators/derived.rs\", \"tokens\": 802, \"content\": \"\\n// src/_03_combinators/derived.rs\\nuse crate::{opt, opt_greedy, repeat0, repeat0_greedy, seq, symbol, Choice, RightData, UpData, OneShotUpData};\\nuse crate::{CombinatorTrait, IntoDyn};\\n\\npub fn seprep1(a: impl CombinatorTrait, b: impl CombinatorTrait)-> impl CombinatorTrait {\\n    let a = symbol(a);\\n    seq!(&a, repeat0(seq!(b, &a)))\\n}\\n\\npub fn seprep0(a: impl CombinatorTrait, b: impl CombinatorTrait)-> impl CombinatorTrait {\\n    opt(seprep1(a, b))\\n}\\n\\npub fn repeatn<'a>(n: usize, a: impl CombinatorTrait + 'a)-> impl CombinatorTrait {\\n    let a = symbol(a);\\n    // Choice { children: Rc::new(vecx![a; n]), greedy: false }.into()\\n    Choice { children: vec![a; n].into_iter().map(IntoDyn::into_dyn).collect(), greedy: false }\\n}\\n\\npub fn seprep1_greedy(a: impl CombinatorTrait, b: impl CombinatorTrait)-> impl CombinatorTrait {\\n    let a = symbol(a);\\n    seq!(&a, repeat0_greedy(seq!(b, &a)))\\n}\\n\\npub fn seprep0_greedy(a: impl CombinatorTrait, b: impl CombinatorTrait)-> impl CombinatorTrait {\\n    opt_greedy(seprep1_greedy(a, b))\\n}\\n\\npub fn repeatn_greedy<'a>(n: usize, a: impl CombinatorTrait + 'a)-> impl CombinatorTrait {\\n    let a = symbol(a);\\n    Choice { children: vec![a; n].into_iter().map(IntoDyn::into_dyn).collect(), greedy: true }\\n}\"}, {\"path\": \"src/_03_combinators/lookaheads/lookahead.rs\", \"tokens\": 1896, \"content\": \"\\n// src/_03_combinators/lookaheads/lookahead.rs\\nuse crate::BaseCombinatorTrait;\\nuse crate::*;\\n\\n#[derive(Debug)]\\npub struct PartialLookahead {\\n    pub parser: Box<dyn ParserTrait>,\\n    pub positive: bool,\\n}\\n\\n#[repr(transparent)]\\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\\npub struct LookaheadData {\\n    pub has_omitted_partial_lookaheads: bool,\\n}\\n\\nimpl Default for LookaheadData {\\n    fn default() -> Self {\\n        // LookaheadData { partial_lookaheads: vec![PartialLookahead { parser: Box::new(Parser::FailParser(FailParser)), positive: true }] }\\n        LookaheadData { has_omitted_partial_lookaheads: false }\\n    }\\n}\\n\\n#[derive(Debug)]\\npub struct Lookahead<T: CombinatorTrait> {\\n    pub combinator: Box<T>,\\n    pub positive: bool,\\n    pub persist_with_partial_lookahead: bool,\\n}\\n\\nimpl<T: CombinatorTrait> DynCombinatorTrait for Lookahead<T> {\\n    fn parse_dyn(&self, right_data: RightData, bytes: &[u8]) -> (Box<dyn ParserTrait + '_>, ParseResults) {\\n        let (parser, parse_results) = self.parse(right_data, bytes);\\n        (Box::new(parser), parse_results)\\n    }\\n\\n    fn one_shot_parse_dyn<'a>(&'a self, right_data: RightData, bytes: &[u8]) -> UnambiguousParseResults {\\n        self.one_shot_parse(right_data, bytes)\\n    }\\n}\\n\\nimpl<T: CombinatorTrait> CombinatorTrait for Lookahead<T> {\\n    type Parser<'a> = FailParser where Self: 'a;\\n    type Output = T::Output;\\n    type PartialOutput = T::PartialOutput;\\n\\n    fn one_shot_parse(&self, right_data: RightData, bytes: &[u8]) -> UnambiguousParseResults {\\n        let parse_result = self.combinator.one_shot_parse(right_data.clone(), bytes);\\n        if self.positive {\\n            match parse_result {\\n                Ok(_) => Ok(OneShotUpData::new(right_data)),\\n                Err(_) => parse_result,\\n            }\\n        } else {\\n            match parse_result {\\n                Ok(_) => Err(UnambiguousParseError::Fail),\\n                Err(UnambiguousParseError::Fail) => Ok(OneShotUpData::new(right_data)),\\n                Err(UnambiguousParseError::Ambiguous | UnambiguousParseError::Incomplete) => parse_result,\\n            }\\n        }\\n    }\\n    fn old_parse(&self, mut right_data: RightData, bytes: &[u8]) -> (Self::Parser<'_>, ParseResults) {\\n        let (parser, mut parse_results) = self.combinator.parse(right_data.clone(), bytes);\\n        let has_up_data = !parse_results.up_data_vec.is_empty();\\n        let succeeds = if self.positive {\\n            // A positive lookahead succeeds if it yields up_data now or it *could* yield up_data later (i.e. it's not done yet)\\n            has_up_data || !parse_results.done()\\n        } else {\\n            // A negative lookahead succeeds if it yields no up_data now\\n            !has_up_data\\n        };\\n        if succeeds {\\n            if !parse_results.done() {\\n                    right_data.get_fields1_mut().lookahead_data.has_omitted_partial_lookaheads = true;\\n            }\\n            (FailParser, ParseResults::new_single(UpData::new(right_data), true))\\n        } else {\\n            (FailParser, ParseResults::empty_finished())\\n        }\\n    }\\n}\\n\\nimpl<T: CombinatorTrait> BaseCombinatorTrait for Lookahead<T> {\\n    fn as_any(&self) -> &dyn std::any::Any where Self: 'static {\\n        self\\n    }\\n    fn apply_to_children(&self, f: &mut dyn FnMut(&dyn BaseCombinatorTrait)) {\\n        f(&self.combinator);\\n    }\\n}\\n\\npub fn lookahead(combinator: impl CombinatorTrait) -> impl CombinatorTrait {\\n    Lookahead { combinator: Box::new(Box::new(combinator)), positive: true, persist_with_partial_lookahead: false }\\n}\\n\\npub fn negative_lookahead(combinator: impl CombinatorTrait) -> impl CombinatorTrait {\\n    Lookahead { combinator: Box::new(Box::new(combinator)), positive: false, persist_with_partial_lookahead: false }\\n}\"}, {\"path\": \"src/_03_combinators/lookaheads/mod.rs\", \"tokens\": 74, \"content\": \"\\n// src/_03_combinators/lookaheads/mod.rs\\nmod lookahead;\\nmod negative_lookahead;\\n\\npub use lookahead::*;\\npub use negative_lookahead::*;\"}, {\"path\": \"src/_03_combinators/lookaheads/negative_lookahead.rs\", \"tokens\": 2672, \"content\": \"\\n// src/_03_combinators/lookaheads/negative_lookahead.rs\\nuse crate::tokenizer::finite_automata::{Expr, Regex, RegexState};\\nuse crate::BaseCombinatorTrait;\\nuse crate::*;\\n// src/combinators/negative_lookahead.rs\\nuse std::collections::HashMap;\\n\\n#[derive(Debug)]\\npub struct ExcludeBytestrings<T: CombinatorTrait> {\\n    pub(crate) inner: T,\\n    pub(crate) regex: Regex,\\n}\\n\\n#[derive(Debug)]\\npub struct ExcludeBytestringsParser<'a, T: CombinatorTrait + 'a> {\\n    pub(crate) inner: T::Parser<'a>,\\n    pub(crate) regex_state: RegexState<'a>,\\n    pub(crate) position: usize,\\n}\\n\\nimpl<T: CombinatorTrait> DynCombinatorTrait for ExcludeBytestrings<T> {\\n    fn parse_dyn(&self, right_data: RightData, bytes: &[u8]) -> (Box<dyn ParserTrait + '_>, ParseResults) {\\n        let (parser, parse_results) = self.parse(right_data, bytes);\\n        (Box::new(parser), parse_results)\\n    }\\n\\n    fn one_shot_parse_dyn<'a>(&'a self, right_data: RightData, bytes: &[u8]) -> UnambiguousParseResults {\\n        self.one_shot_parse(right_data, bytes)\\n    }\\n}\\n\\nimpl<T: CombinatorTrait> CombinatorTrait for ExcludeBytestrings<T> {\\n    type Parser<'a> = ExcludeBytestringsParser<'a, T> where T: 'a;\\n    type Output = T::Output;\\n    type PartialOutput = T::PartialOutput;\\n\\n    fn one_shot_parse(&self, right_data: RightData, bytes: &[u8]) -> UnambiguousParseResults {\\n        let start_position = right_data.get_fields1().position;\\n        match self.inner.one_shot_parse(right_data, bytes) {\\n            Ok(one_shot_up_data) => {\\n                let end_position = one_shot_up_data.get_fields1().position;\\n                let mut regex_state = self.regex.init();\\n                regex_state.execute(&bytes[..(end_position - start_position)]);\\n                if regex_state.fully_matches_here() {\\n                    return Err(UnambiguousParseError::Fail);\\n                } else {\\n                    Ok(one_shot_up_data)\\n                }\\n            },\\n            Err(err) => Err(err),\\n        }\\n    }\\n\\n    fn old_parse(&self, right_data: RightData, bytes: &[u8]) -> (Self::Parser<'_>, ParseResults) {\\n        let (inner, mut parse_results) = self.inner.parse(right_data.clone(), bytes);\\n        let mut regex_state = self.regex.init();\\n        let start_position = right_data.get_fields1().position;\\n\\n        // Optimized logic\\n        let mut end_offsets_to_match = HashMap::new();\\n        let mut end_offsets = Vec::new();\\n        for up_data in &parse_results.up_data_vec {\\n            let end_offset = up_data.get_fields1().position - start_position;\\n            end_offsets_to_match.insert(end_offset, false);\\n            end_offsets.push(end_offset);\\n        }\\n        end_offsets.sort();\\n\\n        let mut offset = 0;\\n        for end_offset in end_offsets {\\n            let slice = &bytes[offset..end_offset];\\n            regex_state.execute(slice);\\n            if regex_state.definitely_fully_matches() {\\n                end_offsets_to_match.insert(end_offset, true);\\n            }\\n            offset = end_offset;\\n        }\\n\\n        // Run the regex to the end of the input\\n        regex_state.execute(&bytes[offset..]);\\n\\n        parse_results.up_data_vec.retain(|up_data| {\\n            let position = up_data.get_fields1().position - start_position;\\n            !end_offsets_to_match[&position]\\n        });\\n\\n        (ExcludeBytestringsParser {\\n            inner,\\n            regex_state,\\n            position: start_position + bytes.len(),\\n        }, parse_results)\\n    }\\n}\\n\\nimpl<T: CombinatorTrait> BaseCombinatorTrait for ExcludeBytestrings<T> {\\n    fn as_any(&self) -> &dyn std::any::Any where Self: 'static {\\n        self\\n    }\\n\\n    fn apply_to_children(&self, f: &mut dyn FnMut(&dyn BaseCombinatorTrait)) {\\n        f(&self.inner);\\n    }\\n}\\n\\nimpl<T: CombinatorTrait> ParserTrait for ExcludeBytestringsParser<'_, T> {\\n    fn get_u8set(&self) -> U8Set {\\n        self.inner.get_u8set()\\n    }\\n\\n    fn parse(&mut self, bytes: &[u8]) -> ParseResults {\\n        let mut parse_results = self.inner.parse(bytes);\\n\\n        // Optimized logic\\n        let mut end_offsets_to_match = HashMap::new();\\n        let mut end_offsets = Vec::new();\\n        for up_data in &parse_results.up_data_vec {\\n            let end_offset = up_data.get_fields1().position - self.position;\\n            end_offsets_to_match.insert(end_offset, false);\\n            end_offsets.push(end_offset);\\n        }\\n        end_offsets.sort();\\n\\n        let mut current_offset = 0;\\n        for end_offset in end_offsets {\\n            let slice = &bytes[current_offset..end_offset];\\n            self.regex_state.execute(slice);\\n            if self.regex_state.fully_matches_here() {\\n                end_offsets_to_match.insert(end_offset, true);\\n            }\\n            current_offset = end_offset;\\n        }\\n\\n        // Run the regex to the end of the input\\n        self.regex_state.execute(&bytes[current_offset..]);\\n\\n        parse_results.up_data_vec.retain(|up_data| {\\n            let position = up_data.get_fields1().position - self.position;\\n            !end_offsets_to_match[&position]\\n        });\\n\\n        self.position += bytes.len();\\n        parse_results\\n    }\\n}\\n\\npub fn exclude_strings<T: IntoCombinator + 'static>(inner: T, bytestrings_to_exclude: Vec<&str>)-> impl CombinatorTrait {\\n    let bytestrings_to_exclude: Vec<Vec<u8>> = bytestrings_to_exclude.iter().map(|s| s.as_bytes().to_vec()).collect();\\n    let expr = Expr::Choice(bytestrings_to_exclude.into_iter().map(|bytes| Expr::U8Seq(bytes)).collect());\\n    let regex = expr.build();\\n\\n    ExcludeBytestrings {\\n        inner: inner.into_combinator(),\\n        regex,\\n    }\\n}\"}, {\"path\": \"src/_03_combinators/mod.rs\", \"tokens\": 130, \"content\": \"\\n// src/_03_combinators/mod.rs\\nmod cache;\\nmod core;\\nmod derived;\\nmod lookaheads;\\nmod nullable;\\nmod wrappers;\\nmod unicode;\\n\\npub use cache::*;\\npub use core::*;\\npub use derived::*;\\n\\npub use lookaheads::*;\\npub use nullable::*;\\npub use unicode::*;\\npub use wrappers::*;\"}, {\"path\": \"src/_03_combinators/nullable/check_right_data.rs\", \"tokens\": 2464, \"content\": \"\\n// src/_03_combinators/nullable/check_right_data.rs\\n// src/combinators/check_right_data.rs\\nuse crate::{BaseCombinatorTrait, DynCombinatorTrait, ParserTrait, UnambiguousParseError, UnambiguousParseResults, RightData, UpData, OneShotUpData};\\nuse crate::{CombinatorTrait, FailParser, ParseResultTrait, ParseResults, RightDataGetters};\\nuse std::fmt::Debug;\\nuse std::hash::{Hash, Hasher};\\n\\npub struct CheckRightData {\\n    pub(crate) run: Box<dyn Fn(&RightData) -> bool>,\\n}\\n\\nimpl Hash for CheckRightData {\\n    fn hash<H: Hasher>(&self, state: &mut H) {\\n        let ptr = std::ptr::addr_of!(self.run) as *const ();\\n        ptr.hash(state);\\n    }\\n}\\n\\nimpl PartialEq for CheckRightData {\\n    fn eq(&self, other: &Self) -> bool {\\n        std::ptr::eq(&self.run, &other.run)\\n    }\\n}\\n\\nimpl Eq for CheckRightData {}\\n\\nimpl Debug for CheckRightData {\\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\\n        f.debug_struct(\\\"CheckRightData\\\").finish()\\n    }\\n}\\n\\nimpl DynCombinatorTrait for CheckRightData {\\n    fn parse_dyn(&self, right_data: RightData, bytes: &[u8]) -> (Box<dyn ParserTrait + '_>, ParseResults) {\\n        let (parser, parse_results) = self.parse(right_data, bytes);\\n        (Box::new(parser), parse_results)\\n    }\\n\\n    fn one_shot_parse_dyn<'a>(&'a self, right_data: RightData, bytes: &[u8]) -> UnambiguousParseResults {\\n        self.one_shot_parse(right_data, bytes)\\n    }\\n}\\n\\nimpl CombinatorTrait for CheckRightData {\\n    type Parser<'a> = FailParser;\\n    type Output = ();\\n    type PartialOutput = ();\\n\\n    fn one_shot_parse(&self, right_data: RightData, bytes: &[u8]) -> UnambiguousParseResults {\\n        if (self.run)(&right_data.clone()) {\\n            Ok(OneShotUpData::new(right_data))\\n        } else {\\n            Err(UnambiguousParseError::Fail)\\n        }\\n    }\\n\\n    fn old_parse(&self, right_data: RightData, bytes: &[u8]) -> (Self::Parser<'_>, ParseResults) {\\n        if (self.run)(&right_data.clone()) {\\n            (FailParser, ParseResults::new_single(UpData::new(right_data), true))\\n        } else {\\n            (FailParser, ParseResults::empty_finished())\\n        }\\n    }\\n}\\n\\nimpl BaseCombinatorTrait for CheckRightData {\\n    fn as_any(&self) -> &dyn std::any::Any where Self: 'static {\\n        self\\n    }\\n}\\n\\npub fn check_right_data(run: impl Fn(&RightData) -> bool + 'static) -> CheckRightData {\\n    CheckRightData { run: Box::new(run) }\\n}\\n\\npub struct MutateRightData {\\n    pub(crate) run: Box<dyn Fn(&mut RightData) -> bool>,\\n}\\n\\nimpl Hash for MutateRightData {\\n    fn hash<H: Hasher>(&self, state: &mut H) {\\n        let ptr = std::ptr::addr_of!(self.run) as *const ();\\n        std::ptr::hash(ptr, state);\\n    }\\n}\\n\\nimpl PartialEq for MutateRightData {\\n    fn eq(&self, other: &Self) -> bool {\\n        std::ptr::eq(&self.run, &other.run)\\n    }\\n}\\n\\nimpl Eq for MutateRightData {}\\n\\nimpl Debug for MutateRightData {\\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\\n        f.debug_struct(\\\"MutateRightData\\\").finish()\\n    }\\n}\\n\\nimpl DynCombinatorTrait for MutateRightData {\\n    fn parse_dyn(&self, right_data: RightData, bytes: &[u8]) -> (Box<dyn ParserTrait + '_>, ParseResults) {\\n        let (parser, parse_results) = self.parse(right_data, bytes);\\n        (Box::new(parser), parse_results)\\n    }\\n\\n    fn one_shot_parse_dyn<'a>(&'a self, right_data: RightData, bytes: &[u8]) -> UnambiguousParseResults {\\n        self.one_shot_parse(right_data, bytes)\\n    }\\n}\\n\\nimpl CombinatorTrait for MutateRightData {\\n    type Parser<'a> = FailParser;\\n    type Output = ();\\n    type PartialOutput = ();\\n\\n    fn one_shot_parse(&self, right_data: RightData, bytes: &[u8]) -> UnambiguousParseResults {\\n        let mut right_data = right_data;\\n        if (self.run)(&mut right_data) {\\n            Ok(OneShotUpData::new(right_data))\\n        } else {\\n            Err(UnambiguousParseError::Fail)\\n        }\\n    }\\n    fn old_parse(&self, right_data: RightData, bytes: &[u8]) -> (Self::Parser<'_>, ParseResults) {\\n        let mut right_data = right_data;\\n        if (self.run)(&mut right_data) {\\n            (FailParser, ParseResults::new_single(UpData::new(right_data), true))\\n        } else {\\n            (FailParser, ParseResults::empty_finished())\\n        }\\n    }\\n}\\n\\nimpl BaseCombinatorTrait for MutateRightData {\\n    fn as_any(&self) -> &dyn std::any::Any where Self: 'static {\\n        self\\n    }\\n}\\n\\npub fn mutate_right_data(run: impl Fn(&mut RightData) -> bool + 'static) -> MutateRightData {\\n    MutateRightData { run: Box::new(run) }\\n}\"}, {\"path\": \"src/_03_combinators/nullable/eps_and_fail.rs\", \"tokens\": 1666, \"content\": \"\\n// src/_03_combinators/nullable/eps_and_fail.rs\\nuse crate::_01_parse_state::{ParseResultTrait, RightData, RightDataGetters, UpData, OneShotUpData};\\nuse crate::{BaseCombinatorTrait, DynCombinatorTrait, UnambiguousParseError, UnambiguousParseResults};\\nuse crate::{CombinatorTrait, ParseResults, ParserTrait, U8Set};\\n#[derive(Debug)]\\npub struct Eps;\\n\\n#[derive(Debug)]\\npub struct EpsParser;\\n\\nimpl DynCombinatorTrait for Eps {\\n    fn parse_dyn(&self, right_data: RightData, bytes: &[u8]) -> (Box<dyn ParserTrait + '_>, ParseResults) {\\n        let (parser, parse_results) = self.parse(right_data, bytes);\\n        (Box::new(parser), parse_results)\\n    }\\n\\n    fn one_shot_parse_dyn<'a>(&'a self, right_data: RightData, bytes: &[u8]) -> UnambiguousParseResults {\\n        self.one_shot_parse(right_data, bytes)\\n    }\\n}\\n\\nimpl CombinatorTrait for Eps {\\n    type Parser<'a> = EpsParser;\\n    type Output = ();\\n    type PartialOutput = ();\\n\\n    fn one_shot_parse(&self, right_data: RightData, bytes: &[u8]) -> UnambiguousParseResults {\\n        Ok(OneShotUpData::new(right_data))\\n    }\\n\\n    fn old_parse(&self, right_data: RightData, bytes: &[u8]) -> (Self::Parser<'_>, ParseResults) {\\n        (EpsParser, ParseResults::new_single(UpData::new(right_data), true))\\n    }\\n}\\n\\nimpl BaseCombinatorTrait for Eps {\\n    fn as_any(&self) -> &dyn std::any::Any where Self: 'static {\\n        self\\n    }\\n}\\n\\nimpl ParserTrait for EpsParser {\\n    fn get_u8set(&self) -> U8Set {\\n        panic!(\\\"EpsParser.get_u8set() called\\\")\\n    }\\n\\n    fn parse(&mut self, bytes: &[u8]) -> ParseResults {\\n        panic!(\\\"EpsParser already consumed\\\")\\n    }\\n}\\n\\npub fn eps() -> Eps {\\n    Eps\\n}\\n\\n\\n    \\n#[repr(transparent)]\\n#[derive(Debug)]\\npub struct FailParser;\\n\\n#[derive(Debug)]\\npub struct Fail;\\n\\nimpl DynCombinatorTrait for Fail {\\n    fn parse_dyn(&self, right_data: RightData, bytes: &[u8]) -> (Box<dyn ParserTrait + '_>, ParseResults) {\\n        let (parser, parse_results) = self.parse(right_data, bytes);\\n        (Box::new(parser), parse_results)\\n    }\\n\\n    fn one_shot_parse_dyn<'a>(&'a self, right_data: RightData, bytes: &[u8]) -> UnambiguousParseResults {\\n        self.one_shot_parse(right_data, bytes)\\n    }\\n}\\n\\nimpl CombinatorTrait for Fail {\\n    type Parser<'a> = FailParser;\\n    type Output = ();\\n    type PartialOutput = ();\\n\\n    fn one_shot_parse(&self, right_data: RightData, bytes: &[u8]) -> UnambiguousParseResults {\\n        Err(UnambiguousParseError::Fail)\\n    }\\n\\n    fn old_parse(&self, right_data: RightData, bytes: &[u8]) -> (Self::Parser<'_>, ParseResults) {\\n        (FailParser, ParseResults::empty_finished())\\n    }\\n}\\n\\nimpl BaseCombinatorTrait for Fail {\\n    fn as_any(&self) -> &dyn std::any::Any where Self: 'static {\\n        self\\n    }\\n}\\n\\nimpl ParserTrait for FailParser {\\n    fn get_u8set(&self) -> U8Set {\\n        panic!(\\\"FailParser.get_u8set() called\\\")\\n    }\\n\\n    fn parse(&mut self, bytes: &[u8]) -> ParseResults {\\n        panic!(\\\"FailParser already consumed\\\")\\n    }\\n}\\n\\npub fn fail() -> Fail {\\n    Fail\\n}\"}, {\"path\": \"src/_03_combinators/nullable/forbid_follows.rs\", \"tokens\": 2662, \"content\": \"\\n// src/_03_combinators/nullable/forbid_follows.rs\\nuse crate::BaseCombinatorTrait;\\nuse crate::*;\\n\\n#[repr(transparent)]\\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Ord, PartialOrd, Default)]\\npub struct ForbidFollowsData {\\n    pub prev_match_ids: u16, // Using a bitset\\n}\\n\\n#[derive(Debug)]\\npub struct ForbidFollows {\\n    pub(crate) match_ids: u16, // Using a bitset\\n}\\n\\n#[derive(Debug)]\\npub struct ForbidFollowsClear {}\\n\\n#[derive(Debug)]\\npub struct ForbidFollowsCheckNot {\\n    pub(crate) match_ids: u16,\\n}\\n\\nimpl DynCombinatorTrait for ForbidFollows {\\n    fn parse_dyn(&self, right_data: RightData, bytes: &[u8]) -> (Box<dyn ParserTrait + '_>, ParseResults) {\\n        let (parser, parse_results) = self.parse(right_data, bytes);\\n        (Box::new(parser), parse_results)\\n    }\\n\\n    fn one_shot_parse_dyn<'a>(&'a self, right_data: RightData, bytes: &[u8]) -> UnambiguousParseResults {\\n        self.one_shot_parse(right_data, bytes)\\n    }\\n}\\n\\nimpl CombinatorTrait for ForbidFollows {\\n    type Parser<'a> = FailParser;\\n    type Output = ();\\n    type PartialOutput = ();\\n\\n    fn one_shot_parse(&self, right_data: RightData, bytes: &[u8]) -> UnambiguousParseResults {\\n        let mut right_data = right_data;\\n        right_data.get_inner_mut().get_fields1_mut().forbidden_consecutive_matches.prev_match_ids = self.match_ids;\\n        Ok(OneShotUpData::new(right_data))\\n    }\\n    fn old_parse(&self, right_data: RightData, bytes: &[u8]) -> (Self::Parser<'_>, ParseResults) {\\n        let mut right_data = right_data;\\n        right_data.get_inner_mut().get_fields1_mut().forbidden_consecutive_matches.prev_match_ids = self.match_ids;\\n        (FailParser, ParseResults::new_single(UpData::new(right_data), true))\\n    }\\n}\\n\\nimpl BaseCombinatorTrait for ForbidFollows {\\n    fn as_any(&self) -> &dyn std::any::Any where Self: 'static {\\n        self\\n    }\\n}\\n\\nimpl DynCombinatorTrait for ForbidFollowsClear {\\n    fn parse_dyn(&self, right_data: RightData, bytes: &[u8]) -> (Box<dyn ParserTrait + '_>, ParseResults) {\\n        let (parser, parse_results) = self.parse(right_data, bytes);\\n        (Box::new(parser), parse_results)\\n    }\\n\\n    fn one_shot_parse_dyn<'a>(&'a self, right_data: RightData, bytes: &[u8]) -> UnambiguousParseResults {\\n        self.one_shot_parse(right_data, bytes)\\n    }\\n}\\n\\nimpl CombinatorTrait for ForbidFollowsClear {\\n    type Parser<'a> = FailParser;\\n    type Output = ();\\n    type PartialOutput = ();\\n\\n    fn one_shot_parse(&self, right_data: RightData, bytes: &[u8]) -> UnambiguousParseResults {\\n        Ok(OneShotUpData::new(right_data))\\n    }\\n    fn old_parse(&self, right_data: RightData, bytes: &[u8]) -> (Self::Parser<'_>, ParseResults) {\\n        let mut right_data = right_data;\\n        right_data.get_inner_mut().get_fields1_mut().forbidden_consecutive_matches.prev_match_ids = 0;\\n        (FailParser, ParseResults::new_single(UpData::new(right_data), true))\\n    }\\n}\\n\\nimpl BaseCombinatorTrait for ForbidFollowsClear {\\n    fn as_any(&self) -> &dyn std::any::Any where Self: 'static {\\n        self\\n    }\\n}\\n\\nimpl DynCombinatorTrait for ForbidFollowsCheckNot {\\n    fn parse_dyn(&self, right_data: RightData, bytes: &[u8]) -> (Box<dyn ParserTrait + '_>, ParseResults) {\\n        let (parser, parse_results) = self.parse(right_data, bytes);\\n        (Box::new(parser), parse_results)\\n    }\\n\\n    fn one_shot_parse_dyn<'a>(&'a self, right_data: RightData, bytes: &[u8]) -> UnambiguousParseResults {\\n        self.one_shot_parse(right_data, bytes)\\n    }\\n}\\n\\nimpl CombinatorTrait for ForbidFollowsCheckNot {\\n    type Parser<'a> = FailParser;\\n    type Output = ();\\n    type PartialOutput = ();\\n\\n    fn one_shot_parse(&self, right_data: RightData, bytes: &[u8]) -> UnambiguousParseResults {\\n        Ok(OneShotUpData::new(right_data))\\n    }\\n    fn old_parse(&self, right_data: RightData, bytes: &[u8]) -> (Self::Parser<'_>, ParseResults) {\\n        let mut right_data = right_data;\\n        if right_data.get_fields1().forbidden_consecutive_matches.prev_match_ids & self.match_ids != 0 {\\n            (FailParser, ParseResults::empty_finished())\\n        } else {\\n            right_data.get_inner_mut().get_fields1_mut().forbidden_consecutive_matches.prev_match_ids = 0;\\n            (FailParser, ParseResults::new_single(UpData::new(right_data), true))\\n        }\\n    }\\n}\\n\\nimpl BaseCombinatorTrait for ForbidFollowsCheckNot {\\n    fn as_any(&self) -> &dyn std::any::Any where Self: 'static {\\n        self\\n    }\\n}\\n\\npub fn forbid_follows(match_ids: &[usize]) -> ForbidFollows { // Using a bitset\\n    let mut bitset = 0;\\n    for &id in match_ids {\\n        bitset |= 1 << TryInto::<u16>::try_into(id).unwrap();\\n    }\\n    ForbidFollows { match_ids: bitset }\\n}\\n\\npub fn forbid_follows_clear() -> ForbidFollowsClear {\\n    ForbidFollowsClear {}\\n}\\n\\npub fn forbid_follows_check_not(match_id: usize) -> ForbidFollowsCheckNot {\\n    let bitmask = 1 << match_id;\\n    ForbidFollowsCheckNot { match_ids: bitmask }\\n}\"}, {\"path\": \"src/_03_combinators/nullable/mod.rs\", \"tokens\": 94, \"content\": \"\\n// src/_03_combinators/nullable/mod.rs\\nmod check_right_data;\\nmod eps_and_fail;\\nmod forbid_follows;\\n\\npub use check_right_data::*;\\npub use eps_and_fail::*;\\npub use forbid_follows::*;\"}, {\"path\": \"src/_03_combinators/unicode.rs\", \"tokens\": 378, \"content\": \"\\n// src/_03_combinators/unicode.rs\\nuse crate::unicode_categories::{char_ranges_in_general_category, GeneralCategory};\\nuse crate::*;\\n\\npub fn get_unicode_general_category_bytestrings(general_category: GeneralCategory) -> Vec<Vec<u8>> {\\n    let mut result = Vec::new();\\n\\n    for (start, end) in char_ranges_in_general_category(general_category).iter().cloned() {\\n        for c in start..=end {\\n            let byte_len = c.len_utf8();\\n            let mut bytes = vec![0; byte_len];\\n            c.encode_utf8(&mut bytes);\\n            result.push(bytes.to_vec());\\n        }\\n    }\\n\\n    result\\n}\\n\\npub fn get_unicode_general_category_combinator(general_category: GeneralCategory)-> impl CombinatorTrait {\\n    let bytestrings = get_unicode_general_category_bytestrings(general_category);\\n    eat_bytestring_choice(bytestrings)\\n}\"}, {\"path\": \"src/_03_combinators/wrappers/deferred.rs\", \"tokens\": 3520, \"content\": \"\\n// src/_03_combinators/wrappers/deferred.rs\\nuse crate::BaseCombinatorTrait;\\nuse crate::*;\\nuse once_cell::unsync::OnceCell;\\n// src/combinators/deferred.rs\\n// src/combinators/deferred.rs\\nuse std::any::{Any, TypeId};\\nuse std::cell::RefCell;\\nuse std::collections::HashMap;\\nuse std::collections::HashSet;\\nuse std::fmt::{Debug, Formatter};\\nuse std::hash::{Hash, Hasher};\\nuse std::panic::Location;\\n\\nthread_local! {\\n    static DEFERRED_CACHE: RefCell<HashMap<CacheKey, CacheEntry>> = RefCell::new(HashMap::new());\\n}\\n\\n#[derive(Debug)]\\npub struct Deferred<'a, T: CombinatorTrait> {\\n    deferred_fn: Box<dyn DeferredFnTrait<T> + 'a>,\\n    inner: OnceCell<T>,\\n}\\n\\nstruct DeferredFn<T: CombinatorTrait, F: Fn() -> T> {\\n    pub f: F,\\n    pub key: CacheKey,\\n}\\n\\nimpl<T: CombinatorTrait + Clone, F: Fn() -> T> Debug for DeferredFn<T, F> {\\n    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {\\n        f.debug_tuple(\\\"DeferredFn\\\").field(&self.key).finish()\\n    }\\n}\\n\\n// todo: this trait is really messy. Any way to clean it up?\\n// Trait for evaluating the deferred function\\ntrait DeferredFnTrait<T: CombinatorTrait>: Debug {\\n    // todo: the fact that\\n    // we need this struct right now is dumb. Aim to remove it. But we don't want to have to return a (bool, T) tuple - that's even worse and it's what we're trying to avoid by using the struct.\\n    fn evaluate_to_combinator(&self) -> EvaluateToCombinatorResult<T>;\\n    fn get_addr(&self) -> usize;\\n}\\n\\nstruct EvaluateToCombinatorResult<T> {\\n    combinator: T,\\n    cache_hit: bool,\\n}\\n\\n#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\\nstruct CacheKey {\\n    addr: usize,\\n    // TODO: it really seems wrong to use TypeId here. It works fine with just addr when we use opt level 0.\\n    //  But at opt level 2, we get a collision between two keys with the same address but different typeids.\\n    //  Obviously something weird is going on with function pointers that I don't quite understand.\\n    type_id: TypeId,\\n}\\n\\n// CacheEntry struct to hold the CombinatorTrait and caller locations\\n#[derive(Debug)]\\nstruct CacheEntry {\\n    value: Box<dyn DynCombinatorTrait>,\\n    caller_locations: RefCell<HashSet<String>>,\\n}\\n\\nimpl<T: CombinatorTrait + Clone + 'static, F: Fn() -> T> DeferredFnTrait<T> for DeferredFn<T, F> {\\n    fn evaluate_to_combinator(&self) -> EvaluateToCombinatorResult<T> {\\n        DEFERRED_CACHE.with(|cache| {\\n            if cache.borrow().contains_key(&self.key) {\\n                count_hit!(\\\"deferred cache hit\\\");\\n                let borrowed = cache.borrow();\\n                let entry = borrowed.get(&self.key).unwrap();\\n                if let Some(value) = entry.value.as_any().downcast_ref::<T>() {\\n                    return EvaluateToCombinatorResult {\\n                        combinator: value.clone(),\\n                        cache_hit: true,\\n                    };\\n                } else {\\n                    // Richer error printing\\n                    eprintln!(\\\"Deferred Cache: {:#?}\\\", borrowed);\\n                    eprintln!(\\\"Key: {:?}\\\", self.key);\\n                    eprintln!(\\\"Conflicting Entry: {:?}\\\", entry);\\n                    eprintln!(\\\"Existing Type Name: {:?}\\\", BaseCombinatorTrait::type_name(&entry.value));\\n                    eprintln!(\\\"Expected Type Name: {}\\\", std::any::type_name::<T>());\\n                    panic!(\\\"Expected value at address {} to be of typeid {:?}, but it had typeid {:?}\\\", self.key.addr, TypeId::of::<T>(), entry.value.as_any().type_id());\\n                }\\n            } else {\\n                count_hit!(\\\"deferred cache miss\\\");\\n                let value = (self.f)();\\n                cache.borrow_mut().insert(self.key, CacheEntry {\\n                    value: Box::new(value.clone()),\\n                    caller_locations: RefCell::new(HashSet::new()),\\n                });\\n                return EvaluateToCombinatorResult {\\n                    combinator: value,\\n                    cache_hit: false,\\n                };\\n            }\\n        })\\n    }\\n    fn get_addr(&self) -> usize {\\n        self.key.addr\\n    }\\n}\\n\\nimpl<T: CombinatorTrait> PartialEq for Deferred<'_, T> {\\n    fn eq(&self, other: &Self) -> bool {\\n        std::ptr::eq(&self.deferred_fn, &other.deferred_fn)\\n    }\\n}\\n\\nimpl<T: CombinatorTrait> Eq for Deferred<'_, T> {}\\n\\nimpl<T: CombinatorTrait> Hash for Deferred<'_, T> {\\n    fn hash<H: Hasher>(&self, state: &mut H) {\\n        std::ptr::hash(&self.deferred_fn, state);\\n    }\\n}\\n\\nimpl<T: CombinatorTrait> DynCombinatorTrait for Deferred<'_, T> {\\n    fn parse_dyn<'a>(&'a self, right_data: RightData, bytes: &[u8]) -> (Box<dyn ParserTrait + 'a>, ParseResults) {\\n        let (parser, parse_results) = self.parse(right_data, bytes);\\n        (Box::new(parser), parse_results)\\n    }\\n\\n    fn one_shot_parse_dyn<'a>(&'a self, right_data: RightData, bytes: &[u8]) -> UnambiguousParseResults {\\n        self.one_shot_parse(right_data, bytes)\\n    }\\n}\\n\\nimpl<T: CombinatorTrait> CombinatorTrait for Deferred<'_, T> {\\n    type Parser<'a> = T::Parser<'a> where Self: 'a;\\n    type Output = T::Output;\\n    type PartialOutput = T::PartialOutput;\\n\\n    fn one_shot_parse(&self, right_data: RightData, bytes: &[u8]) -> UnambiguousParseResults {\\n        let combinator = self.inner.get().expect(\\\"inner combinator not initialized\\\");\\n        combinator.one_shot_parse(right_data, bytes)\\n    }\\n\\n    fn old_parse(&self, right_data: RightData, bytes: &[u8]) -> (Self::Parser<'_>, ParseResults) {\\n        // let combinator = self.inner.get_or_init(|| self.deferred_fn.evaluate_to_combinator());\\n        let combinator = self.inner.get().expect(\\\"inner combinator not initialized\\\");\\n        combinator.parse(right_data, bytes)\\n    }\\n}\\n\\nimpl<T: CombinatorTrait> BaseCombinatorTrait for Deferred<'_, T> {\\n    fn as_any(&self) -> &dyn Any where Self: 'static {\\n        self\\n    }\\n    fn apply_to_children(&self, f: &mut dyn FnMut(&dyn BaseCombinatorTrait)) {\\n        f(self.inner.get_or_init(|| self.deferred_fn.evaluate_to_combinator().combinator))\\n    }\\n    fn compile_inner(&self) {\\n        // Force evaluation and compilation of the inner combinator\\n        let _ = self.inner.get_or_init(|| {\\n            let result = self.deferred_fn.evaluate_to_combinator();\\n            if !result.cache_hit {\\n                result.combinator.compile_inner();\\n            }\\n            result.combinator\\n        });\\n    }\\n}\\n\\n// Public function for creating a Deferred combinator\\n#[track_caller]\\npub fn deferred<T: CombinatorTrait + 'static>(f: fn() -> T) -> Deferred<'static, StrongRef<T>> {\\n    let addr = f as *const () as usize;\\n    let location = Location::caller();\\n    let caller_location_str = location.to_string();\\n    let key = CacheKey {\\n        addr,\\n        type_id: TypeId::of::<T>(),\\n    };\\n    DEFERRED_CACHE.with(|cache| {\\n        let mut cache = cache.borrow_mut();\\n        if let Some(entry) = cache.get_mut(&key) {\\n            entry.caller_locations.borrow_mut().insert(caller_location_str);\\n        }\\n    });\\n    let f = move || StrongRef::new(f());\\n    Deferred {\\n        deferred_fn: Box::new(DeferredFn {\\n            f,\\n            key\\n        }),\\n        inner: OnceCell::new(),\\n    }\\n}\"}, {\"path\": \"src/_03_combinators/wrappers/dyn_parser.rs\", \"tokens\": 890, \"content\": \"\\n// src/_03_combinators/wrappers/dyn_parser.rs\\nuse crate::*;\\nuse std::any::Any;\\n\\n#[derive(Debug)]\\npub struct DynCombinator<C: CombinatorTrait> {\\n    combinator: C,\\n}\\n\\nimpl<C: CombinatorTrait> BaseCombinatorTrait for DynCombinator<C> {\\n    fn as_any(&self) -> &dyn Any where Self: 'static {\\n        self\\n    }\\n}\\n\\nimpl<C: CombinatorTrait> DynCombinatorTrait for DynCombinator<C> {\\n    fn parse_dyn(&self, right_data: RightData, bytes: &[u8]) -> (Box<dyn ParserTrait + '_>, ParseResults) {\\n        let (parser, parse_results) = self.parse(right_data, bytes);\\n        (Box::new(parser), parse_results)\\n    }\\n\\n    fn one_shot_parse_dyn<'a>(&'a self, right_data: RightData, bytes: &[u8]) -> UnambiguousParseResults {\\n        self.one_shot_parse(right_data, bytes)\\n    }\\n}\\n\\nimpl<C: CombinatorTrait> CombinatorTrait for DynCombinator<C> {\\n    type Parser<'a> = Box<dyn ParserTrait + 'a> where Self: 'a;\\n    type Output = C::Output;\\n    type PartialOutput = C::PartialOutput;\\n\\n    fn one_shot_parse(&self, right_data: RightData, bytes: &[u8]) -> UnambiguousParseResults {\\n        self.combinator.one_shot_parse(right_data, bytes)\\n    }\\n\\n    fn old_parse(&self, right_data: RightData, bytes: &[u8]) -> (Self::Parser<'_>, ParseResults) {\\n        let (parser, parse_results) = self.combinator.old_parse(right_data, bytes);\\n        (Box::new(parser), parse_results)\\n    }\\n}\\n\\npub fn dyn_combinator<'a, C: CombinatorTrait + 'a>(combinator: C) -> Box<dyn DynCombinatorTrait + 'a> {\\n    Box::new(DynCombinator { combinator })\\n}\"}, {\"path\": \"src/_03_combinators/wrappers/mod.rs\", \"tokens\": 118, \"content\": \"\\n// src/_03_combinators/wrappers/mod.rs\\nmod deferred;\\nmod dyn_parser;\\nmod profile;\\nmod reference;\\nmod symbol;\\nmod tag;\\n\\npub use deferred::*;\\npub use dyn_parser::*;\\npub use profile::*;\\npub use reference::*;\\npub use symbol::*;\\npub use tag::*;\"}, {\"path\": \"src/_03_combinators/wrappers/profile.rs\", \"tokens\": 2574, \"content\": \"use crate::BaseCombinatorTrait;\\nuse crate::*;\\nuse derivative::Derivative;\\nuse std::collections::HashMap;\\nuse std::sync::Mutex;\\nuse std::time::{Duration, Instant};\\n\\nlazy_static::lazy_static! {\\n    pub static ref GLOBAL_PROFILE_DATA: Mutex<ProfileDataInner> = Mutex::new(ProfileDataInner::default());\\n}\\n\\npub struct ProfileDataInner {\\n    pub(crate) timings: HashMap<String, Duration>,\\n    pub(crate) hit_counts: HashMap<String, usize>,\\n    tag_stack: Vec<String>,\\n    start_time: Instant,\\n}\\n\\nimpl Default for ProfileDataInner {\\n    fn default() -> Self {\\n        Self {\\n            timings: HashMap::new(),\\n            hit_counts: HashMap::new(),\\n            tag_stack: vec![\\\"root\\\".to_string()],\\n            start_time: Instant::now(),\\n        }\\n    }\\n}\\n\\nimpl ProfileDataInner {\\n    pub fn push_tag(tag: String) {\\n        let now = Instant::now();\\n        let mut profile_data = GLOBAL_PROFILE_DATA.lock().unwrap();\\n        let elapsed = now.duration_since(profile_data.start_time);\\n        if let Some(current_tag) = profile_data.tag_stack.last().cloned() {\\n            *profile_data.timings.entry(current_tag.clone()).or_default() += elapsed;\\n            *profile_data.hit_counts.entry(current_tag).or_default() += 1;\\n        }\\n        profile_data.tag_stack.push(tag);\\n        profile_data.start_time = Instant::now();\\n    }\\n\\n    pub fn pop_tag() {\\n        let now = Instant::now();\\n        let mut profile_data = GLOBAL_PROFILE_DATA.lock().unwrap();\\n        if let Some(tag) = profile_data.tag_stack.pop() {\\n            let elapsed = now.duration_since(profile_data.start_time);\\n            *profile_data.timings.entry(tag.clone()).or_default() += elapsed;\\n            *profile_data.hit_counts.entry(tag).or_default() += 1;\\n        }\\n        profile_data.start_time = Instant::now();\\n    }\\n\\n    pub fn count_hit(tag: String) {\\n        let mut profile_data = GLOBAL_PROFILE_DATA.lock().unwrap();\\n        *profile_data.hit_counts.entry(tag).or_default() += 1;\\n    }\\n}\\n\\npub fn clear_profile_data() {\\n    let mut profile_data = GLOBAL_PROFILE_DATA.lock().unwrap();\\n    profile_data.timings.clear();\\n    profile_data.hit_counts.clear();\\n    profile_data.tag_stack.clear();\\n    profile_data.start_time = Instant::now();\\n}\\n\\n#[macro_export]\\nmacro_rules! profile {\\n    ($tag:expr, $body:expr) => {{\\n        // $crate::ProfileDataInner::push_tag($tag.to_string());\\n        // let result = $body;\\n        // $crate::ProfileDataInner::pop_tag();\\n        // result\\n        $body\\n    }};\\n}\\n\\n#[macro_export]\\nmacro_rules! profile_block {\\n    ($body:expr) => {{\\n        // $crate::ProfileDataInner::push_tag(format!(\\\"{}:{}\\\", file!(), line!()));\\n        // let result = $body;\\n        // $crate::ProfileDataInner::pop_tag();\\n        // result\\n        $body\\n    }};\\n}\\n\\n#[macro_export]\\nmacro_rules! count_hit {\\n    ($tag:expr) => {\\n        // $crate::ProfileDataInner::count_hit($tag.to_string());\\n    };\\n}\\n\\n#[derive(Debug)]\\npub struct Profiled<T> {\\n    pub inner: T,\\n    pub tag: String,\\n}\\n\\n#[derive(Derivative)]\\n#[derivative(Debug)]\\npub struct ProfiledParser<P: ParserTrait> {\\n    pub inner: P,\\n    pub tag: String,\\n}\\n\\nimpl<T: CombinatorTrait> DynCombinatorTrait for Profiled<T> {\\n    fn parse_dyn(&self, right_data: RightData, bytes: &[u8]) -> (Box<dyn ParserTrait + '_>, ParseResults) {\\n        let (parser, parse_results) = self.parse(right_data, bytes);\\n        (Box::new(parser), parse_results)\\n    }\\n\\n    fn one_shot_parse_dyn<'a>(&'a self, right_data: RightData, bytes: &[u8]) -> UnambiguousParseResults {\\n        self.one_shot_parse(right_data, bytes)\\n    }\\n}\\n\\nimpl<T: CombinatorTrait> CombinatorTrait for Profiled<T> {\\n    type Parser<'a> = ProfiledParser<T::Parser<'a>> where Self: 'a;\\n    type Output = T::Output;\\n    type PartialOutput = T::PartialOutput;\\n\\n    fn one_shot_parse(&self, right_data: RightData, bytes: &[u8]) -> UnambiguousParseResults {\\n        profile!(&self.tag, self.inner.one_shot_parse(right_data, bytes))\\n    }\\n\\n    fn old_parse(&self, right_data: RightData, bytes: &[u8]) -> (Self::Parser<'_>, ParseResults) {\\n        profile!(&self.tag, {\\n            let (parser, parse_results) = self.inner.parse(right_data, bytes);\\n            let parser = ProfiledParser { inner: parser, tag: self.tag.clone() };\\n            (parser, parse_results)\\n        })\\n    }\\n}\\n\\nimpl<T: CombinatorTrait> BaseCombinatorTrait for Profiled<T> {\\n    fn as_any(&self) -> &dyn std::any::Any where Self: 'static {\\n        self\\n    }\\n    fn apply_to_children(&self, f: &mut dyn FnMut(&dyn BaseCombinatorTrait)) {\\n        f(&self.inner);\\n    }\\n}\\n\\nimpl<P: ParserTrait> ParserTrait for ProfiledParser<P> {\\n    fn get_u8set(&self) -> U8Set {\\n        self.inner.get_u8set()\\n    }\\n\\n    fn parse(&mut self, bytes: &[u8]) -> ParseResults {\\n        profile!(&self.tag, self.inner.parse(bytes))\\n    }\\n}\\n\\npub fn profile<T: IntoCombinator>(tag: &str, a: T)-> impl CombinatorTrait {\\n    // Profiled { inner: a.into_combinator(), tag: tag.to_string() }\\n    a.into_combinator()\\n}\\n\\npub fn profile_internal<'a, T: IntoCombinator>(tag: &str, a: T)-> impl CombinatorTrait {\\n    profile(tag, a)\\n}\"}, {\"path\": \"src/_03_combinators/wrappers/reference.rs\", \"tokens\": 3068, \"content\": \"\\n// src/_03_combinators/wrappers/reference.rs\\nuse crate::BaseCombinatorTrait;\\nuse crate::*;\\nuse once_cell::unsync::OnceCell;\\nuse std::fmt::{Debug, Formatter};\\n// src/combinators/reference.rs\\nuse std::hash::{Hash, Hasher};\\nuse std::rc::{Rc, Weak};\\n\\npub struct WeakRef<T> {\\n    pub inner: Weak<OnceCell<T>>,\\n}\\n\\npub struct StrongRef<T> {\\n    pub inner: Rc<OnceCell<T>>,\\n}\\n\\nimpl<T> Debug for WeakRef<T> {\\n    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {\\n        f.debug_struct(\\\"WeakRef\\\").finish_non_exhaustive()\\n    }\\n}\\n\\nimpl<T: Debug> Debug for StrongRef<T> {\\n    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {\\n        f.debug_struct(\\\"StrongRef\\\").finish_non_exhaustive()\\n    }\\n}\\n\\nimpl<T> Clone for StrongRef<T> {\\n    fn clone(&self) -> Self {\\n        StrongRef {\\n            inner: self.inner.clone()\\n        }\\n    }\\n}\\n\\nimpl<T> Clone for WeakRef<T> {\\n    fn clone(&self) -> Self {\\n        WeakRef {\\n            inner: self.inner.clone()\\n        }\\n    }\\n}\\n\\nimpl<T> PartialEq for WeakRef<T> {\\n    fn eq(&self, other: &Self) -> bool {\\n        self.inner.ptr_eq(&other.inner)\\n    }\\n}\\n\\nimpl<T> Eq for WeakRef<T> {}\\n\\nimpl<T> Hash for WeakRef<T> {\\n    fn hash<H: Hasher>(&self, state: &mut H) {\\n        std::ptr::hash(&self.inner, state);\\n    }\\n}\\n\\nimpl<T> PartialEq for StrongRef<T> {\\n    fn eq(&self, other: &Self) -> bool {\\n        Rc::ptr_eq(&self.inner, &other.inner)\\n    }\\n}\\n\\nimpl<T> Eq for StrongRef<T> {}\\n\\nimpl<T> Hash for StrongRef<T> {\\n    fn hash<H: Hasher>(&self, state: &mut H) {\\n        std::ptr::hash(&self.inner, state);\\n    }\\n}\\n\\nimpl<T: CombinatorTrait> DynCombinatorTrait for WeakRef<T> {\\n    fn parse_dyn(&self, right_data: RightData, bytes: &[u8]) -> (Box<dyn ParserTrait + '_>, ParseResults) {\\n        let (parser, parse_results) = self.parse(right_data, bytes);\\n        (Box::new(parser), parse_results)\\n    }\\n\\n    fn one_shot_parse_dyn<'a>(&'a self, right_data: RightData, bytes: &[u8]) -> UnambiguousParseResults {\\n        self.one_shot_parse(right_data, bytes)\\n    }\\n}\\n\\nimpl<T: CombinatorTrait> CombinatorTrait for WeakRef<T> {\\n    type Parser<'a> = T::Parser<'a> where Self: 'a;\\n    type Output = T::Output;\\n    type PartialOutput = T::PartialOutput;\\n\\n    fn one_shot_parse(&self, right_data: RightData, bytes: &[u8]) -> UnambiguousParseResults {\\n        let combinator = self.get().unwrap();\\n        combinator.one_shot_parse(right_data, bytes)\\n    }\\n\\n    fn old_parse(&self, right_data: RightData, bytes: &[u8]) -> (Self::Parser<'_>, ParseResults) {\\n        let combinator = self.get().unwrap();\\n        combinator.parse(right_data, bytes)\\n    }\\n}\\n\\nimpl<T: CombinatorTrait> BaseCombinatorTrait for WeakRef<T> {\\n    fn as_any(&self) -> &dyn std::any::Any where Self: 'static {\\n        self\\n    }\\n    fn apply_to_children(&self, f: &mut dyn FnMut(&dyn BaseCombinatorTrait)) {\\n        f(self.inner.upgrade().expect(\\\"WeakRef is already dropped\\\").get().expect(\\\"Combinator hasn't been set\\\"));\\n    }\\n}\\n\\nimpl<T: CombinatorTrait> DynCombinatorTrait for StrongRef<T> {\\n    fn parse_dyn(&self, right_data: RightData, bytes: &[u8]) -> (Box<dyn ParserTrait + '_>, ParseResults) {\\n        let (parser, parse_results) = self.parse(right_data, bytes);\\n        (Box::new(parser), parse_results)\\n    }\\n\\n    fn one_shot_parse_dyn<'a>(&'a self, right_data: RightData, bytes: &[u8]) -> UnambiguousParseResults {\\n        self.one_shot_parse(right_data, bytes)\\n    }\\n}\\n\\nimpl<T: CombinatorTrait> CombinatorTrait for StrongRef<T> {\\n    type Parser<'a> = T::Parser<'a> where Self: 'a;\\n    type Output = T::Output;\\n    type PartialOutput = T::PartialOutput;\\n\\n    fn one_shot_parse(&self, right_data: RightData, bytes: &[u8]) -> UnambiguousParseResults {\\n        let combinator = self.inner.get().unwrap();\\n        combinator.one_shot_parse(right_data, bytes)\\n    }\\n\\n    fn old_parse(&self, right_data: RightData, bytes: &[u8]) -> (Self::Parser<'_>, ParseResults) {\\n        self.inner\\n            .get()\\n            .unwrap()\\n            .parse(right_data, bytes)\\n    }\\n}\\n\\nimpl<T: CombinatorTrait> BaseCombinatorTrait for StrongRef<T> {\\n    fn as_any(&self) -> &dyn std::any::Any where Self: 'static {\\n        self\\n    }\\n    fn apply_to_children(&self, f: &mut dyn FnMut(&dyn BaseCombinatorTrait)) {\\n        f(self.inner.get().unwrap());\\n    }\\n}\\n\\npub fn strong_ref<T>() -> StrongRef<T> {\\n    StrongRef {\\n        inner: Rc::new(OnceCell::new())\\n    }\\n}\\n\\nimpl<T> StrongRef<T> {\\n    pub fn set(&self, inner: T) {\\n        self.inner.set(inner).ok().expect(\\\"Cannot set value more than once\\\");\\n    }\\n\\n    pub fn downgrade(&self) -> WeakRef<T> {\\n        WeakRef {\\n            inner: Rc::downgrade(&self.inner)\\n        }\\n    }\\n\\n    pub fn new(inner: T) -> Self {\\n        let cell = OnceCell::new();\\n        cell.set(inner).ok().expect(\\\"Cannot set value more than once\\\");\\n        Self { inner: Rc::new(cell) }\\n    }\\n}\\n\\nimpl<T> WeakRef<T> {\\n    pub fn upgrade(&self) -> Option<StrongRef<T>> {\\n        self.inner.upgrade().map(|inner| StrongRef { inner })\\n    }\\n\\n    pub fn get(&self) -> Option<&T> {\\n        // Upgrade the weak reference to a strong reference\\n        let strong_ref = self.inner.upgrade()?;\\n\\n        // Safely access the inner Combinator\\n        // Note: We use unsafe code here to transmute the lifetime.\\n        // This is safe because the OnceCell guarantees that the value,\\n        // once set, will live as long as the Rc/Weak, which is 'static.\\n        unsafe {\\n            let combinator: &T = std::mem::transmute(strong_ref.get().unwrap());\\n            Some(combinator)\\n        }\\n    }\\n}\"}, {\"path\": \"src/_03_combinators/wrappers/symbol.rs\", \"tokens\": 1042, \"content\": \"\\n// src/_03_combinators/wrappers/symbol.rs\\nuse crate::{RightData, RightDataGetters};\\nuse crate::{BaseCombinatorTrait, DynCombinatorTrait, UnambiguousParseResults};\\nuse std::rc::Rc;\\n\\nuse crate::{CombinatorTrait, IntoCombinator, ParseResultTrait, ParseResults, ParserTrait};\\n#[derive(Debug)]\\npub struct Symbol<T> {\\n    pub value: Rc<T>,\\n}\\n\\nimpl<T> Clone for Symbol<T> {\\n    fn clone(&self) -> Self {\\n        Symbol { value: self.value.clone() }\\n    }\\n}\\n\\nimpl<T: CombinatorTrait> DynCombinatorTrait for Symbol<T> {\\n    fn parse_dyn(&self, right_data: RightData, bytes: &[u8]) -> (Box<dyn ParserTrait + '_>, ParseResults) {\\n        let (parser, parse_results) = self.parse(right_data, bytes);\\n        (Box::new(parser), parse_results)\\n    }\\n\\n    fn one_shot_parse_dyn<'a>(&'a self, right_data: RightData, bytes: &[u8]) -> UnambiguousParseResults {\\n        self.one_shot_parse(right_data, bytes)\\n    }\\n}\\n\\nimpl<T: CombinatorTrait> CombinatorTrait for Symbol<T> {\\n    type Parser<'a> = T::Parser<'a> where Self: 'a;\\n    type Output = T::Output;\\n    type PartialOutput = T::PartialOutput;\\n\\n    fn one_shot_parse(&self, right_data: RightData, bytes: &[u8]) -> UnambiguousParseResults {\\n        self.value.one_shot_parse(right_data, bytes)\\n    }\\n\\n    fn old_parse(&self, right_data: RightData, bytes: &[u8]) -> (Self::Parser<'_>, ParseResults) {\\n        let (parser, parse_results) = self.value.parse(right_data, bytes);\\n        (parser, parse_results)\\n    }\\n}\\n\\nimpl<T: CombinatorTrait> BaseCombinatorTrait for Symbol<T> {\\n    fn as_any(&self) -> &dyn std::any::Any where Self: 'static {\\n        self\\n    }\\n    fn apply_to_children(&self, f: &mut dyn FnMut(&dyn BaseCombinatorTrait)) {\\n        f(self.value.as_ref());\\n    }\\n}\\n\\npub fn symbol<T: IntoCombinator>(value: T) -> Symbol<T::Output> {\\n    Symbol { value: Rc::new(value.into_combinator()) }\\n}\"}, {\"path\": \"src/_03_combinators/wrappers/tag.rs\", \"tokens\": 1620, \"content\": \"\\n// src/_03_combinators/wrappers/tag.rs\\nuse std::fmt::{Debug, Formatter};\\nuse std::panic::{catch_unwind, resume_unwind, AssertUnwindSafe};\\n\\nuse crate::BaseCombinatorTrait;\\nuse crate::*;\\n\\npub struct Tagged<T: CombinatorTrait> {\\n    pub inner: T,\\n    pub tag: String,\\n}\\n\\npub struct TaggedParser<P> {\\n    pub inner: P,\\n    pub tag: String,\\n}\\n\\nimpl<T: CombinatorTrait> Debug for Tagged<T> {\\n    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {\\n        f.debug_struct(\\\"Tagged\\\")\\n            .field(\\\"tag\\\", &self.tag)\\n            .finish_non_exhaustive()\\n    }\\n}\\n\\nimpl<P> Debug for TaggedParser<P> {\\n    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {\\n        f.debug_struct(\\\"TaggedParser\\\")\\n            .field(\\\"tag\\\", &self.tag)\\n            .finish_non_exhaustive()\\n    }\\n}\\n\\nimpl<T: CombinatorTrait> DynCombinatorTrait for Tagged<T> {\\n    fn parse_dyn(&self, right_data: RightData, bytes: &[u8]) -> (Box<dyn ParserTrait + '_>, ParseResults) {\\n        let (parser, parse_results) = self.parse(right_data, bytes);\\n        (Box::new(parser), parse_results)\\n    }\\n\\n    fn one_shot_parse_dyn<'a>(&'a self, right_data: RightData, bytes: &[u8]) -> UnambiguousParseResults {\\n        self.one_shot_parse(right_data, bytes)\\n    }\\n}\\n\\nimpl<'b, T: CombinatorTrait> CombinatorTrait for Tagged<T> where T: 'b {\\n    type Parser<'a> = TaggedParser<T::Parser<'a>> where Self: 'a;\\n    type Output = T::Output;\\n    type PartialOutput = T::PartialOutput;\\n\\n    fn one_shot_parse(&self, right_data: RightData, bytes: &[u8]) -> UnambiguousParseResults {\\n        self.inner.one_shot_parse(right_data, bytes)\\n    }\\n\\n    fn old_parse(&self, right_data: RightData, bytes: &[u8]) -> (Self::Parser<'_>, ParseResults) {\\n        count_hit!(self.tag);\\n        let result = catch_unwind(AssertUnwindSafe(|| self.inner.parse(right_data, bytes)));\\n        match result {\\n            Ok((parser, parse_results)) => (\\n                TaggedParser { inner: parser, tag: self.tag.clone() },\\n                parse_results,\\n            ),\\n            Err(err) => {\\n                eprintln!(\\\"Panic caught in parser with tag: {}\\\", self.tag);\\n                resume_unwind(err);\\n            }\\n        }\\n    }\\n}\\n\\nimpl<T: CombinatorTrait> BaseCombinatorTrait for Tagged<T> {\\n    fn as_any(&self) -> &dyn std::any::Any where Self: 'static {\\n        self\\n    }\\n    fn apply_to_children(&self, f: &mut dyn FnMut(&dyn BaseCombinatorTrait)) {\\n        f(&self.inner);\\n    }\\n}\\n\\nimpl<P: ParserTrait> ParserTrait for TaggedParser<P> {\\n    fn get_u8set(&self) -> U8Set {\\n        self.inner.get_u8set()\\n    }\\n\\n    fn parse(&mut self, bytes: &[u8]) -> ParseResults {\\n        self.inner.parse(bytes)\\n    }\\n}\\n\\npub fn tag<T: IntoCombinator + 'static>(tag: &'static str, a: T)-> impl CombinatorTrait where T::Output: 'static {\\n    // TODO: ffs\\n    Tagged { inner: profile(tag, a), tag: tag.to_string() }\\n    // Tagged { inner: a.into_combinator(), tag: tag.to_string() }\\n    // a.into_combinator()\\n}\"}, {\"path\": \"src/_06_tests/utils.rs\", \"tokens\": 7364, \"content\": \"use crate::{clear_profile_data, RightData, RightDataGetters, UnambiguousParseResults, UpData};\\nuse std::panic::{catch_unwind, AssertUnwindSafe};\\n\\nuse kdam::tqdm;\\n\\nuse crate::{profile, CombinatorTrait, CombinatorTraitExt, ParseResultTrait, ParseResults, ParserTrait, ParserTraitExt, Squash, GLOBAL_PROFILE_DATA};\\n\\nuse std::collections::HashMap;\\nuse std::fs::File;\\nuse std::io::{BufWriter, Write};\\nuse std::time::{Duration, Instant};\\n\\nconst VERBOSE: bool = false;\\n\\npub fn assert_parses<T: CombinatorTrait, S: ToString>(combinator: &T, input: S, desc: &str) {\\n    clear_profile_data();\\n    let input = input.to_string();\\n    println!(\\\"beginning assert_parses {}\\\", desc);\\n\\n    let mut timings = Vec::new();\\n\\n    let (mut parser, mut parse_results) = profile!(\\\"parser\\\", combinator.parser(RightData::default()));\\n\\n    let lines = input.lines().collect::<Vec<_>>();\\n    let num_lines = lines.len();\\n\\n    profile!(\\\"assert_parses main loop\\\", {\\n        for (line_number, line) in tqdm!(lines.iter().enumerate(), animation = \\\"fillup\\\", position = 0) {\\n            let line_start = Instant::now();\\n\\n            let line = if line_number != num_lines - 1 {\\n                format!(\\\"{}\\\\n\\\", line)\\n            } else {\\n                line.to_string()\\n            };\\n            let bytes = line.bytes().collect::<Vec<_>>();\\n\\n            for (char_number, byte) in bytes.iter().cloned().enumerate() {\\n                parse_results.squash();\\n                assert!(parser.get_u8set().contains(byte),\\n                    \\\"byte {:?} is not in any up_data: {:?}. Line: {:?}, Char: {:?}, Text: {:?}, u8set: {:?}\\\",\\n                    byte as char, parse_results, line_number, char_number, line, parser.get_u8set());\\n\\n                if line_number == lines.len() - 1 && char_number == bytes.len() - 1 {\\n                    timings.push((line.to_string(), Instant::now() - line_start));\\n                    break;\\n                }\\n\\n                if VERBOSE {\\n                    println!(\\\"line:char: {line_number}:{char_number}\\\");\\n                    println!(\\\"line: {line:?}\\\");\\n                }\\n\\n                parse_results = catch_unwind(AssertUnwindSafe(|| parser.step(byte)))\\n                    .expect(format!(\\\"Parser.step: Error at byte: {} on line: {} at char: {}\\\", byte as char, line_number, char_number).as_str());\\n\\n                parse_results.squash();\\n\\n                assert!(!parse_results.up_data_vec.is_empty() || !parser.get_u8set().is_empty(),\\n                    \\\"Parser didn't return any data at byte: {} on line: {} at char: {}\\\", byte as char, line_number, char_number);\\n                assert!(!parse_results.done(),\\n                    \\\"Parser finished prematurely at byte: {} on line: {} at char: {}\\\", byte as char, line_number, char_number);\\n            }\\n\\n            timings.push((line, Instant::now() - line_start));\\n        }\\n    });\\n\\n    print_profile_results();\\n\\n    print_timing_results(timings);\\n}\\n\\npub fn assert_parses_tight<T: CombinatorTrait, S: ToString>(combinator: &T, input: S, desc: &str) {\\n    clear_profile_data();\\n    let input = input.to_string();\\n    println!(\\\"beginning assert_parses_tight {}\\\", desc);\\n\\n    let (mut parser, mut parse_results) = combinator.parser(RightData::default());\\n\\n    let lines = input.lines().collect::<Vec<_>>();\\n    let num_lines = lines.len();\\n\\n    let start = Instant::now();\\n\\n    profile!(\\\"assert_parses_tight main loop\\\", {\\n        for (line_number, line) in lines.iter().enumerate() {\\n            let line = if line_number != num_lines - 1 {\\n                format!(\\\"{}\\\\n\\\", line)\\n            } else {\\n                line.to_string()\\n            };\\n            let bytes = line.bytes().collect::<Vec<_>>();\\n\\n            for (char_number, byte) in bytes.iter().cloned().enumerate() {\\n                if line_number == lines.len() - 1 && char_number == bytes.len() - 1 {\\n                    break;\\n                }\\n                parse_results = parser.step(byte);\\n            }\\n        }\\n    });\\n\\n    println!(\\\"assert_parses_tight took {:?}\\\", start.elapsed());\\n}\\n\\npub fn assert_parses_default<T: CombinatorTrait, S: ToString>(combinator: &T, input: S) {\\n    assert_parses(combinator, input, \\\"Parser failed unexpectedly\\\");\\n}\\n\\npub fn profile_parse<T: CombinatorTrait, S: ToString>(combinator: &T, input: S) {\\n    println!(\\\"beginning profile_parse\\\");\\n\\n    let (mut parser, mut parse_results) = combinator.parser(RightData::default());\\n\\n    for byte in tqdm!(input.to_string().bytes(), animation = \\\"fillup\\\", position = 0) {\\n        parse_results = parser.step(byte);\\n    }\\n\\n    print_profile_results();\\n}\\n\\n\\npub fn assert_parses_fast<T: CombinatorTrait, S: ToString>(combinator: &T, input: S) {\\n    let bytes = input.to_string().bytes().collect::<Vec<_>>();\\n    let start = Instant::now();\\n    let (parser, mut parse_results) = profile!(\\\"assert_parses_fast parse\\\", {\\n        combinator.parse(RightData::default(), &bytes)\\n    });\\n    let duration = start.elapsed();\\n    println!(\\\"assert_parses_fast parse took {:?}\\\", duration);\\n    parse_results.squash();\\n\\n    let max_position = parse_results.up_data_vec\\n        .iter()\\n        .max_by_key(|up_data| up_data.get_fields1().position)\\n        .expect(\\\"Expected at least one right data.\\\")\\n        .get_fields1().position;\\n\\n    let (line_number, char_number) = calculate_line_and_char_number(&bytes, max_position);\\n\\n    print_profile_results();\\n\\n    parse_results.squash();\\n\\n    println!(\\\"max_position: {max_position}, line_number: {line_number}, char_number: {char_number}\\\");\\n    assert!(parse_results.up_data_vec\\n        .iter()\\n        .max_by_key(|up_data| up_data.get_fields1().position)\\n        .expect(\\\"Expected at least one right data.\\\")\\n        .get_fields1().position == bytes.len(),\\n        \\\"Expected parser to finish with right data at the end position {}. parse_results: {:?}\\\", bytes.len(), parse_results);\\n}\\n\\npub fn assert_parses_fast_with_tolerance<T: CombinatorTrait, S: ToString>(combinator: &T, input: S, tolerance: usize) {\\n    let bytes = input.to_string().bytes().collect::<Vec<_>>();\\n    let (parser, mut parse_results) = combinator.parse(RightData::default(), &bytes);\\n    parse_results.squash();\\n\\n    let max_position = parse_results.up_data_vec\\n        .iter()\\n        .max_by_key(|up_data| up_data.get_fields1().position)\\n        .expect(\\\"Expected at least one right data.\\\")\\n        .get_fields1().position;\\n\\n    let (line_number, char_number) = calculate_line_and_char_number(&bytes, max_position);\\n\\n    print_profile_results();\\n\\n    assert!(parse_results.up_data_vec\\n        .iter()\\n        .max_by_key(|up_data| up_data.get_fields1().position)\\n        .expect(\\\"Expected at least one right data.\\\")\\n        .get_fields1().position >= bytes.len().saturating_sub(tolerance),\\n        \\\"Expected parser to finish with right data at the end position {}. parse_results: {:?}\\\", bytes.len(), parse_results);\\n}\\n\\npub fn assert_parses_one_shot<T: CombinatorTrait, S: ToString>(combinator: &T, input: S) {\\n    let bytes = input.to_string().bytes().collect::<Vec<_>>();\\n    let start = Instant::now();\\n    let parse_results = profile!(\\\"assert_parses_fast parse\\\", {\\n        combinator.one_shot_parse(RightData::default(), &bytes)\\n    });\\n    let one_shot_up_data = parse_results.expect(\\\"Error parsing input.\\\");\\n    let duration = start.elapsed();\\n    println!(\\\"assert_parses_fast parse took {:?}\\\", duration);\\n\\n    let max_position = one_shot_up_data.get_fields1().position;\\n    let (line_number, char_number) = calculate_line_and_char_number(&bytes, max_position);\\n\\n    print_profile_results();\\n\\n    println!(\\\"max_position: {max_position}, line_number: {line_number}, char_number: {char_number}\\\");\\n\\n    assert!(one_shot_up_data.get_fields1().position == bytes.len(),\\n        \\\"Expected parser to finish with right data at the end position {}. right_data: {:?}\\\", bytes.len(), one_shot_up_data);\\n}\\n\\npub fn assert_parses_one_shot_with_result<T: CombinatorTrait, S: ToString>(combinator: &T, input: S, expected_result: UnambiguousParseResults) {\\n    let bytes = input.to_string().bytes().collect::<Vec<_>>();\\n    let start = Instant::now();\\n    let parse_results = profile!(\\\"assert_parses_fast parse\\\", {\\n        combinator.one_shot_parse(RightData::default(), &bytes)\\n    });\\n    let duration = start.elapsed();\\n    println!(\\\"assert_parses_fast parse took {:?}\\\", duration);\\n\\n    print_profile_results();\\n\\n    assert_eq!(parse_results, expected_result, \\\"Expected parse result {:?}, but got {:?}\\\", expected_result, parse_results);\\n}\\n\\npub fn assert_fails<T: CombinatorTrait, S: ToString>(combinator: &T, input: S, desc: &str) {\\n    let input = input.to_string();\\n    println!(\\\"beginning assert_fails {}\\\", desc);\\n    let (mut parser, ParseResults { .. }) = combinator.parser(RightData::default());\\n\\n    let lines = input.lines().collect::<Vec<_>>();\\n    let num_lines = lines.len();\\n    for (line_number, line) in tqdm!(lines.iter().enumerate(), animation = \\\"fillup\\\", position = 0) {\\n        let line = if line_number != num_lines - 1 {\\n            format!(\\\"{}\\\\n\\\", line)\\n        } else {\\n            line.to_string()\\n        };\\n        let bytes = line.bytes().collect::<Vec<_>>();\\n        for (char_number, byte) in tqdm!(bytes.iter().cloned().enumerate(), animation = \\\"fillup\\\", position = 1) {\\n            let u8set = parser.get_u8set();\\n            if !u8set.contains(byte) {\\n                println!(\\\"byte {:?} is not in the u8set: {:?}\\\", byte as char, u8set);\\n                return;\\n            }\\n\\n            if line_number == lines.len() - 1 && char_number == bytes.len() - 1 {\\n                break;\\n            }\\n\\n            let ParseResults {\\n                up_data_vec: up_data,\\n                ..\\n            } = parser.step(byte).squashed();\\n\\n            if !up_data.is_empty() || !parser.get_u8set().is_empty() {\\n                panic!(\\\"Parser succeeded at byte: {} on line: {} at char: {}\\\", byte as char, line_number, char_number);\\n            }\\n        }\\n    }\\n\\n    panic!(\\\"{}\\\", desc);\\n}\\n\\npub fn assert_fails_default<T: CombinatorTrait, S: ToString>(combinator: &T, input: S) {\\n    assert_fails(combinator, input, \\\"Parser succeeded unexpectedly\\\");\\n}\\n\\npub fn assert_fails_fast<T: CombinatorTrait, S: ToString>(combinator: &T, input: S) {\\n    let (mut parser, _) = combinator.parser(RightData::default());\\n    let bytes = input.to_string().bytes().collect::<Vec<_>>();\\n    let parse_results = parser.parse(&bytes);\\n    assert!(parse_results.done() && parse_results.up_data_vec.iter().max_by_key(|up_data| up_data.get_fields1().position).map_or(true, |up_data| up_data.get_fields1().position == bytes.len()), \\\"Expected parser to fail at the end. parse_results: {:?}\\\", parse_results);\\n}\\n\\n// Helper functions to reduce code duplication\\n\\nfn print_profile_results() {\\n    let profile_data = GLOBAL_PROFILE_DATA.lock().unwrap();\\n    let total_time = profile_data.timings.iter().map(|(_, duration)| *duration).sum::<Duration>();\\n    println!(\\\"Total time: {:?}\\\", total_time);\\n\\n    // Print profile results\\n    let mut profile_vec: Vec<(String, Duration)> = profile_data.timings.iter().map(|(tag, duration)| (tag.clone(), *duration)).collect::<Vec<_>>();\\n    profile_vec.sort_by(|(_, duration_a), (_, duration_b)| duration_b.partial_cmp(duration_a).unwrap());\\n    println!(\\\"Profile results:\\\");\\n    for (tag, duration) in profile_vec.clone() {\\n        let percent = duration.as_secs_f64() / total_time.as_secs_f64() * 100.0;\\n        println!(\\\"{:>9} {:6.2}% {}\\\", format!(\\\"{:.3?}\\\", duration), percent, tag);\\n    }\\n    println!(\\\"Hit counts:\\\");\\n    let total_hit_count = profile_data.hit_counts.values().sum::<usize>();\\n    let mut hit_counts = profile_data.hit_counts.iter().collect::<Vec<_>>();\\n    hit_counts.sort_by(|(_, hit_count_a), (_, hit_count_b)| hit_count_b.partial_cmp(hit_count_a).unwrap());\\n    for (tag, hit_count) in hit_counts.clone() {\\n        let percent = *hit_count as f64 / total_hit_count as f64 * 100.0;\\n        println!(\\\"{:>9} {:6.2}% {}\\\", format!(\\\"{:.3?}\\\", hit_count), percent, tag);\\n    }\\n    // Duration per hit\\n    println!(\\\"Duration per hit:\\\");\\n    let mut duration_per_hit: HashMap<String, Duration> = HashMap::new();\\n    for (tag, hits) in profile_data.hit_counts.iter() {\\n        if let Some(duration) = profile_data.timings.get(tag) {\\n            duration_per_hit.insert(tag.clone(), *duration / *hits as u32);\\n        }\\n    }\\n    let mut duration_per_hit: Vec<(String, Duration)> = duration_per_hit.into_iter().collect::<Vec<_>>();\\n    duration_per_hit.sort_by(|(_, duration_a), (_, duration_b)| duration_b.partial_cmp(duration_a).unwrap());\\n    for (tag, duration) in duration_per_hit.clone() {\\n        let percent = duration.as_secs_f64() / total_time.as_secs_f64() * 100.0;\\n        println!(\\\"{:>9} {:6.2}% {}\\\", format!(\\\"{:.3?}\\\", duration), percent, tag);\\n    }\\n    drop(profile_data);\\n}\\n\\nfn calculate_line_and_char_number(bytes: &[u8], max_position: usize) -> (usize, usize) {\\n    let mut line_number = 0;\\n    let mut char_number = 0;\\n    for byte in bytes[0..max_position].iter().cloned() {\\n        if byte == b'\\\\n' {\\n            line_number += 1;\\n            char_number = 0;\\n        } else {\\n            char_number += 1;\\n        }\\n    }\\n    (line_number, char_number)\\n}\\n\\nfn print_timing_results(timings: Vec<(String, Duration)>) {\\n    // Print timing results\\n    let mut timing_vec: Vec<(String, std::time::Duration)> = timings.into_iter().collect();\\n\\n    // Get 90th percentile\\n    let mut timing_vec_sorted: Vec<(String, std::time::Duration)> = timing_vec.iter().cloned().collect();\\n    timing_vec_sorted.sort_by(|(line_a, duration_a), (line_b, duration_b)| {\\n        let time_per_char_a = duration_a.as_secs_f64() / line_a.len() as f64;\\n        let time_per_char_b = duration_b.as_secs_f64() / line_b.len() as f64;\\n        time_per_char_b.partial_cmp(&time_per_char_a).unwrap()\\n    });\\n    let threshold = timing_vec_sorted[timing_vec_sorted.len() / 10].1;\\n\\n    if VERBOSE {\\n        println!(\\\"Execution time profile:\\\");\\n        for (desc, duration) in timing_vec.clone() {\\n            let duration_secs = duration.as_secs_f64();\\n            let time_per_char = duration_secs / desc.len() as f64 * 1000.0;\\n            let emphasis = if duration > threshold { \\\" * \\\" } else { \\\"   \\\" };\\n            let bold = if duration > threshold { \\\"\\\\x1b[1m\\\" } else { \\\"\\\" };\\n            let reset = if bold.is_empty() { \\\"\\\" } else { \\\"\\\\x1b[0m\\\" };\\n            println!(\\\"{}{:<15}{:<10}{:?}{}s\\\",\\n                     emphasis,\\n                     format!(\\\"{:.3}ms/char\\\", time_per_char),\\n                     format!(\\\"{:.3}s\\\", duration_secs),\\n                     bold,\\n                     desc,\\n            );\\n        }\\n    }\\n\\n    // Save to CSV\\n    let mut csv_file = BufWriter::new(File::create(\\\"timings.csv\\\").unwrap());\\n    csv_file.write_all(\\\"index,text,duration\\\\n\\\".as_bytes()).unwrap();\\n    for (i, (line, duration)) in timing_vec.iter().enumerate() {\\n        // Escape quotes and newlines in the text\\n        let line = line.replace(\\\"\\\\\\\"\\\", \\\"\\\\\\\"\\\\\\\"\\\");\\n        let line = line.replace(\\\"\\\\n\\\", \\\"\\\\\\\\n\\\");\\n        csv_file.write_all(format!(\\\"{},\\\\\\\"{}\\\\\\\",{}\\\\n\\\", i, line, duration.as_secs_f64()).as_bytes()).unwrap();\\n    }\\n    if VERBOSE {\\n        println!(\\\"Saved timings to timings.csv\\\");\\n    }\\n}\"}]"
    },
    {
      "role": "user",
      "content": "/plan Modify this code:\n\n- Define `OutputTrait` and constrain `CombinatorTrait::Output` to implement it. Remove `PartialOutput`; we'll assume `CombinatorTrait::Output` is partial (i.e. we'll never assume an output is complete - it could always have parts missing. Do similarly for other traits like `ParserTrait` and the dyn versions.\n- Modify `UpData` so it has a generic `Output` and a field `output: Output`. You'll have to modify `ParseResults` so it's generic over this as well. Modify `UnambiguousParseResults` and `OneShotUpData` similarly.\n- The signature for `ParserTrait::parse` is `fn parse<'b>(&mut self, bytes: &'b [u8]) -> ParseResults<Self::Output> where Self::Output: 'b;`.\n- The signature for `CombinatorTrait::parse` is `fn parse<'a, 'b>(&'a self, right_data: RightData, bytes: &'b [u8]) -> (Self::Parser<'a>, ParseResults<Self::Output>) where Self::Output: 'b` and likewise for `old_parse`.\n- The signature for `CombinatorTrait::one_shot_parse` is `fn one_shot_parse<'b>(&self, right_data: RightData, bytes: &'b [u8]) -> UnambiguousParseResults<Self::Output> where Self::Output: 'b;`.\n- `Output` should not exist on `UnambiguousParseError` at all, only in the ok, `OneShotUpData`, does it exist. Also, constrain `Output` in the associated type to implement the basic useful stuff like maybe clone, eq and such.\n- Any other code is modified accordingly."
    },
    {
      "role": "model",
      "content": "{\"suggested_files_to_generate\": [\"src/_01_parse_state/frame_stack.rs\", \"src/_01_parse_state/mod.rs\", \"src/_01_parse_state/parse_results.rs\", \"src/_01_parse_state/right_data.rs\", \"src/_01_parse_state/traits.rs\", \"src/_02_traits/combinator.rs\", \"src/_02_traits/convert.rs\", \"src/_03_combinators/cache.rs\", \"src/_03_combinators/core/choice.rs\", \"src/_03_combinators/core/choice_macro.rs\", \"src/_03_combinators/core/choicen.rs\", \"src/_03_combinators/core/eat.rs\", \"src/_03_combinators/core/fast.rs\", \"src/_03_combinators/core/mod.rs\", \"src/_03_combinators/core/opt.rs\", \"src/_03_combinators/core/repeat1.rs\", \"src/_03_combinators/core/seq.rs\", \"src/_03_combinators/core/seq_macro.rs\", \"src/_03_combinators/core/seqn.rs\", \"src/_03_combinators/derived.rs\", \"src/_03_combinators/lookaheads/lookahead.rs\", \"src/_03_combinators/lookaheads/mod.rs\", \"src/_03_combinators/lookaheads/negative_lookahead.rs\", \"src/_03_combinators/mod.rs\", \"src/_03_combinators/nullable/check_right_data.rs\", \"src/_03_combinators/nullable/eps_and_fail.rs\", \"src/_03_combinators/nullable/forbid_follows.rs\", \"src/_03_combinators/nullable/mod.rs\", \"src/_03_combinators/unicode.rs\", \"src/_03_combinators/wrappers/deferred.rs\", \"src/_03_combinators/wrappers/dyn_parser.rs\", \"src/_03_combinators/wrappers/mod.rs\", \"src/_03_combinators/wrappers/profile.rs\", \"src/_03_combinators/wrappers/reference.rs\", \"src/_03_combinators/wrappers/symbol.rs\", \"src/_03_combinators/wrappers/tag.rs\", \"src/_06_tests/utils.rs\"]} "
    },
    {
      "role": "user",
      "content": "/generate src/_01_parse_state/frame_stack.rs src/_01_parse_state/mod.rs src/_01_parse_state/parse_results.rs src/_01_parse_state/right_data.rs"
    },
    {
      "role": "model",
      "content": "{\"src/_01_parse_state/frame_stack.rs\": \"use std::collections::BTreeSet;\\nuse std::hash::Hash;\\n\\nuse crate::U8Set;\\n\\n#[derive(Clone, PartialEq, Debug, Hash, PartialOrd, Ord, Eq)]\\npub struct FrameStack {\\n    frames: Vec<Frame>,\\n}\\n\\nimpl Default for FrameStack {\\n    fn default() -> Self {\\n        Self {\\n            frames: vec![Frame::default()],\\n        }\\n    }\\n}\\n\\n#[derive(Clone, PartialEq, Debug, Default, Eq, Hash, PartialOrd, Ord)]\\npub struct Frame {\\n    pos: BTreeSet<String>,\\n}\\n\\nimpl Frame {\\n    pub fn contains_prefix(&self, name_prefix: &str) -> bool {\\n        self.pos.iter().any(|name| name.starts_with(name_prefix))\\n    }\\n\\n    pub fn contains(&self, name: &str) -> bool {\\n        self.pos.contains(name)\\n    }\\n\\n    pub fn next_u8_given_contains(&self, name: &[u8]) -> (U8Set, bool) {\\n        let mut u8set = U8Set::none();\\n        let mut is_complete = false;\\n        for existing_name in self.pos.iter() {\\n            let existing_name = existing_name.as_bytes();\\n            if name.len() <= existing_name.len() && existing_name[..name.len()] == *name {\\n                let next = existing_name[name.len()..].iter().copied().next();\\n                if let Some(next) = next {\\n                    u8set.insert(next);\\n                } else {\\n                    is_complete = true;\\n                }\\n            }\\n        }\\n        (u8set, is_complete)\\n    }\\n\\n    pub fn push_name(&mut self, name: &[u8]) {\\n        let name: &str = std::str::from_utf8(name).unwrap();\\n        assert!(!self.contains(&name));\\n        self.pos.insert(name.to_string());\\n    }\\n\\n    pub fn pop_name(&mut self, name: &[u8]) {\\n        let name: &str = std::str::from_utf8(name).unwrap();\\n        assert!(self.contains(&name), \\\"{:?} not in {:?}\\\", name, self);\\n        self.pos.remove(name);\\n    }\\n}\\n\\nimpl FrameStack {\\n    pub fn contains_prefix_str(&self, name_prefix: &str) -> bool {\\n        self.frames.iter().any(|frame| frame.contains_prefix(name_prefix))\\n    }\\n\\n    pub fn contains_str(&self, name: &str) -> bool {\\n        self.frames.iter().any(|frame| frame.contains(name))\\n    }\\n\\n    pub fn next_u8_given_contains_u8slice(&self, name: &[u8]) -> (U8Set, bool) {\\n        let mut u8set = U8Set::none();\\n        let mut is_complete = false;\\n        for frame in self.frames.iter().rev() {\\n            let (frame_u8set, frame_is_complete) = frame.next_u8_given_contains(name);\\n            u8set |= frame_u8set;\\n            is_complete |= frame_is_complete;\\n        }\\n        (u8set, is_complete)\\n    }\\n\\n    pub fn contains_prefix_u8vec(&self, name_prefix: &[u8]) -> bool {\\n        self.contains_prefix_str(std::str::from_utf8(name_prefix).unwrap())\\n    }\\n\\n    pub fn contains_u8vec(&self, name: &[u8]) -> bool {\\n        self.contains_str(std::str::from_utf8(name).unwrap())\\n    }\\n\\n    pub fn push_frame(&mut self, new_frame: Frame) {\\n        self.frames.push(new_frame);\\n    }\\n\\n    pub fn push_empty_frame(&mut self) {\\n        self.push_frame(Frame::default());\\n    }\\n\\n    pub fn push_name(&mut self, name: &[u8]) {\\n        self.frames.last_mut().unwrap().push_name(name);\\n    }\\n\\n    pub fn pop_name(&mut self, name: &[u8]) {\\n        self.frames.last_mut().unwrap().pop_name(name);\\n    }\\n\\n    pub fn pop(&mut self) {\\n        self.frames.pop();\\n    }\\n\\n    pub fn filter(&mut self, predicate: impl Fn(&Frame) -> bool) {\\n        self.frames.retain(predicate);\\n    }\\n\\n    pub fn filter_contains(&mut self, name: &[u8]) {\\n        let name = std::str::from_utf8(name).unwrap();\\n        self.filter(|frame| frame.contains(name));\\n    }\\n\\n    pub fn filter_excludes(&mut self, name: &[u8]) {\\n        let name = std::str::from_utf8(name).unwrap();\\n        self.filter(|frame| !frame.contains(name));\\n    }\\n}\\n\\nimpl std::ops::BitOr for Frame {\\n    type Output = Frame;\\n\\n    fn bitor(self, other: Self) -> Frame {\\n        Frame { pos: self.pos.union(&other.pos).cloned().collect() }\\n    }\\n}\\n\\nimpl std::ops::BitOr for FrameStack {\\n    type Output = FrameStack;\\n\\n    fn bitor(self, other: Self) -> FrameStack {\\n        let new_frames = self.frames.iter()\\n            .zip(other.frames.iter())\\n            .map(|(f1, f2)| f1.clone() | f2.clone())\\n            .collect();\\n\\n        FrameStack {\\n            frames: new_frames,\\n        }\\n    }\\n}\", \"src/_01_parse_state/mod.rs\": \"pub use parse_results::*;\\npub use right_data::*;\\npub use traits::*;\\n\\nmod parse_results;\\nmod right_data;\\nmod traits;\", \"src/_01_parse_state/parse_results.rs\": \"use crate::internal_vec::VecY;\\nuse crate::{vecy, Fields1, Fields2, RightData, RightDataGetters};\\n\\n#[derive(Debug, Clone, PartialEq, Eq, Hash)]\\npub struct UpData<Output> {\\n    right_data: RightData,\\n    output: Output,\\n}\\n\\n#[derive(Debug, Clone, PartialEq, Eq, Hash)]\\npub struct OneShotUpData<Output> {\\n    right_data: RightData,\\n    output: Output,\\n}\\n\\n#[derive(Debug, Clone, PartialEq, Eq, Hash)]\\npub struct ParseResults<Output> {\\n    pub up_data_vec: VecY<UpData<Output>>,\\n    pub done: bool,\\n}\\n\\n#[derive(Debug, Clone, PartialEq, Eq, Hash)]\\npub enum UnambiguousParseError {\\n    Incomplete,\\n    Ambiguous,\\n    Fail,\\n}\\n\\n#[derive(Debug, Clone, PartialEq, Eq, Hash)]\\npub enum ActuallyUnambiguousParseError {\\n    Incomplete,\\n    Fail,\\n}\\n\\npub type UnambiguousParseResults<Output> = Result<OneShotUpData<Output>, UnambiguousParseError>;\\n\\npub trait ParseResultTrait<Output> {\\n    fn done(&self) -> bool;\\n    fn succeeds_decisively(&self) -> bool;\\n    fn merge_assign(&mut self, p0: Self) where Self: Sized;\\n    fn merge(self, p0: Self) -> Self where Self: Sized;\\n    fn combine_seq(&mut self, p0: Self) where Self: Sized;\\n    fn new(up_data_vec: VecY<UpData<Output>>, done: bool) -> Self where Self: Sized;\\n    fn new_single(up_data_vec: UpData<Output>, done: bool) -> Self where Self: Sized;\\n    fn empty(done: bool) -> Self where Self: Sized;\\n    fn empty_unfinished() -> Self where Self: Sized;\\n    fn empty_finished() -> Self where Self: Sized;\\n}\\n\\nimpl<Output> From<ParseResults<Output>> for UnambiguousParseResults<Output> {\\n    fn from(value: ParseResults<Output>) -> Self {\\n        if !value.done() {\\n            return Err(UnambiguousParseError::Incomplete);\\n        }\\n        match value.up_data_vec.as_slice() {\\n            [] => Err(UnambiguousParseError::Fail),\\n            [up_data] => Ok(OneShotUpData { right_data: up_data.right_data.clone(), output: up_data.output.clone() }),\\n            [_, _, ..] => Err(UnambiguousParseError::Ambiguous),\\n        }\\n    }\\n}\\n\\nimpl<Output> ParseResultTrait<Output> for ParseResults<Output> {\\n    fn done(&self) -> bool {\\n        self.done\\n    }\\n    fn succeeds_decisively(&self) -> bool {\\n        self.done() && !self.up_data_vec.is_empty() && !self.up_data_vec.iter().any(|rd| rd.right_data.failable())\\n        // TODO: remove the below line and uncomment the above line\\n        // self.done() && !self.up_data_vec.is_empty()\\n    }\\n    fn new(up_data_vec: VecY<UpData<Output>>, done: bool) -> Self {\\n        ParseResults {\\n            up_data_vec,\\n            done,\\n        }\\n    }\\n    fn new_single(up_data: UpData<Output>, done: bool) -> Self {\\n        ParseResults {\\n            up_data_vec: vecy![up_data],\\n            done,\\n        }\\n    }\\n    fn empty(done: bool) -> Self {\\n        ParseResults {\\n            up_data_vec: VecY::new(),\\n            done,\\n        }\\n    }\\n    fn empty_unfinished() -> Self {\\n        ParseResults::empty(false)\\n    }\\n    fn empty_finished() -> Self {\\n        ParseResults::empty(true)\\n    }\\n    fn merge_assign(&mut self, mut p0: ParseResults<Output>) {\\n        self.up_data_vec.append(&mut p0.up_data_vec);\\n        self.done &= p0.done();\\n    }\\n    fn merge(mut self, p0: ParseResults<Output>) -> Self {\\n        self.merge_assign(p0);\\n        self\\n    }\\n    fn combine_seq(&mut self, mut p0: ParseResults<Output>) {\\n        self.up_data_vec.append(&mut p0.up_data_vec);\\n        self.done |= p0.done();\\n    }\\n}\\n\\nimpl<Output> ParseResultTrait<Output> for UnambiguousParseResults<Output> {\\n    fn done(&self) -> bool {\\n        match self {\\n            Ok(_) => true,\\n            Err(UnambiguousParseError::Incomplete) => false,\\n            Err(UnambiguousParseError::Ambiguous) => true,\\n            Err(UnambiguousParseError::Fail) => true,\\n        }\\n    }\\n    fn succeeds_decisively(&self) -> bool {\\n        self.is_ok()\\n    }\\n    fn new(up_data_vec: VecY<UpData<Output>>, done: bool) -> Self {\\n        match (up_data_vec.len(), done) {\\n            (1, true) => Ok(OneShotUpData { right_data: up_data_vec[0].right_data.clone(), output: up_data_vec[0].output.clone() }),\\n            (1, false) => Err(UnambiguousParseError::Incomplete),\\n            _ => Err(UnambiguousParseError::Ambiguous),\\n        }\\n    }\\n    fn new_single(up_data: UpData<Output>, done: bool) -> Self {\\n        Self::new(vecy![up_data], done)\\n    }\\n    fn empty(done: bool) -> Self {\\n        if done {\\n            Err(UnambiguousParseError::Fail)\\n        } else {\\n            Err(UnambiguousParseError::Incomplete)\\n        }\\n    }\\n    fn empty_unfinished() -> Self {\\n        Err(UnambiguousParseError::Incomplete)\\n    }\\n    fn empty_finished() -> Self {\\n        Err(UnambiguousParseError::Fail)\\n    }\\n    fn merge_assign(&mut self, p0: Self) {\\n        // This is a bit of a hack, but it should work\\n        *self = self.clone().merge(p0);\\n    }\\n    fn merge(self, p0: Self) -> Self {\\n        match (self, p0) {\\n            (Ok(up_data1), Ok(up_data2)) => {\\n                if up_data1 == up_data2 {\\n                    Ok(up_data1)\\n                } else {\\n                    Err(UnambiguousParseError::Ambiguous)\\n                }\\n            },\\n            (Ok(up_data), Err(UnambiguousParseError::Incomplete)) => Ok(up_data),\\n            (Err(UnambiguousParseError::Incomplete), Ok(up_data)) => Ok(up_data),\\n            (Err(UnambiguousParseError::Incomplete), Err(UnambiguousParseError::Incomplete)) => Err(UnambiguousParseError::Incomplete),\\n            (Err(e), _) => Err(e),\\n            (_, Err(e)) => Err(e),\\n        }\\n    }\\n    fn combine_seq(&mut self, p0: Self) {\\n        // This is a bit of a hack, but it should work\\n        *self = self.clone().merge(p0);\\n    }\\n}\\n\\nimpl<Output> UpData<Output> {\\n    pub fn new(right_data: RightData, output: Output) -> Self {\\n        Self { right_data, output }\\n    }\\n}\\n\\nimpl<Output> OneShotUpData<Output> {\\n    pub fn new(right_data: RightData, output: Output) -> Self {\\n        Self { right_data, output }\\n    }\\n}\\n\\nimpl<Output: RightDataGetters> RightDataGetters for UpData<Output> {\\n    fn get_fields1(&self) -> &Fields1 { self.right_data.get_fields1() }\\n    fn get_fields1_mut(&mut self) -> &mut Fields1 { self.right_data.get_fields1_mut() }\\n    fn get_fields2(&self) -> &Fields2 { self.right_data.get_fields2() }\\n    fn get_fields2_mut(&mut self) -> &mut Fields2 { self.right_data.get_fields2_mut() }\\n    fn just_right_data(self) -> RightData { self.right_data }\\n}\\n\\nimpl<Output: RightDataGetters> RightDataGetters for OneShotUpData<Output> {\\n    fn get_fields1(&self) -> &Fields1 { self.right_data.get_fields1() }\\n    fn get_fields1_mut(&mut self) -> &mut Fields1 { self.right_data.get_fields1_mut() }\\n    fn get_fields2(&self) -> &Fields2 { self.right_data.get_fields2() }\\n    fn get_fields2_mut(&mut self) -> &mut Fields2 { self.right_data.get_fields2_mut() }\\n    fn just_right_data(self) -> RightData { self.right_data }\\n}\", \"src/_01_parse_state/right_data.rs\": \"use derivative::Derivative;\\nuse std::rc::Rc;\\n\\nuse crate::internal_vec::VecZ;\\nuse crate::{ForbidFollowsData, LookaheadData, PythonQuoteType};\\n\\n#[repr(packed(1))]\\n#[derive(Debug, Clone, Copy, Hash, PartialEq, Eq)]\\npub struct Fields1 {\\n    pub lookahead_data: LookaheadData,\\n    pub position: usize,\\n    pub forbidden_consecutive_matches: ForbidFollowsData,\\n    pub dedents: u8,\\n    pub scope_count: u8\\n}\\n\\n#[derive(Debug, Clone, PartialEq, Eq)]\\npub struct Fields2 {\\n    // #[derivative(Hash = \\\"ignore\\\")]\\n    // pub frame_stack: Option<FrameStack>,\\n    pub indents: VecZ<Vec<u8>>,\\n    pub fstring_start_stack: VecZ<PythonQuoteType>\\n}\\n\\n#[derive(Derivative)]\\n#[derivative(Debug, Clone, Hash, PartialEq, Eq)]\\npub struct RightDataInner {\\n    fields1: Fields1,\\n    #[derivative(Hash = \\\"ignore\\\")]\\n    fields2: Rc<Fields2>,\\n    // pub fields2: Box<Fields2>,\\n    // pub fields2: Fields2,\\n}\\n\\n#[derive(Derivative)]\\n#[derivative(Debug, Clone, Hash, PartialEq, Eq)]\\npub struct RightData {\\n    right_data_inner: Rc<RightDataInner>,\\n    // pub right_data_inner: Box<RightDataInner>,\\n    // pub right_data_inner: RightDataInner,\\n}\\n\\nimpl Default for RightData {\\n    fn default() -> Self {\\n        // Print the size of RightDataInner\\n        println!(\\\"RightDataInner size: {}\\\", std::mem::size_of::<RightDataInner>());\\n        Self {\\n            right_data_inner: RightDataInner {\\n                // frame_stack: None,\\n                fields2: Fields2 { indents: VecZ::new(), fstring_start_stack: VecZ::new() }.into(),\\n                fields1: Fields1 { dedents: 0, scope_count: 0, forbidden_consecutive_matches: ForbidFollowsData::default(), lookahead_data: LookaheadData::default(), position: 0 },\\n            }.into()\\n        }\\n    }\\n}\\n\\nimpl RightData {\\n    pub fn advance(&mut self, n: usize) {\\n        self.get_inner_mut().fields1.position += n;\\n    }\\n\\n    pub fn with_position(mut self, position: usize) -> Self {\\n        self.get_inner_mut().fields1.position = position;\\n        self\\n    }\\n\\n    pub fn failable(&self) -> bool {\\n        self.right_data_inner.fields1.lookahead_data.has_omitted_partial_lookaheads\\n    }\\n\\n    pub fn get_inner_mut(&mut self) -> &mut RightDataInner {\\n        Rc::make_mut(&mut self.right_data_inner)\\n        // &mut *self.right_data_inner\\n        // &mut self.right_data_inner\\n    }\\n}\\n\\npub trait RightDataGetters {\\n    fn get_fields1(&self) -> &Fields1;\\n    fn get_fields1_mut(&mut self) -> &mut Fields1;\\n    fn get_fields2(&self) -> &Fields2;\\n    fn get_fields2_mut(&mut self) -> &mut Fields2;\\n    fn just_right_data(self) -> RightData;\\n}\\n\\nimpl RightDataGetters for RightDataInner {\\n    fn get_fields1(&self) -> &Fields1 {\\n        &self.fields1\\n    }\\n\\n    fn get_fields1_mut(&mut self) -> &mut Fields1 {\\n        &mut self.fields1\\n    }\\n\\n    fn get_fields2(&self) -> &Fields2 {\\n        &self.fields2\\n    }\\n\\n    fn get_fields2_mut(&mut self) -> &mut Fields2 {\\n        Rc::make_mut(&mut self.fields2)\\n        // &mut *self.fields2\\n        // &mut self.fields2\\n    }\\n\\n    fn just_right_data(self) -> RightData {\\n        RightData { right_data_inner: Rc::new(self) }\\n    }\\n}\\n\\nimpl RightDataGetters for RightData {\\n    fn get_fields1(&self) -> &Fields1 {\\n        self.right_data_inner.get_fields1()\\n    }\\n\\n    fn get_fields1_mut(&mut self) -> &mut Fields1 {\\n        Rc::make_mut(&mut self.right_data_inner).get_fields1_mut()\\n    }\\n\\n    fn get_fields2(&self) -> &Fields2 {\\n        self.right_data_inner.get_fields2()\\n    }\\n\\n    fn get_fields2_mut(&mut self) -> &mut Fields2 {\\n        Rc::make_mut(&mut self.right_data_inner).get_fields2_mut()\\n    }\\n\\n    fn just_right_data(self) -> RightData {\\n        RightData { right_data_inner: self.right_data_inner }\\n    }\\n}\"} "
    },
    {
      "role": "user",
      "content": "/generate src/_01_parse_state/traits.rs src/_02_traits/combinator.rs src/_02_traits/convert.rs"
    },
    {
      "role": "model",
      "content": "{\"src/_01_parse_state/traits.rs\": \"use crate::{RightData, RightDataGetters};\\nuse crate::{profile, LookaheadData, ParseResultTrait, ParseResults, UpData, VecY};\\nuse std::collections::{HashMap, HashSet};\\nuse std::hash::{Hash, Hasher};\\n\\n// macro_rules! profile {\\n//     ($tag:expr, $body:expr) => {{\\n//         $crate::profile!($tag, $body)\\n//     }};\\n// }\\n\\n// macro_rules! profile {\\n//     ($tag:expr, $body:expr) => {{\\n//         $body\\n//     }};\\n// }\\n\\nconst SQUASH_THRESHOLD: usize = 1;\\n\\npub trait Squash {\\n    type Output;\\n    fn squashed(self) -> Self::Output;\\n    fn squash(&mut self);\\n}\\n\\nimpl<Output: Clone> Squash for VecY<UpData<Output>> {\\n    type Output = VecY<UpData<Output>>;\\n    fn squashed(self) -> Self::Output {\\n        if self.len() > SQUASH_THRESHOLD {\\n            profile!(\\\"RightDataSquasher::squashed\\\", {\\n                // let mut squasher = RightDataSquasher::new();\\n                // squasher.extend(self.into_iter());\\n                // squasher.finish()\\n                self.into_iter().collect::<HashSet<_>>().into_iter().collect()\\n            })\\n        } else {\\n            self\\n        }\\n    }\\n    fn squash(&mut self) {\\n        if self.len() > SQUASH_THRESHOLD {\\n            *self = self.drain(..).collect::<VecY<UpData<Output>>>().squashed()\\n        }\\n    }\\n}\\n\\nimpl<Output: Clone> Squash for ParseResults<Output> {\\n    type Output = ParseResults<Output>;\\n    fn squashed(self) -> Self::Output {\\n        if self.up_data_vec.len() > SQUASH_THRESHOLD {\\n            profile!(\\\"ParseResults::squashed\\\", {\\n                    let done = self.done();\\n                    ParseResults::new(self.up_data_vec.squashed(), done)\\n                }\\n            )\\n        } else {\\n            self\\n        }\\n    }\\n    fn squash(&mut self) {\\n        profile!(\\\"ParseResults::squash\\\", {\\n        if self.up_data_vec.len() > SQUASH_THRESHOLD {\\n            // *self.right_data_vec = std::mem::take(&mut self.right_data_vec).squashed();\\n            *self = self.clone().squashed();\\n        }\\n            })\\n    }\\n}\\n\\n#[derive(Debug, Default, Clone, PartialEq, Eq)]\\npub struct RightDataSquasher<Output: Clone> {\\n    decomposed: HashMap<RightData, LookaheadData>,\\n    output_squasher: OutputSquasher<Output>,\\n}\\n\\nimpl<Output: Clone> Hash for RightDataSquasher<Output> {\\n    fn hash<H: Hasher>(&self, state: &mut H) {\\n        self.decomposed.len().hash(state);\\n    }\\n}\\n\\nimpl<Output: Clone> RightDataSquasher<Output> {\\n    pub fn new() -> Self {\\n        Self {\\n            decomposed: HashMap::new(),\\n            output_squasher: OutputSquasher::new(),\\n        }\\n    }\\n\\n    pub fn push(&mut self, mut right_data: RightData, output: Output) {\\n        let lookahead_data = std::mem::take(&mut right_data.get_inner_mut().get_fields1_mut().lookahead_data);\\n        let mut existing_lookahead_data = self.decomposed.entry(right_data).or_insert_with_key(|_| lookahead_data.clone());\\n        // TODO: In general, all the lookaheads needs to be satisfied, i.e. it's an AND operation between Vecs of lookaheads. But this implies OR.\\n        existing_lookahead_data.has_omitted_partial_lookaheads &= lookahead_data.has_omitted_partial_lookaheads;\\n        self.output_squasher.push(output);\\n    }\\n\\n    pub fn extend(&mut self, right_data_vec: impl IntoIterator<Item = (RightData, Output)>) {\\n        profile!(\\\"RightDataSquasher::extend\\\", {\\n        for (right_data, output) in right_data_vec {\\n            self.push(right_data, output);\\n        }\\n            })\\n    }\\n\\n    pub fn finish(self) -> VecY<UpData<Output>> {\\n        profile!(\\\"RightDataSquasher::finish\\\", {\\n            let mut result = VecY::new();\\n            for (mut right_data, lookahead_data) in self.decomposed {\\n                right_data.get_inner_mut().get_fields1_mut().lookahead_data = lookahead_data;\\n                result.push(UpData::new(right_data, self.output_squasher.pop()));\\n            }\\n            result\\n        })\\n    }\\n}\\n\\nimpl<Output: Clone> From<Vec<(RightData, Output)>> for RightDataSquasher<Output> {\\n    fn from(right_data_vec: Vec<(RightData, Output)>) -> Self {\\n        profile!(\\\"RightDataSquasher::from\\\", {\\n            let mut squasher = RightDataSquasher::new();\\n            squasher.extend(right_data_vec);\\n            squasher\\n        })\\n    }\\n}\\n\\nimpl<Output: Clone> RightDataSquasher<Output> {\\n    pub fn into_iter(self) -> RightDataSquasherIterator<Output> {\\n        RightDataSquasherIterator {\\n            inner: self.decomposed.into_iter()\\n        }\\n    }\\n}\\n\\npub struct RightDataSquasherIterator<Output: Clone> {\\n    inner: std::collections::hash_map::IntoIter<RightData, LookaheadData>,\\n    output_squasher: OutputSquasher<Output>,\\n}\\n\\nimpl<Output: Clone> Iterator for RightDataSquasherIterator<Output> {\\n    type Item = (RightData, LookaheadData, Output);\\n\\n    fn next(&mut self) -> Option<Self::Item> {\\n        self.inner.next().map(|(right_data, lookahead_data)| (right_data, lookahead_data, self.output_squasher.pop()))\\n    }\\n}\\n\\nimpl<Output: Clone> IntoIterator for RightDataSquasher<Output> {\\n    type Item = (RightData, LookaheadData, Output);\\n    type IntoIter = RightDataSquasherIterator<Output>;\\n\\n    fn into_iter(self) -> Self::IntoIter {\\n        self.into_iter()\\n    }\\n}\\n\\npub struct RightDataSquasherIteratorMut<'a, Output: Clone> {\\n    inner: std::collections::hash_map::IterMut<'a, RightData, LookaheadData>,\\n    output_squasher: &'a mut OutputSquasher<Output>,\\n}\\n\\nimpl<'a, Output: Clone> Iterator for RightDataSquasherIteratorMut<'a, Output> {\\n    type Item = (&'a RightData, &'a mut LookaheadData, Output);\\n\\n    fn next(&mut self) -> Option<Self::Item> {\\n        self.inner.next().map(|(right_data, lookahead_data)| (right_data, lookahead_data, self.output_squasher.pop()))\\n    }\\n}\\n\\nimpl<Output: Clone> RightDataSquasher<Output> {\\n    pub fn iter(&self) -> RightDataSquasherIterator<Output> {\\n        RightDataSquasherIterator {\\n            inner: self.decomposed.clone().into_iter()\\n        }\\n    }\\n\\n    pub fn iter_mut(&mut self) -> RightDataSquasherIteratorMut<Output> {\\n        RightDataSquasherIteratorMut {\\n            inner: self.decomposed.iter_mut(),\\n            output_squasher: &mut self.output_squasher\\n        }\\n    }\\n\\n    pub fn is_empty(&self) -> bool {\\n        self.decomposed.is_empty()\\n    }\\n\\n    pub fn len(&self) -> usize {\\n        self.decomposed.len()\\n    }\\n\\n    pub fn clear(&mut self) {\\n        self.decomposed.clear();\\n    }\\n\\n    pub fn append(&mut self, right_data_squasher: &mut RightDataSquasher<Output>) {\\n        profile!(\\\"RightDataSquasher::append\\\", {\\n        for (right_data, _, output) in right_data_squasher.decomposed.drain() {\\n            self.push(right_data, output);\\n        }\\n            })\\n    }\\n\\n    pub fn retain(&mut self, f: impl Fn(&RightData) -> bool) {\\n        self.decomposed.retain(|right_data, _| f(right_data));\\n    }\\n}\\n\\n#[derive(Debug, Default, Clone, PartialEq, Eq)]\\npub struct OutputSquasher<Output: Clone> {\\n    outputs: Vec<Output>,\\n}\\n\\nimpl<Output: Clone> OutputSquasher<Output> {\\n    pub fn new() -> Self {\\n        Self {\\n            outputs: Vec::new(),\\n        }\\n    }\\n\\n    pub fn push(&mut self, output: Output) {\\n        self.outputs.push(output);\\n    }\\n\\n    pub fn pop(&mut self) -> Output {\\n        self.outputs.pop().unwrap()\\n    }\\n}\\n\\npub trait OutputTrait: Clone + PartialEq + Eq + std::fmt::Debug + std::hash::Hash {}\\n\\nimpl<T: Clone + PartialEq + Eq + std::fmt::Debug + std::hash::Hash> OutputTrait for T {}\\n\\npub trait ParseResultTrait<Output: OutputTrait> {\\n    fn done(&self) -> bool;\\n    fn succeeds_decisively(&self) -> bool;\\n    fn merge_assign(&mut self, p0: Self) where Self: Sized;\\n    fn merge(self, p0: Self) -> Self where Self: Sized;\\n    fn combine_seq(&mut self, p0: Self) where Self: Sized;\\n    fn new(up_data_vec: VecY<UpData<Output>>, done: bool) -> Self where Self: Sized;\\n    fn new_single(up_data_vec: UpData<Output>, done: bool) -> Self where Self: Sized;\\n    fn empty(done: bool) -> Self where Self: Sized;\\n    fn empty_unfinished() -> Self where Self: Sized;\\n    fn empty_finished() -> Self where Self: Sized;\\n}\\n\\npub trait CombinatorTrait: BaseCombinatorTrait + DynCombinatorTrait + std::fmt::Debug {\\n    type Parser<'a>: ParserTrait<Self::Output> where Self: 'a;\\n    type Output: OutputTrait;\\n\\n    fn old_parse<'a, 'b>(&'a self, right_data: RightData, bytes: &'b [u8]) -> (Self::Parser<'a>, ParseResults<Self::Output>) where Self::Output: 'b;\\n    fn parse<'a, 'b>(&'a self, right_data: RightData, bytes: &'b [u8]) -> (Self::Parser<'a>, ParseResults<Self::Output>) where Self::Output: 'b {\\n        self.old_parse(right_data, bytes)\\n    }\\n    fn one_shot_parse<'b>(&self, right_data: RightData, bytes: &'b [u8]) -> UnambiguousParseResults<Self::Output> where Self::Output: 'b;\\n}\\n\\npub trait DynCombinatorTrait: BaseCombinatorTrait + std::fmt::Debug {\\n    fn parse_dyn<'a, 'b>(&'a self, right_data: RightData, bytes: &'b [u8]) -> (Box<dyn ParserTrait<Self::Output> + 'a>, ParseResults<Self::Output>) where Self::Output: 'b;\\n    fn one_shot_parse_dyn<'a, 'b>(&'a self, right_data: RightData, bytes: &'b [u8]) -> UnambiguousParseResults<Self::Output> where Self::Output: 'b;\\n}\\n\\npub trait BaseCombinatorTrait {\\n    fn as_any(&self) -> &dyn std::any::Any where Self: 'static;\\n    fn type_name(&self) -> &str {\\n        std::any::type_name::<Self>()\\n    }\\n    fn apply_to_children(&self, f: &mut dyn FnMut(&dyn BaseCombinatorTrait)) {}\\n    fn compile(mut self) -> Self\\n    where\\n        Self: Sized\\n    {\\n        self.compile_inner();\\n        self\\n    }\\n    fn compile_inner(&self) {\\n        self.apply_to_children(&mut |combinator| combinator.compile_inner());\\n    }\\n}\\n\\npub fn dumb_one_shot_parse<T: CombinatorTrait>(combinator: &T, right_data: RightData, bytes: &[u8]) -> UnambiguousParseResults<T::Output> {\\n    let (parser, parse_results) = combinator.old_parse(right_data, bytes);\\n    UnambiguousParseResults::from(parse_results)\\n}\\n\\npub trait ParserTrait<Output: OutputTrait>: std::fmt::Debug {\\n    fn get_u8set(&self) -> U8Set;\\n    fn parse<'b>(&mut self, bytes: &'b [u8]) -> ParseResults<Output> where Output: 'b;\\n    fn autoparse(&mut self, right_data: RightData, max_length: usize) -> (Vec<u8>, ParseResults<Output>) {\\n        let mut prefix = Vec::new();\\n        let mut parse_results = ParseResults::empty_finished();\\n        while prefix.len() < max_length {\\n            let u8set = self.get_u8set();\\n            if u8set.len() == 1 {\\n                let c = u8set.iter().next().unwrap();\\n                let new_parse_results = self.parse(&[c]);\\n                parse_results.combine_seq(new_parse_results);\\n                prefix.push(c);\\n            } else {\\n                break;\\n            }\\n        }\\n        (prefix, parse_results)\\n    }\\n}\\n\\nimpl<T: DynCombinatorTrait + ?Sized> DynCombinatorTrait for Box<T> {\\n    fn parse_dyn<'a, 'b>(&'a self, right_data: RightData, bytes: &'b [u8]) -> (Box<dyn ParserTrait<Self::Output> + 'a>, ParseResults<Self::Output>) where Self::Output: 'b {\\n        (**self).parse_dyn(right_data, bytes)\\n    }\\n\\n    fn one_shot_parse_dyn<'a, 'b>(&'a self, right_data: RightData, bytes: &'b [u8]) -> UnambiguousParseResults<Self::Output> where Self::Output: 'b {\\n        (**self).one_shot_parse_dyn(right_data, bytes)\\n    }\\n}\\n\\nimpl<T: CombinatorTrait + ?Sized> CombinatorTrait for Box<T> {\\n    type Parser<'a> = T::Parser<'a> where Self: 'a;\\n    type Output = T::Output;\\n\\n    fn one_shot_parse<'b>(&self, right_data: RightData, bytes: &'b [u8]) -> UnambiguousParseResults<Self::Output> where Self::Output: 'b {\\n        (**self).one_shot_parse(right_data, bytes)\\n    }\\n\\n    fn old_parse<'a, 'b>(&self, right_data: RightData, bytes: &'b [u8]) -> (Self::Parser<'a>, ParseResults<Self::Output>) where Self::Output: 'b {\\n        (**self).old_parse(right_data, bytes)\\n    }\\n\\n    fn parse<'a, 'b>(&self, right_data: RightData, bytes: &'b [u8]) -> (Self::Parser<'a>, ParseResults<Self::Output>) where Self::Output: 'b {\\n        (**self).parse(right_data, bytes)\\n    }\\n\\n}\\n\\nimpl<T: BaseCombinatorTrait + ?Sized> BaseCombinatorTrait for Box<T> {\\n    fn as_any(&self) -> &dyn std::any::Any where Self: 'static {\\n        (**self).as_any()\\n    }\\n    fn type_name(&self) -> &str {\\n        (**self).type_name()\\n    }\\n    fn apply_to_children(&self, f: &mut dyn FnMut(&dyn BaseCombinatorTrait)) {\\n        (**self).apply_to_children(f);\\n    }\\n    fn compile_inner(&self) {\\n        (**self).compile_inner();\\n    }\\n}\\n\\nimpl<'a> ParserTrait<Output> for Box<dyn ParserTrait<Output> + 'a> where Output: OutputTrait {\\n    fn get_u8set(&self) -> U8Set {\\n        (**self).get_u8set()\\n    }\\n\\n    fn parse<'b>(&mut self, bytes: &'b [u8]) -> ParseResults<Output> where Output: 'b {\\n        (**self).parse(bytes)\\n    }\\n}\\n\\nimpl<'b> CombinatorTrait for Box<dyn DynCombinatorTrait + 'b> {\\n    type Parser<'a> = Box<dyn ParserTrait<Self::Output> + 'a> where Self: 'a;\\n    type Output = Box<dyn std::any::Any>;\\n\\n    fn one_shot_parse<'b>(&self, right_data: RightData, bytes: &'b [u8]) -> UnambiguousParseResults<Self::Output> where Self::Output: 'b {\\n        (**self).one_shot_parse_dyn(right_data, bytes)\\n    }\\n\\n    fn old_parse<'a, 'b>(&self, right_data: RightData, bytes: &'b [u8]) -> (Self::Parser<'a>, ParseResults<Self::Output>) where Self::Output: 'b {\\n        (**self).parse_dyn(right_data, bytes)\\n    }\\n}\\n\\n// Removed ParserTrait implementation for Parser enum\\n\\npub trait CombinatorTraitExt: CombinatorTrait {\\n    fn parser(&self, right_data: RightData) -> (Self::Parser<'_>, ParseResults<Self::Output>) {\\n        self.old_parse(right_data, &[])\\n    }\\n}\\n\\npub trait ParserTraitExt: ParserTrait<Output> where Output: OutputTrait {\\n    fn step(&mut self, c: u8) -> ParseResults<Output> {\\n        self.parse(&[c])\\n    }\\n}\\n\\nimpl<T: CombinatorTrait> CombinatorTraitExt for T {}\\nimpl<T: ParserTrait<Output>> ParserTraitExt for T where Output: OutputTrait {}\", \"src/_02_traits/combinator.rs\": \"\\n// src/_02_traits/combinator.rs\\nuse crate::{ParseResultTrait, ParseResults, RightData, RightDataGetters, U8Set, UnambiguousParseResults, UpData, OneShotUpData};\\nuse std::fmt::Display;\\n\\n#[macro_export]\\nmacro_rules! match_enum {\\n    ($expr:expr, $enum:ident, $inner:ident => $arm:expr, $($variant:ident),*) => {\\n        match $expr {\\n            $(\\n                $enum::$variant($inner) => $arm,\\n            )*\\n        }\\n    };\\n}\\n\\n// Removed Parser enum\\npub trait CombinatorTrait: BaseCombinatorTrait + DynCombinatorTrait + std::fmt::Debug {\\n    type Parser<'a>: ParserTrait<Self::Output> where Self: 'a;\\n    type Output: OutputTrait;\\n\\n    fn old_parse<'a, 'b>(&'a self, right_data: RightData, bytes: &'b [u8]) -> (Self::Parser<'a>, ParseResults<Self::Output>) where Self::Output: 'b;\\n    fn parse<'a, 'b>(&'a self, right_data: RightData, bytes: &'b [u8]) -> (Self::Parser<'a>, ParseResults<Self::Output>) where Self::Output: 'b {\\n        self.old_parse(right_data, bytes)\\n    }\\n    fn one_shot_parse<'b>(&self, right_data: RightData, bytes: &'b [u8]) -> UnambiguousParseResults<Self::Output> where Self::Output: 'b;\\n}\\n\\npub trait DynCombinatorTrait: BaseCombinatorTrait + std::fmt::Debug {\\n    fn parse_dyn<'a, 'b>(&'a self, right_data: RightData, bytes: &'b [u8]) -> (Box<dyn ParserTrait<Self::Output> + 'a>, ParseResults<Self::Output>) where Self::Output: 'b;\\n    fn one_shot_parse_dyn<'a, 'b>(&'a self, right_data: RightData, bytes: &'b [u8]) -> UnambiguousParseResults<Self::Output> where Self::Output: 'b;\\n}\\n\\npub trait BaseCombinatorTrait {\\n    fn as_any(&self) -> &dyn std::any::Any where Self: 'static;\\n    fn type_name(&self) -> &str {\\n        std::any::type_name::<Self>()\\n    }\\n    fn apply_to_children(&self, f: &mut dyn FnMut(&dyn BaseCombinatorTrait)) {}\\n    fn compile(mut self) -> Self\\n    where\\n        Self: Sized\\n    {\\n        self.compile_inner();\\n        self\\n    }\\n    fn compile_inner(&self) {\\n        self.apply_to_children(&mut |combinator| combinator.compile_inner());\\n    }\\n}\\n\\npub fn dumb_one_shot_parse<T: CombinatorTrait>(combinator: &T, right_data: RightData, bytes: &[u8]) -> UnambiguousParseResults<T::Output> {\\n    let (parser, parse_results) = combinator.old_parse(right_data, bytes);\\n    UnambiguousParseResults::from(parse_results)\\n}\\n\\npub trait ParserTrait<Output: OutputTrait>: std::fmt::Debug {\\n    fn get_u8set(&self) -> U8Set;\\n    fn parse<'b>(&mut self, bytes: &'b [u8]) -> ParseResults<Output> where Output: 'b;\\n    fn autoparse(&mut self, right_data: RightData, max_length: usize) -> (Vec<u8>, ParseResults<Output>) {\\n        let mut prefix = Vec::new();\\n        let mut parse_results = ParseResults::empty_finished();\\n        while prefix.len() < max_length {\\n            let u8set = self.get_u8set();\\n            if u8set.len() == 1 {\\n                let c = u8set.iter().next().unwrap();\\n                let new_parse_results = self.parse(&[c]);\\n                parse_results.combine_seq(new_parse_results);\\n                prefix.push(c);\\n            } else {\\n                break;\\n            }\\n        }\\n        (prefix, parse_results)\\n    }\\n}\\n\\nimpl<T: DynCombinatorTrait + ?Sized> DynCombinatorTrait for Box<T> {\\n    fn parse_dyn<'a, 'b>(&'a self, right_data: RightData, bytes: &'b [u8]) -> (Box<dyn ParserTrait<Self::Output> + 'a>, ParseResults<Self::Output>) where Self::Output: 'b {\\n        (**self).parse_dyn(right_data, bytes)\\n    }\\n\\n    fn one_shot_parse_dyn<'a, 'b>(&'a self, right_data: RightData, bytes: &'b [u8]) -> UnambiguousParseResults<Self::Output> where Self::Output: 'b {\\n        (**self).one_shot_parse_dyn(right_data, bytes)\\n    }\\n}\\n\\nimpl<T: CombinatorTrait + ?Sized> CombinatorTrait for Box<T> {\\n    type Parser<'a> = T::Parser<'a> where Self: 'a;\\n    type Output = T::Output;\\n\\n    fn one_shot_parse<'b>(&self, right_data: RightData, bytes: &'b [u8]) -> UnambiguousParseResults<Self::Output> where Self::Output: 'b {\\n        (**self).one_shot_parse(right_data, bytes)\\n    }\\n\\n    fn old_parse<'a, 'b>(&self, right_data: RightData, bytes: &'b [u8]) -> (Self::Parser<'a>, ParseResults<Self::Output>) where Self::Output: 'b {\\n        (**self).old_parse(right_data, bytes)\\n    }\\n\\n    fn parse<'a, 'b>(&self, right_data: RightData, bytes: &'b [u8]) -> (Self::Parser<'a>, ParseResults<Self::Output>) where Self::Output: 'b {\\n        (**self).parse(right_data, bytes)\\n    }\\n\\n}\\n\\nimpl<T: BaseCombinatorTrait + ?Sized> BaseCombinatorTrait for Box<T> {\\n    fn as_any(&self) -> &dyn std::any::Any where Self: 'static {\\n        (**self).as_any()\\n    }\\n    fn type_name(&self) -> &str {\\n        (**self).type_name()\\n    }\\n    fn apply_to_children(&self, f: &mut dyn FnMut(&dyn BaseCombinatorTrait)) {\\n        (**self).apply_to_children(f);\\n    }\\n    fn compile_inner(&self) {\\n        (**self).compile_inner();\\n    }\\n}\\n\\nimpl<'a> ParserTrait<Output> for Box<dyn ParserTrait<Output> + 'a> where Output: OutputTrait {\\n    fn get_u8set(&self) -> U8Set {\\n        (**self).get_u8set()\\n    }\\n\\n    fn parse<'b>(&mut self, bytes: &'b [u8]) -> ParseResults<Output> where Output: 'b {\\n        (**self).parse(bytes)\\n    }\\n}\\n\\nimpl<'b> CombinatorTrait for Box<dyn DynCombinatorTrait + 'b> {\\n    type Parser<'a> = Box<dyn ParserTrait<Self::Output> + 'a> where Self: 'a;\\n    type Output = Box<dyn std::any::Any>;\\n\\n    fn one_shot_parse<'b>(&self, right_data: RightData, bytes: &'b [u8]) -> UnambiguousParseResults<Self::Output> where Self::Output: 'b {\\n        (**self).one_shot_parse_dyn(right_data, bytes)\\n    }\\n\\n    fn old_parse<'a, 'b>(&self, right_data: RightData, bytes: &'b [u8]) -> (Self::Parser<'a>, ParseResults<Self::Output>) where Self::Output: 'b {\\n        (**self).parse_dyn(right_data, bytes)\\n    }\\n}\\n\\n// Removed ParserTrait implementation for Parser enum\\n\\npub trait CombinatorTraitExt: CombinatorTrait {\\n    fn parser(&self, right_data: RightData) -> (Self::Parser<'_>, ParseResults<Self::Output>) {\\n        self.old_parse(right_data, &[])\\n    }\\n}\\n\\npub trait ParserTraitExt: ParserTrait<Output> where Output: OutputTrait {\\n    fn step(&mut self, c: u8) -> ParseResults<Output> {\\n        self.parse(&[c])\\n    }\\n}\\n\\nimpl<T: CombinatorTrait> CombinatorTraitExt for T {}\\nimpl<T: ParserTrait<Output>> ParserTraitExt for T where Output: OutputTrait {}\", \"src/_02_traits/convert.rs\": \"use crate::tokenizer::finite_automata::Expr;\\n// src/convert.rs\\nuse crate::{fast_combinator, CombinatorTrait, DynCombinatorTrait, FastCombinatorWrapper, StrongRef, Symbol};\\n\\npub trait IntoCombinator {\\n    type Output: CombinatorTrait;\\n    fn into_combinator(self) -> Self::Output;\\n}\\n\\nimpl<T: CombinatorTrait> IntoCombinator for T {\\n    type Output = Self;\\n    fn into_combinator(self) -> Self::Output {\\n        self\\n    }\\n}\\n\\n// impl<T: IntoCombinator, F: Fn() -> T> IntoCombinator for F {\\n//     type Output = T::Output;\\n//     fn into_combinator(self) -> Self::Output {\\n//         self().into_combinator()\\n//     }\\n// }\\n\\nimpl<T: CombinatorTrait> IntoCombinator for &Symbol<T> {\\n    type Output = Symbol<T>;\\n    fn into_combinator(self) -> Self::Output {\\n        self.clone()\\n    }\\n}\\n\\nimpl<T: CombinatorTrait> IntoCombinator for &StrongRef<T> {\\n    type Output = StrongRef<T>;\\n    fn into_combinator(self) -> Self::Output {\\n        self.clone()\\n    }\\n}\\n\\nimpl IntoCombinator for Expr {\\n    type Output = FastCombinatorWrapper;\\n    fn into_combinator(self) -> Self::Output {\\n        fast_combinator(self)\\n    }\\n}\\n\\npub trait IntoDyn<'a> {\\n    fn into_dyn(self) -> Box<dyn DynCombinatorTrait + 'a>;\\n}\\n\\nimpl<'a, T: CombinatorTrait + 'a> IntoDyn<'a> for T {\\n    fn into_dyn(self) -> Box<dyn DynCombinatorTrait + 'a> {\\n        Box::new(self)\\n    }\\n}\"} "
    },
    {
      "role": "user",
      "content": "/generate src/_03_combinators/cache.rs"
    },
    {
      "role": "model",
      "content": "{\"src/_03_combinators/cache.rs\": \"use crate::RightData;\\n// src/combinators/cache.rs\\n// src/combinators/cache.rs\\nuse crate::{BaseCombinatorTrait, DynCombinatorTrait, UnambiguousParseResults, UpData, OneShotUpData};\\nuse std::cell::RefCell;\\nuse std::collections::HashMap;\\nuse std::hash::{Hash, Hasher};\\nuse std::intrinsics::transmute;\\nuse std::num::NonZeroUsize;\\nuse std::rc::Rc;\\n\\nuse crate::{count_hit, profile, profile_internal, CombinatorTrait, IntoCombinator, ParseResultTrait, ParseResults, ParserTrait, Squash, U8Set};\\nuse derivative::Derivative;\\nuse lru::LruCache;\\n\\n\\n// macro_rules! profile {\\n//     ($tag:expr, $body:expr) => {{\\n//         $body\\n//     }};\\n// }\\n\\n// macro_rules! count_hit { ($tag:expr) => {} }\\n\\nthread_local! {\\n    pub static GLOBAL_CACHE: RefCell<GlobalCache> = RefCell::new(GlobalCache::new());\\n}\\n\\n#[derive(Debug)]\\nstruct GlobalCache {\\n    new_parsers: HashMap<usize, LruCache<CacheKey, Rc<RefCell<CacheEntry>>>>,\\n    pub(crate) entries: HashMap<usize, Vec<Rc<RefCell<CacheEntry>>>>,\\n    pub one_shot_results: HashMap<usize, LruCache<CacheKey, UnambiguousParseResults>>,\\n    pub(crate) parse_id_counter: usize,\\n    pub(crate) parse_id: Option<usize>,\\n}\\n\\nimpl GlobalCache {\\n    fn new() -> Self {\\n        Self {\\n            new_parsers: HashMap::new(),\\n            entries: HashMap::new(),\\n            one_shot_results: HashMap::new(),\\n            parse_id_counter: 0,\\n            parse_id: None,\\n        }\\n    }\\n\\n    fn cleanup(&mut self) {\\n        let parse_id = self.parse_id.take().unwrap();\\n        self.new_parsers.get_mut(&parse_id).unwrap().clear();\\n        self.entries.get_mut(&parse_id).unwrap().retain(|entry| !entry.borrow().maybe_parse_results.as_ref().unwrap().done());\\n    }\\n\\n    fn one_shot_cleanup(&mut self) {\\n        let parse_id = self.parse_id.take().unwrap();\\n        self.one_shot_results.get_mut(&parse_id).unwrap().clear();\\n    }\\n}\\n\\n#[derive(Debug)]\\nstruct CacheKey {\\n    combinator: *const dyn DynCombinatorTrait,\\n    right_data: RightData,\\n}\\n\\nimpl Hash for CacheKey {\\n    fn hash<H: Hasher>(&self, state: &mut H) {\\n        self.combinator.hash(state);\\n        self.right_data.hash(state);\\n    }\\n}\\n\\nimpl PartialEq for CacheKey {\\n    fn eq(&self, other: &Self) -> bool {\\n        self.combinator == other.combinator && self.right_data == other.right_data\\n    }\\n}\\n\\nimpl Eq for CacheKey {}\\n\\n#[derive(Derivative)]\\n#[derivative(Debug)]\\nstruct CacheEntry {\\n    pub(crate) parser: Option<Box<dyn ParserTrait>>,\\n    maybe_parse_results: Option<ParseResults>,\\n    maybe_u8set: Option<U8Set>,\\n}\\n\\n#[derive(Debug)]\\npub struct CacheContext<T: CombinatorTrait> {\\n    pub inner: T,\\n}\\n\\n#[derive(Debug)]\\npub struct Cached<T: CombinatorTrait> {\\n    pub inner: T,\\n}\\n\\n#[derive(Debug)]\\npub struct CachedParser {\\n    pub entry: Rc<RefCell<CacheEntry>>,\\n}\\n\\nimpl Hash for CachedParser {\\n    fn hash<H: Hasher>(&self, state: &mut H) {\\n        std::ptr::hash(self.entry.as_ref() as *const RefCell<CacheEntry>, state);\\n    }\\n}\\n\\nimpl PartialEq for CachedParser {\\n    fn eq(&self, other: &Self) -> bool {\\n        Rc::ptr_eq(&self.entry, &other.entry)\\n    }\\n}\\n\\n#[derive(Derivative)]\\n#[derivative(Debug)]\\npub struct CacheContextParser<'a> {\\n    pub inner: Box<dyn ParserTrait + 'a>,\\n    pub(crate) parse_id: usize,\\n}\\n\\nimpl<T: CombinatorTrait> DynCombinatorTrait for CacheContext<T> {\\n    fn parse_dyn<'a, 'b>(&'a self, right_data: RightData, bytes: &'b [u8]) -> (Box<dyn ParserTrait<Self::Output> + 'a>, ParseResults<Self::Output>) where Self::Output: 'b {\\n        let (parser, parse_results) = self.parse(right_data, bytes);\\n        (Box::new(parser), parse_results)\\n    }\\n\\n    fn one_shot_parse_dyn<'a, 'b>(&'a self, right_data: RightData, bytes: &'b [u8]) -> UnambiguousParseResults<Self::Output> where Self::Output: 'b {\\n        self.one_shot_parse(right_data, bytes)\\n    }\\n}\\n\\nimpl<T: CombinatorTrait> CombinatorTrait for CacheContext<T> {\\n    type Parser<'a> = CacheContextParser<'a> where Self: 'a;\\n    type Output = T::Output;\\n\\n    fn one_shot_parse<'b>(&self, right_data: RightData, bytes: &'b [u8]) -> UnambiguousParseResults<Self::Output> where Self::Output: 'b {\\n        profile!(\\\"CacheContext.one_shot_parse: start\\\", {\\n        GLOBAL_CACHE.with(|cache| {\\n            let parse_id = {\\n                let mut global_cache = cache.borrow_mut();\\n                let parse_id = global_cache.parse_id_counter;\\n                global_cache.new_parsers.insert(parse_id, LruCache::new(NonZeroUsize::new(64).unwrap()));\\n                global_cache.entries.insert(parse_id, Vec::new());\\n                global_cache.one_shot_results.insert(parse_id, LruCache::new(NonZeroUsize::new(64).unwrap()));\\n                global_cache.parse_id = Some(global_cache.parse_id_counter);\\n                global_cache.parse_id_counter += 1;\\n                parse_id\\n            };\\n            let parse_result = self.inner.one_shot_parse(right_data, bytes);\\n            let mut global_cache = cache.borrow_mut();\\n            global_cache.one_shot_cleanup();\\n            parse_result\\n        })\\n            })\\n    }\\n\\n    fn old_parse<'a, 'b>(&self, right_data: RightData, bytes: &'b [u8]) -> (Self::Parser<'a>, ParseResults<Self::Output>) where Self::Output: 'b {\\n        profile!(\\\"CacheContext.old_parse: start\\\", {\\n        GLOBAL_CACHE.with(|cache| {\\n            let parse_id = {\\n                let mut global_cache = cache.borrow_mut();\\n                let parse_id = global_cache.parse_id_counter;\\n                global_cache.new_parsers.insert(parse_id, LruCache::new(NonZeroUsize::new(64).unwrap()));\\n                global_cache.entries.insert(parse_id, Vec::new());\\n                global_cache.one_shot_results.insert(parse_id, LruCache::new(NonZeroUsize::new(64).unwrap()));\\n                global_cache.parse_id = Some(global_cache.parse_id_counter);\\n                global_cache.parse_id_counter += 1;\\n                parse_id\\n            };\\n            let (parser, results) = profile!(\\\"CacheContext.parse: inner.parse\\\", self.inner.parse(right_data, bytes));\\n            let mut global_cache = cache.borrow_mut();\\n            global_cache.entries.get_mut(&parse_id).unwrap().reverse();\\n            global_cache.cleanup();\\n            let cache_context_parser = CacheContextParser { inner: Box::new(parser), parse_id };\\n            (cache_context_parser, results)\\n        })\\n        })\\n    }\\n}\\n\\nimpl<T: CombinatorTrait> BaseCombinatorTrait for CacheContext<T> {\\n    fn as_any(&self) -> &dyn std::any::Any where Self: 'static {\\n        self\\n    }\\n    fn apply_to_children(&self, f: &mut dyn FnMut(&dyn BaseCombinatorTrait)) {\\n        f(&self.inner);\\n    }\\n}\\n\\nimpl<Output: OutputTrait> ParserTrait<Output> for CacheContextParser<'_> {\\n    fn get_u8set(&self) -> U8Set {\\n        self.inner.as_ref().get_u8set()\\n    }\\n\\n    fn parse<'b>(&mut self, bytes: &'b [u8]) -> ParseResults<Output> where Output: 'b {\\n        profile!(\\\"CacheContextParser.parse: start\\\", {\\n        GLOBAL_CACHE.with(|cache| {\\n            {\\n                let mut global_cache = cache.borrow_mut();\\n                global_cache.parse_id = Some(self.parse_id);\\n                global_cache.entries.get_mut(&self.parse_id).unwrap().iter_mut().for_each(|entry| {\\n                    entry.borrow_mut().maybe_parse_results.take();\\n                    entry.borrow_mut().maybe_u8set.take();\\n                });\\n            }\\n            let num_entries_initial = cache.borrow_mut().entries[&self.parse_id].len();\\n            for i in (0..num_entries_initial).rev() {\\n                let entry_refcell = cache.borrow_mut().entries[&self.parse_id][i].clone();\\n                let mut entry = entry_refcell.borrow_mut();\\n                let parse_results = profile!(\\\"CacheContextParser.parse: entry.parser.parse\\\", entry.parser.as_mut().unwrap().parse(bytes));\\n                entry.maybe_parse_results = Some(parse_results);\\n            }\\n\\n            let parse_result = profile!(\\\"CacheContextParser.parse: inner.parse\\\", self.inner.as_mut().parse(bytes));\\n\\n            let mut global_cache = cache.borrow_mut();\\n            let mut new_entries = global_cache.entries.get_mut(&self.parse_id).unwrap().split_off(num_entries_initial);\\n            new_entries.reverse();\\n            global_cache.entries.get_mut(&self.parse_id).unwrap().append(&mut new_entries);\\n            global_cache.cleanup();\\n            parse_result\\n        })\\n        })\\n    }\\n}\\n\\nimpl<T: CombinatorTrait> DynCombinatorTrait for Cached<T> {\\n    fn parse_dyn<'a, 'b>(&'a self, right_data: RightData, bytes: &'b [u8]) -> (Box<dyn ParserTrait<Self::Output> + 'a>, ParseResults<Self::Output>) where Self::Output: 'b {\\n        let (parser, parse_results) = self.parse(right_data, bytes);\\n        (Box::new(parser), parse_results)\\n    }\\n\\n    fn one_shot_parse_dyn<'a, 'b>(&'a self, right_data: RightData, bytes: &'b [u8]) -> UnambiguousParseResults<Self::Output> where Self::Output: 'b {\\n        self.one_shot_parse(right_data, bytes)\\n    }\\n}\\n\\nimpl<T: CombinatorTrait> CombinatorTrait for Cached<T> {\\n    type Parser<'a> = CachedParser where Self: 'a;\\n    type Output = T::Output;\\n\\n    fn one_shot_parse<'b>(&self, right_data: RightData, bytes: &'b [u8]) -> UnambiguousParseResults<Self::Output> where Self::Output: 'b {\\n        GLOBAL_CACHE.with(move |cache| {\\n            let key = CacheKey { combinator: std::ptr::addr_of!(self.inner) as *const dyn DynCombinatorTrait, right_data: right_data.clone() };\\n\\n            let mut global_cache = cache.borrow_mut();\\n            let parse_id = global_cache.parse_id.unwrap();\\n            if let Some(entry) = profile!(\\\"Cached.parse: check cache: get entry\\\", {\\n                global_cache.one_shot_results.get_mut(&parse_id).unwrap().get(&key).cloned()\\n            }) {\\n                count_hit!(\\\"Cached.parse: cache hit\\\");\\n                return entry;\\n            }\\n            drop(global_cache);\\n\\n            count_hit!(\\\"Cached.parse: cache miss\\\");\\n            let inner = &self.inner;\\n            let parse_result: UnambiguousParseResults<Self::Output> = profile!(\\\"Cached.parse: inner.one_shot_parse\\\", inner.one_shot_parse(right_data, bytes));\\n            let mut global_cache = cache.borrow_mut();\\n            let parse_id = global_cache.parse_id.unwrap();\\n            global_cache.one_shot_results.get_mut(&parse_id).unwrap().put(key, parse_result.clone());\\n            parse_result\\n        })\\n    }\\n\\n    fn old_parse<'a, 'b>(&self, right_data: RightData, bytes: &'b [u8]) -> (Self::Parser<'a>, ParseResults<Self::Output>) where Self::Output: 'b {\\n        GLOBAL_CACHE.with(move |cache| {\\n            let key = CacheKey { combinator: std::ptr::addr_of!(self.inner) as *const dyn DynCombinatorTrait, right_data: right_data.clone() };\\n\\n            let mut global_cache = cache.borrow_mut();\\n            let parse_id = global_cache.parse_id.unwrap();\\n            if let Some(entry) = profile!(\\\"Cached.parse: check cache: get entry\\\", {\\n                global_cache.new_parsers.get_mut(&parse_id).unwrap().get(&key).cloned()\\n            }) {\\n                count_hit!(\\\"Cached.parse: cache hit\\\");\\n                let parse_results = entry.borrow().maybe_parse_results.clone().expect(\\\"CachedParser.parser: parse_results is None\\\");\\n                return (CachedParser { entry }, parse_results);\\n            }\\n            drop(global_cache);\\n\\n            count_hit!(\\\"Cached.parse: cache miss\\\");\\n            let entry = Rc::new(RefCell::new(CacheEntry {\\n                parser: None,\\n                maybe_parse_results: None,\\n                maybe_u8set: None,\\n            }));\\n            // let inner: &'static T = unsafe { transmute(&self.inner) };\\n            // let (parser, mut parse_results): (_, ParseResults) = profile!(\\\"Cached.parse: inner.parse\\\", inner.parse(right_data, bytes));\\n            // let (parser, mut parse_results) = inner.parse_dyn(right_data, bytes);\\n            let (parser, mut parse_results) = self.inner.parse_dyn(right_data, bytes);\\n            let parser: Box<dyn ParserTrait<Self::Output> + 'static> = unsafe { transmute(parser) };\\n            // profile!(\\\"Cached.parse: parse_results.squash\\\", parse_results.squash());\\n\\n            let mut global_cache = cache.borrow_mut();\\n            let parse_id = global_cache.parse_id.unwrap();\\n            global_cache.new_parsers.get_mut(&parse_id).unwrap().put(key, entry.clone());\\n            if !parse_results.done() {\\n                global_cache.entries.get_mut(&parse_id).unwrap().push(entry.clone());\\n            }\\n            *entry.borrow_mut() = CacheEntry { parser: Some(parser), maybe_parse_results: Some(parse_results.clone()), maybe_u8set: None };\\n            (CachedParser { entry }, parse_results)\\n        })\\n    }\\n}\\n\\nimpl<T: CombinatorTrait> BaseCombinatorTrait for Cached<T> {\\n    fn as_any(&self) -> &dyn std::any::Any where Self: 'static {\\n        self\\n    }\\n    fn apply_to_children(&self, f: &mut dyn FnMut(&dyn BaseCombinatorTrait)) {\\n        f(&self.inner);\\n    }\\n}\\n\\nimpl<Output: OutputTrait> ParserTrait<Output> for CachedParser {\\n    fn get_u8set(&self) -> U8Set {\\n        if self.entry.borrow().maybe_u8set.is_some() {\\n            self.entry.borrow().maybe_u8set.clone().unwrap()\\n        } else {\\n            let u8set = self.entry.borrow().parser.as_ref().unwrap().get_u8set();\\n            self.entry.borrow_mut().maybe_u8set = Some(u8set.clone());\\n            u8set\\n        }\\n    }\\n\\n    fn parse<'b>(&mut self, bytes: &'b [u8]) -> ParseResults<Output> where Output: 'b {\\n        self.entry.borrow().maybe_parse_results.clone().expect(\\\"CachedParser.steps: parse_results is None\\\")\\n    }\\n}\\n\\npub fn cache_context<'a, T: IntoCombinator>(a: T)-> impl CombinatorTrait where T::Output: 'static {\\n    profile_internal(\\\"cache_context\\\", CacheContext { inner: a.into_combinator() })\\n    // a.into_combinator()\\n}\\n\\n// todo: do we really need to make this 'static?\\npub fn cached<T: IntoCombinator>(a: T)-> impl CombinatorTrait where T::Output: 'static {\\n    profile_internal(\\\"cached\\\", Cached { inner: a.into_combinator() })\\n    // a.into_combinator()\\n}\"} "
    },
    {
      "role": "user",
      "content": "/generate src/_03_combinators/core/choice.rs"
    },
    {
      "role": "model",
      "content": "{\"src/_03_combinators/core/choice.rs\": \"use crate::_01_parse_state::{ParseResultTrait, RightData, RightDataGetters, UpData};\\nuse crate::{profile_internal, BaseCombinatorTrait, CombinatorTrait, DynCombinatorTrait, ParseResults, ParserTrait, U8Set, UnambiguousParseError, UnambiguousParseResults, VecX, OneShotUpData};\\n\\n#[derive(Debug)]\\npub struct Choice<'a> {\\n    pub(crate) children: VecX<Box<dyn DynCombinatorTrait + 'a>>,\\n    pub(crate) greedy: bool,\\n}\\n\\n#[derive(Debug)]\\npub struct ChoiceParser<'a> {\\n    pub(crate) parsers: Vec<Box<dyn ParserTrait + 'a>>,\\n    pub(crate) greedy: bool,\\n}\\n\\nimpl DynCombinatorTrait for Choice<'_> {\\n    fn parse_dyn<'a, 'b>(&'a self, right_data: RightData, bytes: &'b [u8]) -> (Box<dyn ParserTrait<Self::Output> + 'a>, ParseResults<Self::Output>) where Self::Output: 'b {\\n        let (parser, parse_results) = self.parse(right_data, bytes);\\n        (Box::new(parser), parse_results)\\n    }\\n\\n    fn one_shot_parse_dyn<'a, 'b>(&'a self, right_data: RightData, bytes: &'b [u8]) -> UnambiguousParseResults<Self::Output> where Self::Output: 'b {\\n        self.one_shot_parse(right_data, bytes)\\n    }\\n}\\n\\nimpl<Output: OutputTrait> CombinatorTrait for Choice<'_> {\\n    type Parser<'a> = ChoiceParser<'a> where Self: 'a;\\n    type Output = Output;\\n\\n\\n    fn one_shot_parse<'b>(&self, right_data: RightData, bytes: &'b [u8]) -> UnambiguousParseResults<Self::Output> where Self::Output: 'b {\\n        if self.greedy {\\n            for parser in self.children.iter() {\\n                let parse_result = parser.one_shot_parse(right_data.clone(), bytes);\\n                match parse_result {\\n                    Ok(one_shot_up_data) => {\\n                        return Ok(OneShotUpData::new(one_shot_up_data.just_right_data(), one_shot_up_data.output));\\n                    }\\n                    Err(UnambiguousParseError::Incomplete | UnambiguousParseError::Ambiguous) => {\\n                        return parse_result;\\n                    }\\n                    Err(UnambiguousParseError::Fail) => {}\\n                }\\n            }\\n            Err(UnambiguousParseError::Fail)\\n        } else {\\n            for (i, parser) in self.children.iter().enumerate() {\\n                let parse_result = parser.one_shot_parse(right_data.clone(), bytes);\\n                match parse_result {\\n                    Ok(one_shot_up_data) => {\\n                        for parser2 in self.children[i+1..].iter() {\\n                            let parse_result2 = parser2.one_shot_parse(right_data.clone(), bytes);\\n                            match parse_result2 {\\n                                Ok(_) => {\\n                                    return Err(UnambiguousParseError::Ambiguous);\\n                                }\\n                                Err(UnambiguousParseError::Incomplete | UnambiguousParseError::Ambiguous) => {\\n                                    return parse_result2;\\n                                }\\n                                Err(UnambiguousParseError::Fail) => {}\\n                            }\\n                        }\\n                        return Ok(OneShotUpData::new(one_shot_up_data.just_right_data(), one_shot_up_data.output));\\n                    }\\n                    Err(UnambiguousParseError::Incomplete | UnambiguousParseError::Ambiguous) => {\\n                        return parse_result;\\n                    }\\n                    Err(UnambiguousParseError::Fail) => {}\\n                }\\n            };\\n            Err(UnambiguousParseError::Fail)\\n        }\\n    }\\n\\n    fn old_parse<'a, 'b>(&self, right_data: RightData, bytes: &'b [u8]) -> (Self::Parser<'a>, ParseResults<Self::Output>) where Self::Output: 'b {\\n        let mut parsers = Vec::new();\\n        let mut combined_results = ParseResults::empty_finished();\\n\\n        for child in &self.children {\\n            let (parser, parse_results) = child.as_ref().parse_dyn(right_data.clone(), bytes);\\n            if !parse_results.done {\\n                parsers.push(parser);\\n            }\\n            let discard_rest = self.greedy && parse_results.succeeds_decisively();\\n            combined_results.merge_assign(parse_results);\\n            if discard_rest {\\n                break;\\n            }\\n        }\\n\\n        (\\n            ChoiceParser { parsers, greedy: self.greedy },\\n            combined_results\\n        )\\n    }\\n}\\n\\nimpl BaseCombinatorTrait for Choice<'_> {\\n    fn as_any(&self) -> &dyn std::any::Any where Self: 'static {\\n        self\\n    }\\n    fn apply_to_children(&self, f: &mut dyn FnMut(&dyn BaseCombinatorTrait)) {\\n        for child in self.children.iter() {\\n            f(child);\\n        }\\n    }\\n}\\n\\nimpl<Output: OutputTrait> ParserTrait<Output> for ChoiceParser<'_> {\\n    fn get_u8set(&self) -> U8Set {\\n        let mut u8set = U8Set::none();\\n        for parser in &self.parsers {\\n            u8set |= parser.get_u8set();\\n        }\\n        u8set\\n    }\\n\\n    fn parse<'b>(&mut self, bytes: &'b [u8]) -> ParseResults<Output> where Output: 'b {\\n        let mut parse_result = ParseResults::empty_finished();\\n        let mut discard_rest = false;\\n\\n        self.parsers.retain_mut(|mut parser| {\\n            if discard_rest {\\n                return false;\\n            }\\n            let parse_results = parser.parse(bytes);\\n            discard_rest = self.greedy && parse_results.succeeds_decisively();\\n            let done = parse_results.done();\\n            parse_result.merge_assign(parse_results);\\n            !done\\n        });\\n        parse_result\\n    }\\n\\n}\\n\\npub fn _choice<'a>(v: Vec<Box<dyn DynCombinatorTrait + 'a>>) -> impl CombinatorTrait + 'a {\\n    Choice {\\n        children: v.into_iter().collect(),\\n        greedy: false,\\n    }\\n}\\n\\npub fn _choice_greedy<'a>(v: Vec<Box<dyn DynCombinatorTrait + 'a>>) -> impl CombinatorTrait + 'a {\\n    profile_internal(\\\"choice\\\", Choice {\\n        children: v.into_iter().collect(),\\n        greedy: true,\\n    })\\n}\"} "
    },
    {
      "role": "user",
      "content": "/generate src/_03_combinators/core/choice_macro.rs"
    },
    {
      "role": "model",
      "content": "{\"src/_03_combinators/core/choice_macro.rs\": \"use crate::IntoCombinator;\\n\\npub fn choicen_helper<T: IntoCombinator>(x: T) -> T::Output {\\n        IntoCombinator::into_combinator(x)\\n}\\n\\n#[macro_export]\\nmacro_rules! choice_generalised {\\n    ($greedy:expr, $c0:expr, $c1:expr $(,)?) => {{\\n        use $crate::choicen_helper as h;\\n        $crate::Choice2 {\\n            c0: $crate::IntoCombinator::into_combinator($c0),\\n            c1: h($c1),\\n            greedy: $greedy,\\n        }\\n    }};\\n    ($greedy:expr, $c0:expr, $c1:expr, $c2:expr $(,)?) => {{\\n        use $crate::choicen_helper as h;\\n        $crate::Choice3 {\\n            c0: $crate::IntoCombinator::into_combinator($c0),\\n            c1: h($c1),\\n            c2: h($c2),\\n            greedy: $greedy,\\n        }\\n    }};\\n    ($greedy:expr, $c0:expr, $c1:expr, $c2:expr, $c3:expr $(,)?) => {{\\n        use $crate::choicen_helper as h;\\n        $crate::Choice4 {\\n            c0: $crate::IntoCombinator::into_combinator($c0),\\n            c1: h($c1),\\n            c2: h($c2),\\n            c3: h($c3),\\n            greedy: $greedy,\\n        }\\n    }};\\n    ($greedy:expr, $c0:expr, $c1:expr, $c2:expr, $c3:expr, $c4:expr $(,)?) => {{\\n        use $crate::choicen_helper as h;\\n        $crate::Choice5 {\\n            c0: $crate::IntoCombinator::into_combinator($c0),\\n            c1: h($c1),\\n            c2: h($c2),\\n            c3: h($c3),\\n            c4: h($c4),\\n            greedy: $greedy,\\n        }\\n    }};\\n    ($greedy:expr, $c0:expr, $c1:expr, $c2:expr, $c3:expr, $c4:expr, $c5:expr $(,)?) => {{\\n        use $crate::choicen_helper as h;\\n        $crate::Choice6 {\\n            c0: $crate::IntoCombinator::into_combinator($c0),\\n            c1: h($c1),\\n            c2: h($c2),\\n            c3: h($c3),\\n            c4: h($c4),\\n            c5: h($c5),\\n            greedy: $greedy,\\n        }\\n    }};\\n    ($greedy:expr, $c0:expr, $c1:expr, $c2:expr, $c3:expr, $c4:expr, $c5:expr, $c6:expr $(,)?) => {{\\n        use $crate::choicen_helper as h;\\n        $crate::Choice7 {\\n            c0: $crate::IntoCombinator::into_combinator($c0),\\n            c1: h($c1),\\n            c2: h($c2),\\n            c3: h($c3),\\n            c4: h($c4),\\n            c5: h($c5),\\n            c6: h($c6),\\n            greedy: $greedy,\\n        }\\n    }};\\n    ($greedy:expr, $c0:expr, $c1:expr, $c2:expr, $c3:expr, $c4:expr, $c5:expr, $c6:expr, $c7:expr $(,)?) => {{\\n        use $crate::choicen_helper as h;\\n        $crate::Choice8 {\\n            c0: $crate::IntoCombinator::into_combinator($c0),\\n            c1: h($c1),\\n            c2: h($c2),\\n            c3: h($c3),\\n            c4: h($c4),\\n            c5: h($c5),\\n            c6: h($c6),\\n            c7: h($c7),\\n            greedy: $greedy,\\n        }\\n    }};\\n    ($greedy:expr, $c0:expr, $c1:expr, $c2:expr, $c3:expr, $c4:expr, $c5:expr, $c6:expr, $c7:expr, $c8:expr $(,)?) => {{\\n        use $crate::choicen_helper as h;\\n        $crate::Choice9 {\\n            c0: $crate::IntoCombinator::into_combinator($c0),\\n            c1: h($c1),\\n            c2: h($c2),\\n            c3: h($c3),\\n            c4: h($c4),\\n            c5: h($c5),\\n            c6: h($c6),\\n            c7: h($c7),\\n            c8: h($c8),\\n            greedy: $greedy,\\n        }\\n    }};\\n    ($greedy:expr, $c0:expr, $c1:expr, $c2:expr, $c3:expr, $c4:expr, $c5:expr, $c6:expr, $c7:expr, $c8:expr, $c9:expr $(,)?) => {{\\n        use $crate::choicen_helper as h;\\n        $crate::Choice10 {\\n            c0: $crate::IntoCombinator::into_combinator($c0),\\n            c1: h($c1),\\n            c2: h($c2),\\n            c3: h($c3),\\n            c4: h($c4),\\n            c5: h($c5),\\n            c6: h($c6),\\n            c7: h($c7),\\n            c8: h($c8),\\n            c9: h($c9),\\n            greedy: $greedy,\\n        }\\n    }};\\n    ($greedy:expr, $c0:expr, $c1:expr, $c2:expr, $c3:expr, $c4:expr, $c5:expr, $c6:expr, $c7:expr, $c8:expr, $c9:expr, $c10:expr $(,)?) => {{\\n        use $crate::choicen_helper as h;\\n        $crate::Choice11 {\\n            c0: $crate::IntoCombinator::into_combinator($c0),\\n            c1: h($c1),\\n            c2: h($c2),\\n            c3: h($c3),\\n            c4: h($c4),\\n            c5: h($c5),\\n            c6: h($c6),\\n            c7: h($c7),\\n            c8: h($c8),\\n            c9: h($c9),\\n            c10: h($c10),\\n            greedy: $greedy,\\n        }\\n    }};\\n    ($greedy:expr, $c0:expr, $c1:expr, $c2:expr, $c3:expr, $c4:expr, $c5:expr, $c6:expr, $c7:expr, $c8:expr, $c9:expr, $c10:expr, $c11:expr $(,)?) => {{\\n        use $crate::choicen_helper as h;\\n        $crate::Choice12 {\\n            c0: $crate::IntoCombinator::into_combinator($c0),\\n            c1: h($c1),\\n            c2: h($c2),\\n            c3: h($c3),\\n            c4: h($c4),\\n            c5: h($c5),\\n            c6: h($c6),\\n            c7: h($c7),\\n            c8: h($c8),\\n            c9: h($c9),\\n            c10: h($c10),\\n            c11: h($c11),\\n            greedy: $greedy,\\n        }\\n    }};\\n    ($greedy:expr, $c0:expr, $c1:expr, $c2:expr, $c3:expr, $c4:expr, $c5:expr, $c6:expr, $c7:expr, $c8:expr, $c9:expr, $c10:expr, $c11:expr, $c12:expr $(,)?) => {{\\n        use $crate::choicen_helper as h;\\n        $crate::Choice13 {\\n            c0: $crate::IntoCombinator::into_combinator($c0),\\n            c1: h($c1),\\n            c2: h($c2),\\n            c3: h($c3),\\n            c4: h($c4),\\n            c5: h($c5),\\n            c6: h($c6),\\n            c7: h($c7),\\n            c8: h($c8),\\n            c9: h($c9),\\n            c10: h($c10),\\n            c11: h($c11),\\n            c12: h($c12),\\n            greedy: $greedy,\\n        }\\n    }};\\n    ($greedy:expr, $c0:expr, $c1:expr, $c2:expr, $c3:expr, $c4:expr, $c5:expr, $c6:expr, $c7:expr, $c8:expr, $c9:expr, $c10:expr, $c11:expr, $c12:expr, $c13:expr $(,)?) => {{\\n        use $crate::choicen_helper as h;\\n        $crate::Choice14 {\\n            c0: $crate::IntoCombinator::into_combinator($c0),\\n            c1: h($c1),\\n            c2: h($c2),\\n            c3: h($c3),\\n            c4: h($c4),\\n            c5: h($c5),\\n            c6: h($c6),\\n            c7: h($c7),\\n            c8: h($c8),\\n            c9: h($c9),\\n            c10: h($c10),\\n            c11: h($c11),\\n            c12: h($c12),\\n            c13: h($c13),\\n            greedy: $greedy,\\n        }\\n    }};\\n    ($greedy:expr, $c0:expr, $c1:expr, $c2:expr, $c3:expr, $c4:expr, $c5:expr, $c6:expr, $c7:expr, $c8:expr, $c9:expr, $c10:expr, $c11:expr, $c12:expr, $c13:expr, $c14:expr $(,)?) => {{\\n        use $crate::choicen_helper as h;\\n        $crate::Choice15 {\\n            c0: $crate::IntoCombinator::into_combinator($c0),\\n            c1: h($c1),\\n            c2: h($c2),\\n            c3: h($c3),\\n            c4: h($c4),\\n            c5: h($c5),\\n            c6: h($c6),\\n            c7: h($c7),\\n            c8: h($c8),\\n            c9: h($c9),\\n            c10: h($c10),\\n            c11: h($c11),\\n            c12: h($c12),\\n            c13: h($c13),\\n            c14: h($c14),\\n            greedy: $greedy,\\n        }\\n    }};\\n    ($greedy:expr, $c0:expr, $c1:expr, $c2:expr, $c3:expr, $c4:expr, $c5:expr, $c6:expr, $c7:expr, $c8:expr, $c9:expr, $c10:expr, $c11:expr, $c12:expr, $c13:expr, $c14:expr, $c15:expr $(,)?) => {{\\n        use $crate::choicen_helper as h;\\n        $crate::Choice16 {\\n            c0: $crate::IntoCombinator::into_combinator($c0),\\n            c1: h($c1),\\n            c2: h($c2),\\n            c3: h($c3),\\n            c4: h($c4),\\n            c5: h($c5),\\n            c6: h($c6),\\n            c7: h($c7),\\n            c8: h($c8),\\n            c9: h($c9),\\n            c10: h($c10),\\n            c11: h($c11),\\n            c12: h($c12),\\n            c13: h($c13),\\n            c14: h($c14),\\n            c15: h($c15),\\n            greedy: $greedy,\\n        }\\n    }};\\n    ($greedy:expr, $c0:expr, $c1:expr, $c2:expr, $c3:expr, $c4:expr, $c5:expr, $c6:expr, $c7:expr, $c8:expr, $c9:expr, $c10:expr, $c11:expr, $c12:expr, $c13:expr, $c14:expr, $c15:expr, $($rest:expr),+ $(,)?) => {{\\n        fn convert<T: $crate::IntoCombinator>(x: T) -> Box<dyn $crate::CombinatorTrait> where T::Output {\\n            Box::new(x.into_combinator())\\n        }\\n        if $greedy {\\n            $crate::_choice_greedy(vec![convert($c0), convert($c1), convert($c2), convert($c3), convert($c4), convert($c5), convert($c6), convert($c7), convert($c8), convert($c9), convert($c10), convert($c11), convert($c12), convert($c13), convert($c14), convert($c15), $(convert($rest)),+])\\n        } else {\\n            $crate::_choice(vec![convert($c0), convert($c1), convert($c2), convert($c3), convert($c4), convert($c5), convert($c6), convert($c7), convert($c8), convert($c9), convert($c10), convert($c11), convert($c12), convert($c13), convert($c14), convert($c15), $(convert($rest)),+])\\n        }\\n    }};\\n}\\n\\n#[macro_export]\\nmacro_rules! choice {\\n    ($($rest:expr),+ $(,)?) => {{\\n        $crate::choice_generalised!(false, $($rest),+)\\n    }};\\n}\\n\\n#[macro_export]\\nmacro_rules! choice_greedy {\\n    ($($rest:expr),+ $(,)?) => {{\\n        $crate::choice_generalised!(true, $($rest),+)\\n    }};\\n}\"} "
    },
    {
      "role": "user",
      "content": "/generate src/_03_combinators/core/choicen.rs"
    },
    {
      "role": "model",
      "content": "{\"src/_03_combinators/core/choicen.rs\": \"\\n// src/_03_combinators/core/choicen.rs\\nuse crate::{BaseCombinatorTrait, CombinatorTrait, IntoCombinator, ParseResultTrait, ParseResults, ParserTrait, RightData, RightDataGetters, Squash, U8Set, UnambiguousParseResults, UpData, OneShotUpData};\\n\\nmacro_rules! profile {\\n    ($tag:expr, $body:expr) => {{\\n        $body\\n    }};\\n}\\n\\n#[macro_export]\\nmacro_rules! define_choice {\\n    ($choice_name:ident, $choice_parser_name:ident, $choice_enum_name:ident, $choice_partial_enum_name:ident, $first:ident, $($rest:ident),+) => {\\n        #[derive(Debug)]\\n        pub struct $choice_name<$first, $($rest),+> {\\n            pub(crate) $first: $first,\\n            $(pub(crate) $rest: $rest,)+\\n            pub(crate) greedy: bool,\\n        }\\n\\n        #[derive(Debug)]\\n        pub struct $choice_parser_name<'a, $first, $($rest),+>\\n        where\\n            $first: CombinatorTrait,\\n            $($rest: CombinatorTrait),+\\n        {\\n            pub(crate) combinator: &'a $choice_name<$first, $($rest),+>,\\n            pub(crate) $first: Vec<$first::Parser<'a>>,\\n            $(pub(crate) $rest: Vec<$rest::Parser<'a>>,)+\\n            pub(crate) position: usize,\\n        }\\n\\n        pub struct $choice_enum_name<$first, $($rest),+>\\n        where\\n            $first: CombinatorTrait,\\n            $($rest: CombinatorTrait),+\\n        {\\n            pub(crate) $first: $first::Output,\\n            $(pub(crate) $rest: $rest::Output,)+\\n        }\\n\\n        pub struct $choice_partial_enum_name<$first, $($rest),+>\\n        where\\n            $first: CombinatorTrait,\\n            $($rest: CombinatorTrait),+\\n        {\\n            pub(crate) $first: Option<$first::Output>,\\n            $(pub(crate) $rest: Option<$rest::Output>,)+\\n        }\\n\\n        impl<$first, $($rest),+> $crate::DynCombinatorTrait for $choice_name<$first, $($rest),+>\\n        where\\n            $first: CombinatorTrait,\\n            $($rest: CombinatorTrait),+,\\n        {\\n            fn parse_dyn(&self, right_data: RightData, bytes: &[u8]) -> (Box<dyn ParserTrait<Self::Output> + '_>, ParseResults<Self::Output>) {\\n                let (parser, parse_results) = self.parse(right_data, bytes);\\n                (Box::new(parser), parse_results)\\n            }\\n\\n            fn one_shot_parse_dyn(&self, right_data: RightData, bytes: &[u8]) -> UnambiguousParseResults<Self::Output> {\\n                self.one_shot_parse(right_data, bytes)\\n            }\\n        }\\n\\n        impl<$first, $($rest),+> CombinatorTrait for $choice_name<$first, $($rest),+>\\n        where\\n            $first: CombinatorTrait,\\n            $($rest: CombinatorTrait),+,\\n        {\\n            type Parser<'a> = $choice_parser_name<'a, $first, $($rest),+> where Self: 'a;\\n            type Output = $choice_enum_name<$first, $($rest),+>;\\n\\n            fn one_shot_parse<'b>(&self, right_data: RightData, bytes: &'b [u8]) -> $crate::UnambiguousParseResults<Self::Output> where Self::Output: 'b {\\n                use $crate::{UnambiguousParseResults, UnambiguousParseError};\\n                if self.greedy {\\n                    let first_combinator = &self.$first;\\n                    let parse_result = first_combinator.one_shot_parse(right_data.clone(), bytes);\\n                    if matches!(parse_result, Ok(_) | Err(UnambiguousParseError::Ambiguous | UnambiguousParseError::Incomplete)) {\\n                        return parse_result;\\n                    }\\n\\n                    $(\\n                        let next_combinator = &self.$rest;\\n                        let parse_result = next_combinator.one_shot_parse(right_data.clone(), bytes);\\n                        if matches!(parse_result, Ok(_) | Err(UnambiguousParseError::Ambiguous | UnambiguousParseError::Incomplete)) {\\n                            return parse_result;\\n                        }\\n                    )+\\n\\n                    Err(UnambiguousParseError::Fail)\\n                } else {\\n                    let first_combinator = &self.$first;\\n                    let mut final_parse_result = first_combinator.one_shot_parse(right_data.clone(), bytes);\\n                    if matches!(final_parse_result, Err(UnambiguousParseError::Ambiguous | UnambiguousParseError::Incomplete)) {\\n                        return final_parse_result;\\n                    }\\n\\n                    $(\\n                        let next_combinator = &self.$rest;\\n                        let parse_result = next_combinator.one_shot_parse(right_data.clone(), bytes);\\n                        match (&parse_result, &final_parse_result) {\\n                            (Err(UnambiguousParseError::Ambiguous | UnambiguousParseError::Incomplete), _) => {\\n                                return parse_result;\\n                            },\\n                            (Ok(_), Ok(_)) => {\\n                                return parse_result;\\n                            },\\n                            (Ok(_), Err(UnambiguousParseError::Fail)) => {\\n                                final_parse_result = parse_result;\\n                            },\\n                            (Ok(_), Err(UnambiguousParseError::Incomplete | UnambiguousParseError::Ambiguous)) => unreachable!(),\\n                            (Err(UnambiguousParseError::Fail), _) => {},\\n                        }\\n                    )+\\n\\n                    final_parse_result\\n                }\\n            }\\n\\n            fn old_parse<'a, 'b>(&'a self, right_data: RightData, bytes: &'b [u8]) -> (Self::Parser<'a>, ParseResults<Self::Output>) where Self::Output: 'b {\\n                let start_position = right_data.get_fields1().position;\\n\\n                let mut combined_results = ParseResults::empty_finished();\\n\\n                let (first_parser, first_parse_results) = self.$first.parse(right_data.clone(), bytes);\\n                let mut parser = $choice_parser_name {\\n                    combinator: self,\\n                    $first: vec![],\\n                    $($rest: vec![],)+\\n                    position: start_position + bytes.len(),\\n                };\\n                if !first_parse_results.done {\\n                    parser.$first.push(first_parser);\\n                }\\n                let discard_rest = self.greedy && first_parse_results.succeeds_decisively();\\n                combined_results.merge_assign(first_parse_results);\\n\\n                $(\\n                    if discard_rest {\\n                        return (parser, combined_results);\\n                    }\\n                    let (next_parser, next_parse_results) = self.$rest.parse(right_data.clone(), bytes);\\n                    if !next_parse_results.done() {\\n                        parser.$rest.push(next_parser);\\n                    }\\n                    let discard_rest = self.greedy && next_parse_results.succeeds_decisively();\\n                    combined_results.merge_assign(next_parse_results);\\n                )+\\n\\n                (parser, combined_results)\\n            }\\n        }\\n\\n        impl<'a, $first, $($rest),+> ParserTrait<$choice_enum_name<$first, $($rest),+>> for $choice_parser_name<'a, $first, $($rest),+>\\n        where\\n            $first: CombinatorTrait,\\n            $($rest: CombinatorTrait),+\\n        {\\n            fn get_u8set(&self) -> U8Set {\\n                let mut u8set = U8Set::none();\\n                for parser in &self.$first {\\n                    u8set = u8set.union(&parser.get_u8set());\\n                }\\n                $(\\n                    for parser in &self.$rest {\\n                        u8set = u8set.union(&parser.get_u8set());\\n                    }\\n                )+\\n                u8set\\n            }\\n\\n            fn parse<'b>(&mut self, bytes: &'b [u8]) -> ParseResults<$choice_enum_name<$first, $($rest),+>> where $choice_enum_name<$first, $($rest),+>: 'b {\\n                profile!(stringify!($choice_parser_name, \\\"::parse\\\"), {\\n                    let mut parse_result = ParseResults::empty_finished();\\n                    let mut discard_rest = false;\\n\\n                    // First child\\n                    self.$first.retain_mut(|parser| {\\n                        if discard_rest {\\n                            return false;\\n                        }\\n                        let parse_results = parser.parse(bytes);\\n                        let done = parse_results.done;\\n                        discard_rest = self.combinator.greedy && parse_results.succeeds_decisively();\\n                        parse_result.merge_assign(parse_results);\\n                        !done\\n                    });\\n\\n                    // Rest of the children\\n                    $(\\n                        if discard_rest {\\n                            return parse_result;\\n                        }\\n\\n                        self.$rest.retain_mut(|parser| {\\n                            if discard_rest {\\n                                return false;\\n                            }\\n                            let parse_results = parser.parse(bytes);\\n                            let done = parse_results.done;\\n                            discard_rest = self.combinator.greedy && parse_results.succeeds_decisively();\\n                            parse_result.merge_assign(parse_results);\\n                            !done\\n                        });\\n                    )+\\n\\n                    parse_result\\n                })\\n            }\\n        }\\n\\n        impl<$first, $($rest),+> BaseCombinatorTrait for $choice_name<$first, $($rest),+>\\n        where\\n            $first: BaseCombinatorTrait,\\n            $($rest: BaseCombinatorTrait),+,\\n        {\\n            fn as_any(&self) -> &dyn std::any::Any where Self: 'static {\\n                self\\n            }\\n\\n            fn apply_to_children(&self, f: &mut dyn FnMut(&dyn BaseCombinatorTrait)) {\\n                f(&self.$first);\\n                $(f(&self.$rest);)+\\n            }\\n        }\\n    };\\n}\\n\\ndefine_choice!(Choice2, Choice2Parser, Choice2Enum, Choice2PartialEnum, c0, c1);\\ndefine_choice!(Choice3, Choice3Parser, Choice3Enum, Choice3PartialEnum, c0, c1, c2);\\ndefine_choice!(Choice4, Choice4Parser, Choice4Enum, Choice4PartialEnum, c0, c1, c2, c3);\\ndefine_choice!(Choice5, Choice5Parser, Choice5Enum, Choice5PartialEnum, c0, c1, c2, c3, c4);\\ndefine_choice!(Choice6, Choice6Parser, Choice6Enum, Choice6PartialEnum, c0, c1, c2, c3, c4, c5);\\ndefine_choice!(Choice7, Choice7Parser, Choice7Enum, Choice7PartialEnum, c0, c1, c2, c3, c4, c5, c6);\\ndefine_choice!(Choice8, Choice8Parser, Choice8Enum, Choice8PartialEnum, c0, c1, c2, c3, c4, c5, c6, c7);\\ndefine_choice!(Choice9, Choice9Parser, Choice9Enum, Choice9PartialEnum, c0, c1, c2, c3, c4, c5, c6, c7, c8);\\ndefine_choice!(Choice10, Choice10Parser, Choice10Enum, Choice10PartialEnum, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9);\\ndefine_choice!(Choice11, Choice11Parser, Choice11Enum, Choice11PartialEnum, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, c10);\\ndefine_choice!(Choice12, Choice12Parser, Choice12Enum, Choice12PartialEnum, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11);\\ndefine_choice!(Choice13, Choice13Parser, Choice13Enum, Choice13PartialEnum, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12);\\ndefine_choice!(Choice14, Choice14Parser, Choice14Enum, Choice14PartialEnum, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13);\\ndefine_choice!(Choice15, Choice15Parser, Choice15Enum, Choice15PartialEnum, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14);\\ndefine_choice!(Choice16, Choice16Parser, Choice16Enum, Choice16PartialEnum, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15);\"} "
    },
    {
      "role": "user",
      "content": "/generate src/_03_combinators/core/eat.rs src/_03_combinators/core/fast.rs src/_03_combinators/core/mod.rs src/_03_combinators/core/opt.rs"
    },
    {
      "role": "model",
      "content": "{\"src/_03_combinators/core/eat.rs\": \"\\n// src/_03_combinators/core/eat.rs\\nuse crate::internal_vec::VecY;\\nuse crate::_01_parse_state::{RightData, UpData};\\nuse crate::{RightDataGetters, UnambiguousParseError};\\nuse crate::{BaseCombinatorTrait, DynCombinatorTrait, UnambiguousParseResults, OneShotUpData};\\nuse crate::{CombinatorTrait, ParseResultTrait, ParseResults, ParserTrait, U8Set};\\nuse std::ops::RangeBounds;\\n\\n#[derive(Copy, Debug, Clone, PartialEq, Eq, Hash)]\\npub struct EatU8 {\\n    pub(crate) u8set: U8Set,\\n}\\n\\n#[derive(Debug)]\\npub struct EatU8Parser {\\n    pub(crate) u8set: U8Set,\\n    pub(crate) right_data: Option<RightData>,\\n}\\n\\nimpl DynCombinatorTrait for EatU8 {\\n    fn parse_dyn<'a, 'b>(&'a self, right_data: RightData, bytes: &'b [u8]) -> (Box<dyn ParserTrait<Self::Output> + 'a>, ParseResults<Self::Output>) where Self::Output: 'b {\\n        let (parser, parse_results) = self.parse(right_data, bytes);\\n        (Box::new(parser), parse_results)\\n    }\\n\\n    fn one_shot_parse_dyn<'a, 'b>(&'a self, right_data: RightData, bytes: &'b [u8]) -> UnambiguousParseResults<Self::Output> where Self::Output: 'b {\\n        self.one_shot_parse(right_data, bytes)\\n    }\\n}\\n\\nimpl CombinatorTrait for EatU8 {\\n    type Parser<'a> = EatU8Parser;\\n    type Output = ();\\n\\n    fn one_shot_parse<'b>(&self, right_data: RightData, bytes: &'b [u8]) -> UnambiguousParseResults<Self::Output> where Self::Output: 'b {\\n        if bytes.is_empty() {\\n            return ParseResultTrait::empty_unfinished();\\n        }\\n\\n        let mut right_data = right_data;\\n        if self.u8set.contains(bytes[0]) {\\n            right_data.advance(1);\\n            Ok(OneShotUpData::new(right_data, ())) // Add output\\n        } else {\\n            ParseResultTrait::empty_finished()\\n        }\\n    }\\n\\n    fn old_parse<'a, 'b>(&self, right_data: RightData, bytes: &'b [u8]) -> (Self::Parser<'a>, ParseResults<Self::Output>) where Self::Output: 'b {\\n        let mut parser = EatU8Parser {\\n            u8set: self.u8set.clone(),\\n            right_data: Some(right_data),\\n        };\\n        let parse_results = parser.parse(bytes);\\n        (parser, parse_results)\\n    }\\n}\\n\\nimpl BaseCombinatorTrait for EatU8 {\\n    fn as_any(&self) -> &dyn std::any::Any where Self: 'static {\\n        self\\n    }\\n}\\n\\nimpl<Output: OutputTrait> ParserTrait<Output> for EatU8Parser {\\n    fn get_u8set(&self) -> U8Set {\\n        assert!(self.right_data.is_some(), \\\"EatU8Parser.get_u8set() called but right_data is None\\\");\\n        return self.u8set.clone();\\n    }\\n\\n    fn parse<'b>(&mut self, bytes: &'b [u8]) -> ParseResults<Output> where Output: 'b {\\n        if bytes.is_empty() {\\n            return ParseResults::empty_unfinished();\\n        }\\n\\n        let mut right_data = self.right_data.take().unwrap();\\n        if self.u8set.contains(bytes[0]) {\\n            right_data.advance(1);\\n            ParseResults::new_single(UpData::new(right_data, ()), true) // Add output\\n        } else {\\n            ParseResults::empty_finished()\\n        }\\n    }\\n}\\n\\npub fn eat_byte(byte: u8) -> EatU8 {\\n    EatU8 {\\n        u8set: U8Set::from_byte(byte),\\n    }\\n}\\n\\npub fn eat_char(c: char) -> EatU8 {\\n    eat_byte(c as u8)\\n}\\n\\npub fn eat_any_byte() -> EatU8 {\\n    EatU8 {\\n        u8set: U8Set::all(),\\n    }\\n}\\n\\npub fn eat_char_choice(chars: &str) -> EatU8 {\\n    EatU8 {\\n        u8set: U8Set::from_chars(chars),\\n    }\\n}\\n\\npub fn eat_char_negation_choice(chars: &str) -> EatU8 {\\n    EatU8 {\\n        u8set: U8Set::from_chars_negation(chars),\\n    }\\n}\\n\\npub fn eat_byte_choice(bytes: &[u8]) -> EatU8 {\\n    EatU8 {\\n        u8set: U8Set::from_bytes(bytes),\\n    }\\n}\\n\\npub fn eat_byte_range(start: u8, end: u8) -> EatU8 {\\n    EatU8 {\\n        u8set: U8Set::from_range(start, end),\\n    }\\n}\\n\\npub fn eat_char_negation(c: char) -> EatU8 {\\n    EatU8 {\\n        u8set: U8Set::from_char_negation(c),\\n    }\\n}\\n\\npub fn eat_char_range(range: impl IntoIterator<Item=u8>) -> EatU8 {\\n    EatU8 { u8set: U8Set::from_byte_range(range) }\\n}\\n\\npub fn eat_byte_negation_range(range: impl IntoIterator<Item=u8>) -> EatU8 {\\n    EatU8 { u8set: U8Set::from_char_negation_range(range) }\\n}\\n\\npub fn eat_match_fn<F>(f: F) -> EatU8\\nwhere\\n    F: Fn(u8) -> bool,\\n{\\n    EatU8 {\\n        u8set: U8Set::from_match_fn(f),\\n    }\\n}\\n\\n\\n#[derive(Debug)]\\npub struct EatString {\\n    pub(crate) string: Vec<u8>,\\n}\\n\\n#[derive(Debug)]\\npub struct EatStringParser<'a> {\\n    pub(crate) string: &'a [u8],\\n    index: usize,\\n    pub(crate) right_data: Option<RightData>,\\n}\\n\\nimpl DynCombinatorTrait for EatString {\\n    fn parse_dyn<'a, 'b>(&'a self, right_data: RightData, bytes: &'b [u8]) -> (Box<dyn ParserTrait<Self::Output> + 'a>, ParseResults<Self::Output>) where Self::Output: 'b {\\n        let (parser, parse_results) = self.parse(right_data, bytes);\\n        (Box::new(parser), parse_results)\\n    }\\n\\n    fn one_shot_parse_dyn<'a, 'b>(&'a self, right_data: RightData, bytes: &'b [u8]) -> UnambiguousParseResults<Self::Output> where Self::Output: 'b {\\n        self.one_shot_parse(right_data, bytes)\\n    }\\n}\\n\\nimpl CombinatorTrait for EatString {\\n    type Parser<'a> = EatStringParser<'a>;\\n    type Output = ();\\n\\n    fn one_shot_parse<'b>(&self, right_data: RightData, bytes: &'b [u8]) -> UnambiguousParseResults<Self::Output> where Self::Output: 'b {\\n        if bytes.len() < self.string.len() {\\n            return Err(UnambiguousParseError::Incomplete);\\n        }\\n\\n        if self.string == bytes[..self.string.len()] {\\n            let mut right_data = right_data;\\n            right_data.advance(self.string.len());\\n            Ok(OneShotUpData::new(right_data, ())) // Add output\\n        } else {\\n            Err(UnambiguousParseError::Fail)\\n        }\\n    }\\n\\n    fn old_parse<'a, 'b>(&self, right_data: RightData, bytes: &'b [u8]) -> (Self::Parser<'a>, ParseResults<Self::Output>) where Self::Output: 'b {\\n        let mut parser = EatStringParser {\\n            string: self.string.as_slice(),\\n            index: 0,\\n            right_data: Some(right_data),\\n        };\\n        let parse_results = parser.parse(bytes);\\n        (parser, parse_results)\\n    }\\n}\\n\\nimpl BaseCombinatorTrait for EatString {\\n    fn as_any(&self) -> &dyn std::any::Any where Self: 'static {\\n        self\\n    }\\n}\\n\\nimpl<Output: OutputTrait> ParserTrait<Output> for EatStringParser<'_> {\\n    fn get_u8set(&self) -> U8Set {\\n        U8Set::from_byte(self.string[self.index])\\n    }\\n\\n    fn parse<'b>(&mut self, bytes: &'b [u8]) -> ParseResults<Output> where Output: 'b {\\n        if bytes.is_empty() {\\n            return ParseResults::empty_unfinished();\\n        }\\n\\n        let mut up_data_vec = VecY::new();\\n        let mut done = false;\\n\\n        for &byte in bytes {\\n            if self.string[self.index] == byte {\\n                self.index += 1;\\n                if self.index == self.string.len() {\\n                    let mut right_data = self.right_data.take().expect(\\\"right_data already taken\\\");\\n                    right_data.advance(self.string.len());\\n                    up_data_vec.push(UpData::new(right_data, ())); // Add output\\n                    done = true;\\n                    break;\\n                }\\n            } else {\\n                done = true;\\n                self.right_data.take();\\n                break;\\n            }\\n        }\\n\\n        ParseResults::new(up_data_vec, done)\\n    }\\n}\\n\\npub fn eat_string(string: &str) -> EatString {\\n    EatString { string: string.as_bytes().to_vec() }\\n}\\n\\npub fn eat_bytes(bytes: &[u8]) -> EatString {\\n    EatString { string: bytes.to_vec() }\\n}\\n\\npub fn eat(string: impl Into<String>) -> EatString {\\n    EatString { string: string.into().into_bytes() }\\n}\", \"src/_03_combinators/core/fast.rs\": \"\\n// src/_03_combinators/core/fast.rs\\nuse crate::tokenizer::finite_automata::{Expr, Regex, RegexState};\\nuse crate::tokenizer::{choice_fast, eat_bytestring_fast, eat_string_fast};\\nuse crate::BaseCombinatorTrait;\\nuse crate::*;\\n// src/combinators/fast.rs\\nuse std::fmt::{Debug, Formatter};\\nuse std::hash::Hash;\\n\\npub struct FastCombinatorWrapper {\\n    pub(crate) regex: Regex,\\n}\\n\\npub struct FastParserWrapper<'a> {\\n    pub(crate) regex_state: RegexState<'a>,\\n    pub(crate) right_data: Option<RightData>,\\n}\\n\\nimpl Debug for FastCombinatorWrapper {\\n    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {\\n        f.debug_struct(\\\"FastCombinatorWrapper\\\").finish_non_exhaustive()\\n    }\\n}\\n\\nimpl Debug for FastParserWrapper<'_> {\\n    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {\\n        f.debug_struct(\\\"FastParserWrapper\\\").finish_non_exhaustive()\\n    }\\n}\\n\\nimpl DynCombinatorTrait for FastCombinatorWrapper {\\n    fn parse_dyn<'a, 'b>(&'a self, right_data: RightData, bytes: &'b [u8]) -> (Box<dyn ParserTrait<Self::Output> + 'a>, ParseResults<Self::Output>) where Self::Output: 'b {\\n        let (parser, parse_results) = self.parse(right_data, bytes);\\n        (Box::new(parser), parse_results)\\n    }\\n\\n    fn one_shot_parse_dyn<'a, 'b>(&'a self, right_data: RightData, bytes: &'b [u8]) -> UnambiguousParseResults<Self::Output> where Self::Output: 'b {\\n        self.one_shot_parse(right_data, bytes)\\n    }\\n}\\n\\nimpl CombinatorTrait for FastCombinatorWrapper {\\n    type Parser<'a> = FastParserWrapper<'a>;\\n    type Output = ();\\n\\n    fn one_shot_parse<'b>(&self, right_data: RightData, bytes: &'b [u8]) -> UnambiguousParseResults<Self::Output> where Self::Output: 'b {\\n        let mut regex_state = self.regex.init();\\n        regex_state.execute(bytes);\\n        if !regex_state.done() {\\n            Err(UnambiguousParseError::Incomplete)\\n        } else if let Some(new_match) = regex_state.prev_match() {\\n            let mut right_data = right_data;\\n            let position = new_match.position;\\n            #[cfg(debug_assertions)]\\n            if position == 0 {\\n                panic!(\\\"FastCombinatorWrapper::one_shot_parse: regex matched the empty string\\\");\\n            }\\n            right_data.advance(position);\\n            Ok(OneShotUpData::new(right_data, ())) // Add output\\n        } else {\\n            assert!(regex_state.failed());\\n            Err(UnambiguousParseError::Fail)\\n        }\\n    }\\n\\n    fn old_parse<'a, 'b>(&self, right_data: RightData, bytes: &'b [u8]) -> (Self::Parser<'a>, ParseResults<Self::Output>) where Self::Output: 'b {\\n        let mut regex_state = self.regex.init();\\n        regex_state.execute(bytes);\\n        if regex_state.failed() {\\n            (FastParserWrapper { regex_state, right_data: None }, ParseResults::empty_finished())\\n        } else {\\n            let mut up_data_vec: VecY<UpData<()>> = vecy![];\\n            let done = regex_state.done();\\n            if let Some(new_match) = regex_state.prev_match() {\\n                let mut right_data = right_data.clone();\\n                let position = new_match.position;\\n                #[cfg(debug_assertions)]\\n                if position == 0 {\\n                    panic!(\\\"FastCombinatorWrapper::old_parse: regex matched the empty string\\\");\\n                }\\n                right_data.advance(position);\\n                up_data_vec.push(UpData::new(right_data, ())); // Add output\\n            }\\n            (FastParserWrapper { regex_state, right_data: Some(right_data) }, ParseResults::new(up_data_vec, done))\\n        }\\n    }\\n}\\n\\nimpl BaseCombinatorTrait for FastCombinatorWrapper {\\n    fn as_any(&self) -> &dyn std::any::Any where Self: 'static {\\n        self\\n    }\\n}\\n\\nimpl<Output: OutputTrait> ParserTrait<Output> for FastParserWrapper<'_> {\\n    fn get_u8set(&self) -> U8Set {\\n        profile!(\\\"FastParserWrapper.get_u8set\\\", self.regex_state.get_u8set())\\n    }\\n\\n    fn parse<'b>(&mut self, bytes: &'b [u8]) -> ParseResults<Output> where Output: 'b {\\n        let mut regex_state = &mut self.regex_state;\\n        let prev_match = regex_state.prev_match();\\n        regex_state.execute(bytes);\\n        if regex_state.failed() {\\n            ParseResults::empty_finished()\\n        } else {\\n            let mut up_data_vec: VecY<UpData<()>> = vecy![];\\n            let done = regex_state.done();\\n            if let Some(new_match) = regex_state.prev_match() {\\n                if Some(new_match) != prev_match {\\n                    let mut right_data = self.right_data.clone().unwrap();\\n                    let position = new_match.position;\\n                    if position == 0 {\\n                        panic!(\\\"FastParserWrapper::parse: regex matched the empty string\\\");\\n                    }\\n                    right_data.advance(position);\\n                    up_data_vec.push(UpData::new(right_data, ())); // Add output\\n                }\\n            }\\n            ParseResults::new(up_data_vec, done)\\n        }\\n    }\\n}\\n\\npub fn fast_combinator(expr: Expr) -> FastCombinatorWrapper {\\n    let regex = expr.build();\\n    FastCombinatorWrapper { regex }\\n}\\n\\npub fn eat_bytestring_choice(bytestrings: Vec<Vec<u8>>) -> FastCombinatorWrapper {\\n    // Convert into a regex.\\n    let mut children = vec![];\\n    for bytes in bytestrings {\\n        children.push(eat_bytestring_fast(bytes));\\n    }\\n    fast_combinator(choice_fast(children))\\n}\\n\\npub fn eat_string_choice(strings: &[&str]) -> FastCombinatorWrapper {\\n    let mut children = vec![];\\n    for s in strings {\\n        children.push(eat_string_fast(s));\\n    }\\n    fast_combinator(choice_fast(children))\\n}\", \"src/_03_combinators/core/mod.rs\": \"\\n// src/_03_combinators/core/mod.rs\\nmod choicen;\\nmod choice;\\nmod eat;\\nmod fast;\\nmod opt;\\nmod repeat1;\\nmod seq;\\nmod seqn;\\nmod choice_macro;\\nmod seq_macro;\\n\\npub use choice::*;\\npub use choicen::*;\\npub use eat::*;\\npub use fast::*;\\n\\npub use opt::*;\\npub use repeat1::*;\\npub use seq::*;\\npub use seqn::*;\\npub use choice_macro::*;\\npub use seq_macro::*;\", \"src/_03_combinators/core/opt.rs\": \"\\n// src/_03_combinators/core/opt.rs\\nuse crate::BaseCombinatorTrait;\\nuse crate::*;\\n\\n#[derive(Debug)]\\npub struct Opt<T: CombinatorTrait> {\\n    pub(crate) inner: T,\\n    pub(crate) greedy: bool,\\n}\\n\\nimpl<T: CombinatorTrait> DynCombinatorTrait for Opt<T> {\\n    fn parse_dyn<'a, 'b>(&'a self, right_data: RightData, bytes: &'b [u8]) -> (Box<dyn ParserTrait<Self::Output> + 'a>, ParseResults<Self::Output>) where Self::Output: 'b {\\n        let (parser, parse_results) = self.parse(right_data, bytes);\\n        (Box::new(parser), parse_results)\\n    }\\n\\n    fn one_shot_parse_dyn<'a, 'b>(&'a self, right_data: RightData, bytes: &'b [u8]) -> UnambiguousParseResults<Self::Output> where Self::Output: 'b {\\n        self.one_shot_parse(right_data, bytes)\\n    }\\n}\\n\\nimpl<T: CombinatorTrait> CombinatorTrait for Opt<T> {\\n    type Parser<'a> = T::Parser<'a> where Self: 'a;\\n    type Output = Option<T::Output>;\\n\\n    fn one_shot_parse<'b>(&self, right_data: RightData, bytes: &'b [u8]) -> UnambiguousParseResults<Self::Output> where Self::Output: 'b {\\n        let parse_result = self.inner.one_shot_parse(right_data.clone(), bytes);\\n        if self.greedy {\\n            match parse_result {\\n                Ok(one_shot_up_data) => Ok(OneShotUpData::new(one_shot_up_data.just_right_data(), Some(one_shot_up_data.output))), // Add output\\n                Err(UnambiguousParseError::Fail) => Ok(OneShotUpData::new(right_data, None)), // Add output\\n                Err(UnambiguousParseError::Incomplete | UnambiguousParseError::Ambiguous) => parse_result,\\n            }\\n        } else {\\n            match parse_result {\\n                Ok(_) => Err(UnambiguousParseError::Ambiguous),\\n                Err(UnambiguousParseError::Fail) => Ok(OneShotUpData::new(right_data, None)), // Add output\\n                Err(UnambiguousParseError::Incomplete | UnambiguousParseError::Ambiguous) => parse_result,\\n            }\\n        }\\n    }\\n\\n    fn old_parse<'a, 'b>(&self, right_data: RightData, bytes: &'b [u8]) -> (Self::Parser<'a>, ParseResults<Self::Output>) where Self::Output: 'b {\\n        let (parser, mut parse_results) = self.inner.parse(right_data.clone(), bytes);\\n        if !(self.greedy && parse_results.succeeds_decisively()) {\\n            // TODO: remove the condition below. It's a hack.\\n            // if parse_results.up_data_vec.is_empty() {  // TODO: remove this line\\n                parse_results.up_data_vec.push(UpData::new(right_data, None)); // Add output\\n            // }\\n        }\\n        (parser, parse_results)\\n    }\\n}\\n\\nimpl<T: CombinatorTrait> BaseCombinatorTrait for Opt<T> {\\n    fn as_any(&self) -> &dyn std::any::Any where Self: 'static {\\n        self\\n    }\\n    fn apply_to_children(&self, f: &mut dyn FnMut(&dyn BaseCombinatorTrait)) {\\n        f(&self.inner);\\n    }\\n}\\n\\npub fn opt<T: IntoCombinator>(a: T) -> Opt<T::Output> {\\n    Opt { inner: a.into_combinator(), greedy: false }\\n}\\n\\npub fn opt_greedy(a: impl IntoCombinator)-> impl CombinatorTrait {\\n    profile_internal(\\\"opt_greedy\\\", Opt { inner: a.into_combinator(), greedy: true })\\n}\"} "
    },
    {
      "role": "user",
      "content": "/generate src/_03_combinators/core/seq_macro.rs"
    },
    {
      "role": "model",
      "content": "{\"src/_03_combinators/core/seq_macro.rs\": \"use crate::IntoCombinator;\\n\\npub fn seqn_helper<T: IntoCombinator>(x: T) -> T::Output {\\n    IntoCombinator::into_combinator(x)\\n}\\n\\n#[macro_export]\\nmacro_rules! seq {\\n    ($c0:expr $(,)?) => {{\\n        $c0\\n    }};\\n    ($c0:expr, $c1:expr $(,)?) => {{\\n        use $crate::seqn_helper as h;\\n        $crate::Seq2 {\\n            c0: $crate::IntoCombinator::into_combinator($c0),\\n            c1: h($c1),\\n        }\\n    }};\\n    ($c0:expr, $c1:expr, $c2:expr $(,)?) => {{\\n        use $crate::seqn_helper as h;\\n        $crate::Seq3 {\\n            c0: $crate::IntoCombinator::into_combinator($c0),\\n            c1: h($c1),\\n            c2: h($c2),\\n        }\\n    }};\\n    ($c0:expr, $c1:expr, $c2:expr, $c3:expr $(,)?) => {{\\n        use $crate::seqn_helper as h;\\n        $crate::Seq4 {\\n            c0: $crate::IntoCombinator::into_combinator($c0),\\n            c1: h($c1),\\n            c2: h($c2),\\n            c3: h($c3),\\n        }\\n    }};\\n    ($c0:expr, $c1:expr, $c2:expr, $c3:expr, $c4:expr $(,)?) => {{\\n        use $crate::seqn_helper as h;\\n        $crate::Seq5 {\\n            c0: $crate::IntoCombinator::into_combinator($c0),\\n            c1: h($c1),\\n            c2: h($c2),\\n            c3: h($c3),\\n            c4: h($c4),\\n        }\\n    }};\\n    ($c0:expr, $c1:expr, $c2:expr, $c3:expr, $c4:expr, $c5:expr $(,)?) => {{\\n        use $crate::seqn_helper as h;\\n        $crate::Seq6 {\\n            c0: $crate::IntoCombinator::into_combinator($c0),\\n            c1: h($c1),\\n            c2: h($c2),\\n            c3: h($c3),\\n            c4: h($c4),\\n            c5: h($c5),\\n        }\\n    }};\\n    ($c0:expr, $c1:expr, $c2:expr, $c3:expr, $c4:expr, $c5:expr, $c6:expr $(,)?) => {{\\n        use $crate::seqn_helper as h;\\n        $crate::Seq7 {\\n            c0: $crate::IntoCombinator::into_combinator($c0),\\n            c1: h($c1),\\n            c2: h($c2),\\n            c3: h($c3),\\n            c4: h($c4),\\n            c5: h($c5),\\n            c6: h($c6),\\n        }\\n    }};\\n    ($c0:expr, $c1:expr, $c2:expr, $c3:expr, $c4:expr, $c5:expr, $c6:expr, $c7:expr $(,)?) => {{\\n        use $crate::seqn_helper as h;\\n        $crate::Seq8 {\\n            c0: $crate::IntoCombinator::into_combinator($c0),\\n            c1: h($c1),\\n            c2: h($c2),\\n            c3: h($c3),\\n            c4: h($c4),\\n            c5: h($c5),\\n            c6: h($c6),\\n            c7: h($c7),\\n        }\\n    }};\\n    ($c0:expr, $c1:expr, $c2:expr, $c3:expr, $c4:expr, $c5:expr, $c6:expr, $c7:expr, $c8:expr $(,)?) => {{\\n        use $crate::seqn_helper as h;\\n        $crate::Seq9 {\\n            c0: $crate::IntoCombinator::into_combinator($c0),\\n            c1: h($c1),\\n            c2: h($c2),\\n            c3: h($c3),\\n            c4: h($c4),\\n            c5: h($c5),\\n            c6: h($c6),\\n            c7: h($c7),\\n            c8: h($c8),\\n        }\\n    }};\\n    ($c0:expr, $c1:expr, $c2:expr, $c3:expr, $c4:expr, $c5:expr, $c6:expr, $c7:expr, $c8:expr, $c9:expr $(,)?) => {{\\n        use $crate::seqn_helper as h;\\n        $crate::Seq10 {\\n            c0: $crate::IntoCombinator::into_combinator($c0),\\n            c1: h($c1),\\n            c2: h($c2),\\n            c3: h($c3),\\n            c4: h($c4),\\n            c5: h($c5),\\n            c6: h($c6),\\n            c7: h($c7),\\n            c8: h($c8),\\n            c9: h($c9),\\n        }\\n    }};\\n    ($c0:expr, $c1:expr, $c2:expr, $c3:expr, $c4:expr, $c5:expr, $c6:expr, $c7:expr, $c8:expr, $c9:expr, $c10:expr $(,)?) => {{\\n        use $crate::seqn_helper as h;\\n        $crate::Seq11 {\\n            c0: $crate::IntoCombinator::into_combinator($c0),\\n            c1: h($c1),\\n            c2: h($c2),\\n            c3: h($c3),\\n            c4: h($c4),\\n            c5: h($c5),\\n            c6: h($c6),\\n            c7: h($c7),\\n            c8: h($c8),\\n            c9: h($c9),\\n            c10: h($c10),\\n        }\\n    }};\\n    ($c0:expr, $c1:expr, $c2:expr, $c3:expr, $c4:expr, $c5:expr, $c6:expr, $c7:expr, $c8:expr, $c9:expr, $c10:expr, $c11:expr $(,)?) => {{\\n        use $crate::seqn_helper as h;\\n        $crate::Seq12 {\\n            c0: $crate::IntoCombinator::into_combinator($c0),\\n            c1: h($c1),\\n            c2: h($c2),\\n            c3: h($c3),\\n            c4: h($c4),\\n            c5: h($c5),\\n            c6: h($c6),\\n            c7: h($c7),\\n            c8: h($c8),\\n            c9: h($c9),\\n            c10: h($c10),\\n            c11: h($c11),\\n        }\\n    }};\\n    ($c0:expr, $c1:expr, $c2:expr, $c3:expr, $c4:expr, $c5:expr, $c6:expr, $c7:expr, $c8:expr, $c9:expr, $c10:expr, $c11:expr, $c12:expr $(,)?) => {{\\n        use $crate::seqn_helper as h;\\n        $crate::Seq13 {\\n            c0: $crate::IntoCombinator::into_combinator($c0),\\n            c1: h($c1),\\n            c2: h($c2),\\n            c3: h($c3),\\n            c4: h($c4),\\n            c5: h($c5),\\n            c6: h($c6),\\n            c7: h($c7),\\n            c8: h($c8),\\n            c9: h($c9),\\n            c10: h($c10),\\n            c11: h($c11),\\n            c12: h($c12),\\n        }\\n    }};\\n    ($c0:expr, $c1:expr, $c2:expr, $c3:expr, $c4:expr, $c5:expr, $c6:expr, $c7:expr, $c8:expr, $c9:expr, $c10:expr, $c11:expr, $c12:expr, $c13:expr $(,)?) => {{\\n        use $crate::seqn_helper as h;\\n        $crate::Seq14 {\\n            c0: $crate::IntoCombinator::into_combinator($c0),\\n            c1: h($c1),\\n            c2: h($c2),\\n            c3: h($c3),\\n            c4: h($c4),\\n            c5: h($c5),\\n            c6: h($c6),\\n            c7: h($c7),\\n            c8: h($c8),\\n            c9: h($c9),\\n            c10: h($c10),\\n            c11: h($c11),\\n            c12: h($c12),\\n            c13: h($c13),\\n        }\\n    }};\\n    ($c0:expr, $c1:expr, $c2:expr, $c3:expr, $c4:expr, $c5:expr, $c6:expr, $c7:expr, $c8:expr, $c9:expr, $c10:expr, $c11:expr, $c12:expr, $c13:expr, $c14:expr $(,)?) => {{\\n        use $crate::seqn_helper as h;\\n        $crate::Seq15 {\\n            c0: $crate::IntoCombinator::into_combinator($c0),\\n            c1: h($c1),\\n            c2: h($c2),\\n            c3: h($c3),\\n            c4: h($c4),\\n            c5: h($c5),\\n            c6: h($c6),\\n            c7: h($c7),\\n            c8: h($c8),\\n            c9: h($c9),\\n            c10: h($c10),\\n            c11: h($c11),\\n            c12: h($c12),\\n            c13: h($c13),\\n            c14: h($c14),\\n        }\\n    }};\\n    ($c0:expr, $c1:expr, $c2:expr, $c3:expr, $c4:expr, $c5:expr, $c6:expr, $c7:expr, $c8:expr, $c9:expr, $c10:expr, $c11:expr, $c12:expr, $c13:expr, $c14:expr, $c15:expr $(,)?) => {{\\n        use $crate::seqn_helper as h;\\n        $crate::Seq16 {\\n            c0: $crate::IntoCombinator::into_combinator($c0),\\n            c1: h($c1),\\n            c2: h($c2),\\n            c3: h($c3),\\n            c4: h($c4),\\n            c5: h($c5),\\n            c6: h($c6),\\n            c7: h($c7),\\n            c8: h($c8),\\n            c9: h($c9),\\n            c10: h($c10),\\n            c11: h($c11),\\n            c12: h($c12),\\n            c13: h($c13),\\n            c14: h($c14),\\n            c15: h($c15),\\n        }\\n    }};\\n    ($c0:expr, $c1:expr, $c2:expr, $c3:expr, $c4:expr, $c5:expr, $c6:expr, $c7:expr, $c8:expr, $c9:expr, $c10:expr, $c11:expr, $c12:expr, $c13:expr, $c14:expr, $c15:expr, $($rest:expr),+ $(,)?) => {{\\n        fn convert<T: $crate::IntoCombinator>(x: T) -> Box<dyn $crate::CombinatorTrait> where T::Output {\\n            Box::new(x.into_combinator())\\n        }\\n\\n        $crate::_seq(vec![convert($c0), convert($c1), convert($c2), convert($c3), convert($c4), convert($c5), convert($c6), convert($c7), convert($c8), convert($c9), convert($c10), convert($c11), convert($c12), convert($c13), convert($c14), convert($c15), $(convert($rest)),+])\\n    }};\\n}\"} "
    },
    {
      "role": "user",
      "content": "/generate src/_03_combinators/core/seqn.rs src/_03_combinators/derived.rs"
    },
    {
      "role": "model",
      "content": "{\"src/_03_combinators/core/seqn.rs\": \"\\n// src/_03_combinators/core/seqn.rs\\nuse crate::{BaseCombinatorTrait, CombinatorTrait, IntoCombinator, ParseResultTrait, ParseResults, ParserTrait, RightData, RightDataGetters, Squash, U8Set, UnambiguousParseResults, VecY, UpData, OneShotUpData};\\n\\nmacro_rules! profile {\\n    ($name:expr, $expr:expr) => {\\n        $expr\\n    };\\n}\\n\\nmacro_rules! count_hit { ($tag:expr) => {} }\\n\\n#[macro_export]\\nmacro_rules! define_seq {\\n    ($seq_name:ident, $seq_parser_name:ident, $seq_enum_name:ident, $seq_partial_enum_name:ident, $first:ident, $($rest:ident),+ $(,)?) => {\\n        #[derive(Debug)]\\n        pub struct $seq_name<$first, $($rest),+>\\n        where\\n            $($rest: CombinatorTrait),+\\n        {\\n            pub(crate) $first: $first,\\n            $(pub(crate) $rest: $rest),+\\n        }\\n\\n        #[derive(Debug)]\\n        pub struct $seq_parser_name<'a, $first, $($rest),+>\\n        where\\n            $first: CombinatorTrait,\\n            $($rest: CombinatorTrait),+\\n        {\\n            pub(crate) combinator: &'a $seq_name<$first, $($rest),+>,\\n            pub(crate) $first: Option<$first::Parser<'a>>,\\n            $(pub(crate) $rest: Vec<$rest::Parser<'a>>,)+\\n            pub(crate) position: usize,\\n        }\\n\\n        #[derive(Debug)]\\n        pub struct $seq_enum_name<$first, $($rest),+>\\n        where\\n            $first: CombinatorTrait,\\n            $($rest: CombinatorTrait),+\\n        {\\n            pub(crate) $first: $first::Output,\\n            $(pub(crate) $rest: $rest::Output),+\\n        }\\n\\n        #[derive(Debug)]\\n        pub struct $seq_partial_enum_name<$first, $($rest),+>\\n        where\\n            $first: CombinatorTrait,\\n            $($rest: CombinatorTrait),+\\n        {\\n            pub(crate) $first: Option<$first::Output>,\\n            $(pub(crate) $rest: Option<$rest::Output>),+\\n        }\\n\\n        impl<$first, $($rest),+> $crate::DynCombinatorTrait for $seq_name<$first, $($rest),+>\\n        where\\n            $first: CombinatorTrait,\\n            $($rest: CombinatorTrait),+,\\n        {\\n            fn parse_dyn(&self, right_data: RightData, bytes: &[u8]) -> (Box<dyn ParserTrait<Self::Output> + '_>, ParseResults<Self::Output>) {\\n                let (parser, parse_results) = self.parse(right_data, bytes);\\n                (Box::new(parser), parse_results)\\n            }\\n\\n            fn one_shot_parse_dyn(&self, right_data: RightData, bytes: &[u8]) -> UnambiguousParseResults<Self::Output> {\\n                self.one_shot_parse(right_data, bytes)\\n            }\\n        }\\n\\n        impl<$first, $($rest),+> CombinatorTrait for $seq_name<$first, $($rest),+>\\n        where\\n            $first: CombinatorTrait,\\n            $($rest: CombinatorTrait),+,\\n        {\\n            type Parser<'a> = $seq_parser_name<'a, $first, $($rest),+> where Self: 'a;\\n            type Output = $seq_enum_name<$first, $($rest),+>;\\n\\n            fn one_shot_parse<'b>(&self, right_data: RightData, bytes: &'b [u8]) -> $crate::UnambiguousParseResults<Self::Output> where Self::Output: 'b {\\n                let mut right_data = right_data;\\n                let start_position = right_data.get_fields1().position;\\n                let result = self.$first.one_shot_parse(right_data, bytes);\\n                match result {\\n                    Ok(one_shot_up_data) => {\\n                        right_data = one_shot_up_data.just_right_data();\\n                    },\\n                    Err(err) => {\\n                        return Err(err);\\n                    }\\n                }\\n                $(\\n                    let offset = right_data.get_fields1().position - start_position;\\n                    let result = self.$rest.one_shot_parse(right_data, &bytes[offset..]);\\n                    match result {\\n                        Ok(one_shot_up_data) => {\\n                            right_data = one_shot_up_data.just_right_data();\\n                        },\\n                        Err(err) => {\\n                            return Err(err);\\n                        }\\n                    }\\n                )+\\n                $crate::UnambiguousParseResults::Ok(OneShotUpData::new(right_data, $seq_enum_name {\\n                    $first: one_shot_up_data.output,\\n                    $($rest: one_shot_up_data.output),+\\n                }))\\n            }\\n\\n            fn old_parse<'a, 'b>(&'a self, right_data: RightData, bytes: &'b [u8]) -> (Self::Parser<'a>, ParseResults<Self::Output>) where Self::Output: 'b {\\n                let start_position = right_data.get_fields1().position;\\n\\n                let first_combinator = &self.$first;\\n                let (first_parser, first_parse_results) = profile!(stringify!($seq_name, \\\" first child parse\\\"), {\\n                    first_combinator.parse(right_data, &bytes)\\n                });\\n\\n                let mut all_done = first_parse_results.done();\\n                if all_done && first_parse_results.up_data_vec.is_empty() {\\n                    // Shortcut\\n                    return (\\n                        $seq_parser_name {\\n                            combinator: self,\\n                            $first: None,\\n                            $($rest: vec![],)+\\n                            position: start_position + bytes.len(),\\n                        },\\n                        first_parse_results\\n                    );\\n                }\\n                let first_parser_vec = if all_done { None } else { Some(first_parser) };\\n\\n                let mut next_up_data_vec = first_parse_results.up_data_vec;\\n\\n                fn helper<'a, T: CombinatorTrait>(right_data: RightData, next_combinator: &'a T, bytes: &[u8], start_position: usize) -> (T::Parser<'a>, ParseResults<T::Output>) {\\n                    let offset = right_data.get_fields1().position - start_position;\\n                    profile!(stringify!($seq_name, \\\" child parse\\\"), {\\n                        next_combinator.parse(right_data, &bytes[offset..])\\n                    })\\n                }\\n\\n                let mut seqn_parser = $seq_parser_name {\\n                    combinator: self,\\n                    $first: first_parser_vec,\\n                    $($rest: vec![],)+\\n                    position: start_position + bytes.len(),\\n                };\\n\\n                // process each child combinator\\n                $(\\n                    if next_up_data_vec.is_empty() {\\n                        return (seqn_parser, ParseResults::empty(all_done));\\n                    }\\n\\n                    let mut next_next_up_data_vec = VecY::new();\\n                    for up_data in next_up_data_vec {\\n                        let (parser, parse_results) = helper(up_data.just_right_data(), &self.$rest, &bytes, start_position);\\n                        if !parse_results.done() {\\n                            all_done = false;\\n                            seqn_parser.$rest.push(parser);\\n                        }\\n                        next_next_up_data_vec.extend(parse_results.up_data_vec);\\n                    }\\n                    next_up_data_vec = next_next_up_data_vec;\\n                )+\\n\\n                let parse_results = ParseResults::new(next_up_data_vec, all_done);\\n\\n                (seqn_parser, parse_results)\\n            }\\n        }\\n\\n        impl<'a, $first, $($rest),+> ParserTrait<$seq_enum_name<$first, $($rest),+>> for $seq_parser_name<'a, $first, $($rest),+>\\n        where\\n            $first: CombinatorTrait,\\n            $($rest: CombinatorTrait),+\\n        {\\n            fn get_u8set(&self) -> U8Set {\\n                let mut u8set = U8Set::none();\\n                if let Some(parser) = &self.$first {\\n                    u8set = u8set.union(&parser.get_u8set());\\n                }\\n                $(\\n                    for parser in &self.$rest {\\n                        u8set = u8set.union(&parser.get_u8set());\\n                    }\\n                )+\\n                u8set\\n            }\\n\\n            fn parse<'b>(&mut self, bytes: &'b [u8]) -> ParseResults<$seq_enum_name<$first, $($rest),+>> where $seq_enum_name<$first, $($rest),+>: 'b {\\n                profile!(stringify!($seq_parser_name, \\\"::parse\\\"), {\\n                    let mut new_up_data: VecY<UpData<$seq_enum_name<$first, $($rest),+>>> = VecY::new();\\n\\n                    // first child\\n                    if let Some(parser) = &mut self.$first {\\n                        let parse_results = profile!(stringify!($seq_parser_name, \\\"::parse child Parser::parse\\\"), { parser.parse(bytes) });\\n                        new_up_data.extend(parse_results.up_data_vec);\\n                        if parse_results.done {\\n                            self.$first = None;\\n                        }\\n                    }\\n\\n                    let mut all_done = self.$first.is_none();\\n\\n                    // rest of the children\\n                    $(\\n                        let mut up_data_to_init_this_child = std::mem::take(&mut new_up_data);\\n                        // TODO: Squashing after each sequent is good for performance (~5% gain on Python parser), but makes it difficult to reason about building the parse tree.\\n                        //  So, I'm leaving it out for now. But it'd be good to revisit this and see if we could bring it back.\\n                        // up_data_to_init_this_child.squash();\\n\\n                        // step existing parsers for this child\\n                        self.$rest.retain_mut(|parser| {\\n                            let parse_results = profile!(stringify!($seq_parser_name, \\\"::parse child Parser::parse\\\"), {\\n                                parser.parse(bytes)\\n                            });\\n                            new_up_data.extend(parse_results.up_data_vec);\\n                            !parse_results.done\\n                        });\\n\\n                        // new parsers for this child, one for each right_data emitted by the previous child\\n                        for up_data in up_data_to_init_this_child {\\n                            let offset = up_data.get_fields1().position - self.position;\\n                            let combinator = &self.combinator.$rest;\\n                            let (parser, parse_results) = profile!(stringify!($seq_parser_name, \\\"::parse child Combinator::parse\\\"), {\\n                                combinator.parse(up_data.just_right_data(), &bytes[offset..])\\n                            });\\n                            if !parse_results.done() {\\n                                self.$rest.push(parser);\\n                            }\\n                            new_up_data.extend(parse_results.up_data_vec);\\n                        }\\n\\n                        all_done &= self.$rest.is_empty();\\n                    )+\\n\\n                    self.position += bytes.len();\\n\\n                    ParseResults::new(new_up_data, all_done)\\n                })\\n            }\\n        }\\n\\n        impl<$first, $($rest),+> BaseCombinatorTrait for $seq_name<$first, $($rest),+>\\n        where\\n            $first: CombinatorTrait,\\n            $($rest: CombinatorTrait),+,\\n        {\\n            fn as_any(&self) -> &dyn std::any::Any where Self: 'static {\\n                self\\n            }\\n\\n            fn apply_to_children(&self, f: &mut dyn FnMut(&dyn BaseCombinatorTrait)) {\\n                f(&self.$first);\\n                $(f(&self.$rest);)+\\n            }\\n        }\\n    };\\n}\\n\\ndefine_seq!(Seq2, Seq2Parser, Seq2Enum, Seq2PartialEnum, c0, c1);\\ndefine_seq!(Seq3, Seq3Parser, Seq3Enum, Seq3PartialEnum, c0, c1, c2);\\ndefine_seq!(Seq4, Seq4Parser, Seq4Enum, Seq4PartialEnum, c0, c1, c2, c3);\\ndefine_seq!(Seq5, Seq5Parser, Seq5Enum, Seq5PartialEnum, c0, c1, c2, c3, c4);\\ndefine_seq!(Seq6, Seq6Parser, Seq6Enum, Seq6PartialEnum, c0, c1, c2, c3, c4, c5);\\ndefine_seq!(Seq7, Seq7Parser, Seq7Enum, Seq7PartialEnum, c0, c1, c2, c3, c4, c5, c6);\\ndefine_seq!(Seq8, Seq8Parser, Seq8Enum, Seq8PartialEnum, c0, c1, c2, c3, c4, c5, c6, c7);\\ndefine_seq!(Seq9, Seq9Parser, Seq9Enum, Seq9PartialEnum, c0, c1, c2, c3, c4, c5, c6, c7, c8);\\ndefine_seq!(Seq10, Seq10Parser, Seq10Enum, Seq10PartialEnum, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9);\\ndefine_seq!(Seq11, Seq11Parser, Seq11Enum, Seq11PartialEnum, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, c10);\\ndefine_seq!(Seq12, Seq12Parser, Seq12Enum, Seq12PartialEnum, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11);\\ndefine_seq!(Seq13, Seq13Parser, Seq13Enum, Seq13PartialEnum, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12);\", \"src/_03_combinators/derived.rs\": \"\\n// src/_03_combinators/derived.rs\\nuse crate::{opt, opt_greedy, repeat0, repeat0_greedy, seq, symbol, Choice, RightData, UpData, OneShotUpData};\\nuse crate::{CombinatorTrait, IntoDyn};\\n\\npub fn seprep1(a: impl CombinatorTrait, b: impl CombinatorTrait)-> impl CombinatorTrait {\\n    let a = symbol(a);\\n    seq!(&a, repeat0(seq!(b, &a)))\\n}\\n\\npub fn seprep0(a: impl CombinatorTrait, b: impl CombinatorTrait)-> impl CombinatorTrait {\\n    opt(seprep1(a, b))\\n}\\n\\npub fn repeatn<'a>(n: usize, a: impl CombinatorTrait + 'a)-> impl CombinatorTrait {\\n    let a = symbol(a);\\n    // Choice { children: Rc::new(vecx![a; n]), greedy: false }.into()\\n    Choice { children: vec![a; n].into_iter().map(IntoDyn::into_dyn).collect(), greedy: false }\\n}\\n\\npub fn seprep1_greedy(a: impl CombinatorTrait, b: impl CombinatorTrait)-> impl CombinatorTrait {\\n    let a = symbol(a);\\n    seq!(&a, repeat0_greedy(seq!(b, &a)))\\n}\\n\\npub fn seprep0_greedy(a: impl CombinatorTrait, b: impl CombinatorTrait)-> impl CombinatorTrait {\\n    opt_greedy(seprep1_greedy(a, b))\\n}\\n\\npub fn repeatn_greedy<'a>(n: usize, a: impl CombinatorTrait + 'a)-> impl CombinatorTrait {\\n    let a = symbol(a);\\n    Choice { children: vec![a; n].into_iter().map(IntoDyn::into_dyn).collect(), greedy: true }\\n}\"} "
    },
    {
      "role": "user",
      "content": "/generate src/_03_combinators/lookaheads/lookahead.rs src/_03_combinators/lookaheads/mod.rs src/_03_combinators/lookaheads/negative_lookahead.rs src/_03_combinators/mod.rs src/_03_combinators/nullable/check_right_data.rs"
    },
    {
      "role": "model",
      "content": "{\"src/_03_combinators/lookaheads/lookahead.rs\": \"\\n// src/_03_combinators/lookaheads/lookahead.rs\\nuse crate::BaseCombinatorTrait;\\nuse crate::*;\\n\\n#[derive(Debug)]\\npub struct PartialLookahead {\\n    pub parser: Box<dyn ParserTrait>,\\n    pub positive: bool,\\n}\\n\\n#[repr(transparent)]\\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\\npub struct LookaheadData {\\n    pub has_omitted_partial_lookaheads: bool,\\n}\\n\\nimpl Default for LookaheadData {\\n    fn default() -> Self {\\n        // LookaheadData { partial_lookaheads: vec![PartialLookahead { parser: Box::new(Parser::FailParser(FailParser)), positive: true }] }\\n        LookaheadData { has_omitted_partial_lookaheads: false }\\n    }\\n}\\n\\n#[derive(Debug)]\\npub struct Lookahead<T: CombinatorTrait> {\\n    pub combinator: Box<T>,\\n    pub positive: bool,\\n    pub persist_with_partial_lookahead: bool,\\n}\\n\\nimpl<T: CombinatorTrait> DynCombinatorTrait for Lookahead<T> {\\n    fn parse_dyn<'a, 'b>(&'a self, right_data: RightData, bytes: &'b [u8]) -> (Box<dyn ParserTrait<Self::Output> + 'a>, ParseResults<Self::Output>) where Self::Output: 'b {\\n        let (parser, parse_results) = self.parse(right_data, bytes);\\n        (Box::new(parser), parse_results)\\n    }\\n\\n    fn one_shot_parse_dyn<'a, 'b>(&'a self, right_data: RightData, bytes: &'b [u8]) -> UnambiguousParseResults<Self::Output> where Self::Output: 'b {\\n        self.one_shot_parse(right_data, bytes)\\n    }\\n}\\n\\nimpl<T: CombinatorTrait> CombinatorTrait for Lookahead<T> {\\n    type Parser<'a> = FailParser where Self: 'a;\\n    type Output = T::Output;\\n\\n    fn one_shot_parse<'b>(&self, right_data: RightData, bytes: &'b [u8]) -> UnambiguousParseResults<Self::Output> where Self::Output: 'b {\\n        let parse_result = self.combinator.one_shot_parse(right_data.clone(), bytes);\\n        if self.positive {\\n            match parse_result {\\n                Ok(_) => Ok(OneShotUpData::new(right_data, ())), // Add output\\n                Err(_) => parse_result,\\n            }\\n        } else {\\n            match parse_result {\\n                Ok(_) => Err(UnambiguousParseError::Fail),\\n                Err(UnambiguousParseError::Fail) => Ok(OneShotUpData::new(right_data, ())), // Add output\\n                Err(UnambiguousParseError::Ambiguous | UnambiguousParseError::Incomplete) => parse_result,\\n            }\\n        }\\n    }\\n    fn old_parse<'a, 'b>(&self, mut right_data: RightData, bytes: &'b [u8]) -> (Self::Parser<'a>, ParseResults<Self::Output>) where Self::Output: 'b {\\n        let (parser, mut parse_results) = self.combinator.parse(right_data.clone(), bytes);\\n        let has_up_data = !parse_results.up_data_vec.is_empty();\\n        let succeeds = if self.positive {\\n            // A positive lookahead succeeds if it yields up_data now or it *could* yield up_data later (i.e. it's not done yet)\\n            has_up_data || !parse_results.done()\\n        } else {\\n            // A negative lookahead succeeds if it yields no up_data now\\n            !has_up_data\\n        };\\n        if succeeds {\\n            if !parse_results.done() {\\n                    right_data.get_fields1_mut().lookahead_data.has_omitted_partial_lookaheads = true;\\n            }\\n            (FailParser, ParseResults::new_single(UpData::new(right_data, ()), true)) // Add output\\n        } else {\\n            (FailParser, ParseResults::empty_finished())\\n        }\\n    }\\n}\\n\\nimpl<T: CombinatorTrait> BaseCombinatorTrait for Lookahead<T> {\\n    fn as_any(&self) -> &dyn std::any::Any where Self: 'static {\\n        self\\n    }\\n    fn apply_to_children(&self, f: &mut dyn FnMut(&dyn BaseCombinatorTrait)) {\\n        f(&self.combinator);\\n    }\\n}\\n\\npub fn lookahead(combinator: impl CombinatorTrait) -> impl CombinatorTrait {\\n    Lookahead { combinator: Box::new(Box::new(combinator)), positive: true, persist_with_partial_lookahead: false }\\n}\\n\\npub fn negative_lookahead(combinator: impl CombinatorTrait) -> impl CombinatorTrait {\\n    Lookahead { combinator: Box::new(Box::new(combinator)), positive: false, persist_with_partial_lookahead: false }\\n}\", \"src/_03_combinators/lookaheads/mod.rs\": \"\\n// src/_03_combinators/lookaheads/mod.rs\\nmod lookahead;\\nmod negative_lookahead;\\n\\npub use lookahead::*;\\npub use negative_lookahead::*;\", \"src/_03_combinators/lookaheads/negative_lookahead.rs\": \"\\n// src/_03_combinators/lookaheads/negative_lookahead.rs\\nuse crate::tokenizer::finite_automata::{Expr, Regex, RegexState};\\nuse crate::BaseCombinatorTrait;\\nuse crate::*;\\n// src/combinators/negative_lookahead.rs\\nuse std::collections::HashMap;\\n\\n#[derive(Debug)]\\npub struct ExcludeBytestrings<T: CombinatorTrait> {\\n    pub(crate) inner: T,\\n    pub(crate) regex: Regex,\\n}\\n\\n#[derive(Debug)]\\npub struct ExcludeBytestringsParser<'a, T: CombinatorTrait + 'a> {\\n    pub(crate) inner: T::Parser<'a>,\\n    pub(crate) regex_state: RegexState<'a>,\\n    pub(crate) position: usize,\\n}\\n\\nimpl<T: CombinatorTrait> DynCombinatorTrait for ExcludeBytestrings<T> {\\n    fn parse_dyn<'a, 'b>(&'a self, right_data: RightData, bytes: &'b [u8]) -> (Box<dyn ParserTrait<Self::Output> + 'a>, ParseResults<Self::Output>) where Self::Output: 'b {\\n        let (parser, parse_results) = self.parse(right_data, bytes);\\n        (Box::new(parser), parse_results)\\n    }\\n\\n    fn one_shot_parse_dyn<'a, 'b>(&'a self, right_data: RightData, bytes: &'b [u8]) -> UnambiguousParseResults<Self::Output> where Self::Output: 'b {\\n        self.one_shot_parse(right_data, bytes)\\n    }\\n}\\n\\nimpl<T: CombinatorTrait> CombinatorTrait for ExcludeBytestrings<T> {\\n    type Parser<'a> = ExcludeBytestringsParser<'a, T> where T: 'a;\\n    type Output = T::Output;\\n\\n    fn one_shot_parse<'b>(&self, right_data: RightData, bytes: &'b [u8]) -> UnambiguousParseResults<Self::Output> where Self::Output: 'b {\\n        let start_position = right_data.get_fields1().position;\\n        match self.inner.one_shot_parse(right_data, bytes) {\\n            Ok(one_shot_up_data) => {\\n                let end_position = one_shot_up_data.get_fields1().position;\\n                let mut regex_state = self.regex.init();\\n                regex_state.execute(&bytes[..(end_position - start_position)]);\\n                if regex_state.fully_matches_here() {\\n                    return Err(UnambiguousParseError::Fail);\\n                } else {\\n                    Ok(one_shot_up_data)\\n                }\\n            },\\n            Err(err) => Err(err),\\n        }\\n    }\\n\\n    fn old_parse<'a, 'b>(&self, right_data: RightData, bytes: &'b [u8]) -> (Self::Parser<'a>, ParseResults<Self::Output>) where Self::Output: 'b {\\n        let (inner, mut parse_results) = self.inner.parse(right_data.clone(), bytes);\\n        let mut regex_state = self.regex.init();\\n        let start_position = right_data.get_fields1().position;\\n\\n        // Optimized logic\\n        let mut end_offsets_to_match = HashMap::new();\\n        let mut end_offsets = Vec::new();\\n        for up_data in &parse_results.up_data_vec {\\n            let end_offset = up_data.get_fields1().position - start_position;\\n            end_offsets_to_match.insert(end_offset, false);\\n            end_offsets.push(end_offset);\\n        }\\n        end_offsets.sort();\\n\\n        let mut offset = 0;\\n        for end_offset in end_offsets {\\n            let slice = &bytes[offset..end_offset];\\n            regex_state.execute(slice);\\n            if regex_state.definitely_fully_matches() {\\n                end_offsets_to_match.insert(end_offset, true);\\n            }\\n            offset = end_offset;\\n        }\\n\\n        // Run the regex to the end of the input\\n        regex_state.execute(&bytes[offset..]);\\n\\n        parse_results.up_data_vec.retain(|up_data| {\\n            let position = up_data.get_fields1().position - start_position;\\n            !end_offsets_to_match[&position]\\n        });\\n\\n        (ExcludeBytestringsParser {\\n            inner,\\n            regex_state,\\n            position: start_position + bytes.len(),\\n        }, parse_results)\\n    }\\n}\\n\\nimpl<T: CombinatorTrait> BaseCombinatorTrait for ExcludeBytestrings<T> {\\n    fn as_any(&self) -> &dyn std::any::Any where Self: 'static {\\n        self\\n    }\\n\\n    fn apply_to_children(&self, f: &mut dyn FnMut(&dyn BaseCombinatorTrait)) {\\n        f(&self.inner);\\n    }\\n}\\n\\nimpl<T: CombinatorTrait> ParserTrait<T::Output> for ExcludeBytestringsParser<'_, T> {\\n    fn get_u8set(&self) -> U8Set {\\n        self.inner.get_u8set()\\n    }\\n\\n    fn parse<'b>(&mut self, bytes: &'b [u8]) -> ParseResults<T::Output> where T::Output: 'b {\\n        let mut parse_results = self.inner.parse(bytes);\\n\\n        // Optimized logic\\n        let mut end_offsets_to_match = HashMap::new();\\n        let mut end_offsets = Vec::new();\\n        for up_data in &parse_results.up_data_vec {\\n            let end_offset = up_data.get_fields1().position - self.position;\\n            end_offsets_to_match.insert(end_offset, false);\\n            end_offsets.push(end_offset);\\n        }\\n        end_offsets.sort();\\n\\n        let mut current_offset = 0;\\n        for end_offset in end_offsets {\\n            let slice = &bytes[current_offset..end_offset];\\n            self.regex_state.execute(slice);\\n            if self.regex_state.fully_matches_here() {\\n                end_offsets_to_match.insert(end_offset, true);\\n            }\\n            current_offset = end_offset;\\n        }\\n\\n        // Run the regex to the end of the input\\n        self.regex_state.execute(&bytes[current_offset..]);\\n\\n        parse_results.up_data_vec.retain(|up_data| {\\n            let position = up_data.get_fields1().position - self.position;\\n            !end_offsets_to_match[&position]\\n        });\\n\\n        self.position += bytes.len();\\n        parse_results\\n    }\\n}\\n\\npub fn exclude_strings<T: IntoCombinator + 'static>(inner: T, bytestrings_to_exclude: Vec<&str>)-> impl CombinatorTrait {\\n    let bytestrings_to_exclude: Vec<Vec<u8>> = bytestrings_to_exclude.iter().map(|s| s.as_bytes().to_vec()).collect();\\n    let expr = Expr::Choice(bytestrings_to_exclude.into_iter().map(|bytes| Expr::U8Seq(bytes)).collect());\\n    let regex = expr.build();\\n\\n    ExcludeBytestrings {\\n        inner: inner.into_combinator(),\\n        regex,\\n    }\\n}\", \"src/_03_combinators/mod.rs\": \"\\n// src/_03_combinators/mod.rs\\nmod cache;\\nmod core;\\nmod derived;\\nmod lookaheads;\\nmod nullable;\\nmod wrappers;\\nmod unicode;\\n\\npub use cache::*;\\npub use core::*;\\npub use derived::*;\\n\\npub use lookaheads::*;\\npub use nullable::*;\\npub use unicode::*;\\npub use wrappers::*;\", \"src/_03_combinators/nullable/check_right_data.rs\": \"\\n// src/_03_combinators/nullable/check_right_data.rs\\n// src/combinators/check_right_data.rs\\nuse crate::{BaseCombinatorTrait, DynCombinatorTrait, ParserTrait, UnambiguousParseError, UnambiguousParseResults, RightData, UpData, OneShotUpData};\\nuse crate::{CombinatorTrait, FailParser, ParseResultTrait, ParseResults, RightDataGetters};\\nuse std::fmt::Debug;\\nuse std::hash::{Hash, Hasher};\\n\\npub struct CheckRightData {\\n    pub(crate) run: Box<dyn Fn(&RightData) -> bool>,\\n}\\n\\nimpl Hash for CheckRightData {\\n    fn hash<H: Hasher>(&self, state: &mut H) {\\n        let ptr = std::ptr::addr_of!(self.run) as *const ();\\n        ptr.hash(state);\\n    }\\n}\\n\\nimpl PartialEq for CheckRightData {\\n    fn eq(&self, other: &Self) -> bool {\\n        std::ptr::eq(&self.run, &other.run)\\n    }\\n}\\n\\nimpl Eq for CheckRightData {}\\n\\nimpl Debug for CheckRightData {\\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\\n        f.debug_struct(\\\"CheckRightData\\\").finish()\\n    }\\n}\\n\\nimpl DynCombinatorTrait for CheckRightData {\\n    fn parse_dyn<'a, 'b>(&'a self, right_data: RightData, bytes: &'b [u8]) -> (Box<dyn ParserTrait<Self::Output> + 'a>, ParseResults<Self::Output>) where Self::Output: 'b {\\n        let (parser, parse_results) = self.parse(right_data, bytes);\\n        (Box::new(parser), parse_results)\\n    }\\n\\n    fn one_shot_parse_dyn<'a, 'b>(&'a self, right_data: RightData, bytes: &'b [u8]) -> UnambiguousParseResults<Self::Output> where Self::Output: 'b {\\n        self.one_shot_parse(right_data, bytes)\\n    }\\n}\\n\\nimpl CombinatorTrait for CheckRightData {\\n    type Parser<'a> = FailParser;\\n    type Output = ();\\n\\n    fn one_shot_parse<'b>(&self, right_data: RightData, bytes: &'b [u8]) -> UnambiguousParseResults<Self::Output> where Self::Output: 'b {\\n        if (self.run)(&right_data.clone()) {\\n            Ok(OneShotUpData::new(right_data, ())) // Add output\\n        } else {\\n            Err(UnambiguousParseError::Fail)\\n        }\\n    }\\n\\n    fn old_parse<'a, 'b>(&self, right_data: RightData, bytes: &'b [u8]) -> (Self::Parser<'a>, ParseResults<Self::Output>) where Self::Output: 'b {\\n        if (self.run)(&right_data.clone()) {\\n            (FailParser, ParseResults::new_single(UpData::new(right_data, ()), true)) // Add output\\n        } else {\\n            (FailParser, ParseResults::empty_finished())\\n        }\\n    }\\n}\\n\\nimpl BaseCombinatorTrait for CheckRightData {\\n    fn as_any(&self) -> &dyn std::any::Any where Self: 'static {\\n        self\\n    }\\n}\\n\\npub fn check_right_data(run: impl Fn(&RightData) -> bool + 'static) -> CheckRightData {\\n    CheckRightData { run: Box::new(run) }\\n}\\n\\npub struct MutateRightData {\\n    pub(crate) run: Box<dyn Fn(&mut RightData) -> bool>,\\n}\\n\\nimpl Hash for MutateRightData {\\n    fn hash<H: Hasher>(&self, state: &mut H) {\\n        let ptr = std::ptr::addr_of!(self.run) as *const ();\\n        std::ptr::hash(ptr, state);\\n    }\\n}\\n\\nimpl PartialEq for MutateRightData {\\n    fn eq(&self, other: &Self) -> bool {\\n        std::ptr::eq(&self.run, &other.run)\\n    }\\n}\\n\\nimpl Eq for MutateRightData {}\\n\\nimpl Debug for MutateRightData {\\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\\n        f.debug_struct(\\\"MutateRightData\\\").finish()\\n    }\\n}\\n\\nimpl DynCombinatorTrait for MutateRightData {\\n    fn parse_dyn<'a, 'b>(&'a self, right_data: RightData, bytes: &'b [u8]) -> (Box<dyn ParserTrait<Self::Output> + 'a>, ParseResults<Self::Output>) where Self::Output: 'b {\\n        let (parser, parse_results) = self.parse(right_data, bytes);\\n        (Box::new(parser), parse_results)\\n    }\\n\\n    fn one_shot_parse_dyn<'a, 'b>(&'a self, right_data: RightData, bytes: &'b [u8]) -> UnambiguousParseResults<Self::Output> where Self::Output: 'b {\\n        self.one_shot_parse(right_data, bytes)\\n    }\\n}\\n\\nimpl CombinatorTrait for MutateRightData {\\n    type Parser<'a> = FailParser;\\n    type Output = ();\\n\\n    fn one_shot_parse<'b>(&self, right_data: RightData, bytes: &'b [u8]) -> UnambiguousParseResults<Self::Output> where Self::Output: 'b {\\n        let mut right_data = right_data;\\n        if (self.run)(&mut right_data) {\\n            Ok(OneShotUpData::new(right_data, ())) // Add output\\n        } else {\\n            Err(UnambiguousParseError::Fail)\\n        }\\n    }\\n    fn old_parse<'a, 'b>(&self, right_data: RightData, bytes: &'b [u8]) -> (Self::Parser<'a>, ParseResults<Self::Output>) where Self::Output: 'b {\\n        let mut right_data = right_data;\\n        if (self.run)(&mut right_data) {\\n            (FailParser, ParseResults::new_single(UpData::new(right_data, ()), true)) // Add output\\n        } else {\\n            (FailParser, ParseResults::empty_finished())\\n        }\\n    }\\n}\\n\\nimpl BaseCombinatorTrait for MutateRightData {\\n    fn as_any(&self) -> &dyn std::any::Any where Self: 'static {\\n        self\\n    }\\n}\\n\\npub fn mutate_right_data(run: impl Fn(&mut RightData) -> bool + 'static) -> MutateRightData {\\n    MutateRightData { run: Box::new(run) }\\n}\"} "
    },
    {
      "role": "user",
      "content": "/generate src/_03_combinators/nullable/eps_and_fail.rs src/_03_combinators/nullable/forbid_follows.rs src/_03_combinators/nullable/mod.rs src/_03_combinators/unicode.rs"
    },
    {
      "role": "model",
      "content": "{\"src/_03_combinators/nullable/eps_and_fail.rs\": \"\\n// src/_03_combinators/nullable/eps_and_fail.rs\\nuse crate::_01_parse_state::{ParseResultTrait, RightData, RightDataGetters, UpData, OneShotUpData};\\nuse crate::{BaseCombinatorTrait, DynCombinatorTrait, UnambiguousParseError, UnambiguousParseResults};\\nuse crate::{CombinatorTrait, ParseResults, ParserTrait, U8Set};\\n#[derive(Debug)]\\npub struct Eps;\\n\\n#[derive(Debug)]\\npub struct EpsParser;\\n\\nimpl DynCombinatorTrait for Eps {\\n    fn parse_dyn<'a, 'b>(&'a self, right_data: RightData, bytes: &'b [u8]) -> (Box<dyn ParserTrait<Self::Output> + 'a>, ParseResults<Self::Output>) where Self::Output: 'b {\\n        let (parser, parse_results) = self.parse(right_data, bytes);\\n        (Box::new(parser), parse_results)\\n    }\\n\\n    fn one_shot_parse_dyn<'a, 'b>(&'a self, right_data: RightData, bytes: &'b [u8]) -> UnambiguousParseResults<Self::Output> where Self::Output: 'b {\\n        self.one_shot_parse(right_data, bytes)\\n    }\\n}\\n\\nimpl CombinatorTrait for Eps {\\n    type Parser<'a> = EpsParser;\\n    type Output = ();\\n\\n    fn one_shot_parse<'b>(&self, right_data: RightData, bytes: &'b [u8]) -> UnambiguousParseResults<Self::Output> where Self::Output: 'b {\\n        Ok(OneShotUpData::new(right_data, ())) // Add output\\n    }\\n\\n    fn old_parse<'a, 'b>(&self, right_data: RightData, bytes: &'b [u8]) -> (Self::Parser<'a>, ParseResults<Self::Output>) where Self::Output: 'b {\\n        (EpsParser, ParseResults::new_single(UpData::new(right_data, ()), true)) // Add output\\n    }\\n}\\n\\nimpl BaseCombinatorTrait for Eps {\\n    fn as_any(&self) -> &dyn std::any::Any where Self: 'static {\\n        self\\n    }\\n}\\n\\nimpl<Output: OutputTrait> ParserTrait<Output> for EpsParser {\\n    fn get_u8set(&self) -> U8Set {\\n        panic!(\\\"EpsParser.get_u8set() called\\\")\\n    }\\n\\n    fn parse<'b>(&mut self, bytes: &'b [u8]) -> ParseResults<Output> where Output: 'b {\\n        panic!(\\\"EpsParser already consumed\\\")\\n    }\\n}\\n\\npub fn eps() -> Eps {\\n    Eps\\n}\\n\\n\\n    \\n#[repr(transparent)]\\n#[derive(Debug)]\\npub struct FailParser;\\n\\n#[derive(Debug)]\\npub struct Fail;\\n\\nimpl DynCombinatorTrait for Fail {\\n    fn parse_dyn<'a, 'b>(&'a self, right_data: RightData, bytes: &'b [u8]) -> (Box<dyn ParserTrait<Self::Output> + 'a>, ParseResults<Self::Output>) where Self::Output: 'b {\\n        let (parser, parse_results) = self.parse(right_data, bytes);\\n        (Box::new(parser), parse_results)\\n    }\\n\\n    fn one_shot_parse_dyn<'a, 'b>(&'a self, right_data: RightData, bytes: &'b [u8]) -> UnambiguousParseResults<Self::Output> where Self::Output: 'b {\\n        self.one_shot_parse(right_data, bytes)\\n    }\\n}\\n\\nimpl CombinatorTrait for Fail {\\n    type Parser<'a> = FailParser;\\n    type Output = ();\\n\\n    fn one_shot_parse<'b>(&self, right_data: RightData, bytes: &'b [u8]) -> UnambiguousParseResults<Self::Output> where Self::Output: 'b {\\n        Err(UnambiguousParseError::Fail)\\n    }\\n\\n    fn old_parse<'a, 'b>(&self, right_data: RightData, bytes: &'b [u8]) -> (Self::Parser<'a>, ParseResults<Self::Output>) where Self::Output: 'b {\\n        (FailParser, ParseResults::empty_finished())\\n    }\\n}\\n\\nimpl BaseCombinatorTrait for Fail {\\n    fn as_any(&self) -> &dyn std::any::Any where Self: 'static {\\n        self\\n    }\\n}\\n\\nimpl<Output: OutputTrait> ParserTrait<Output> for FailParser {\\n    fn get_u8set(&self) -> U8Set {\\n        panic!(\\\"FailParser.get_u8set() called\\\")\\n    }\\n\\n    fn parse<'b>(&mut self, bytes: &'b [u8]) -> ParseResults<Output> where Output: 'b {\\n        panic!(\\\"FailParser already consumed\\\")\\n    }\\n}\\n\\npub fn fail() -> Fail {\\n    Fail\\n}\", \"src/_03_combinators/nullable/forbid_follows.rs\": \"\\n// src/_03_combinators/nullable/forbid_follows.rs\\nuse crate::BaseCombinatorTrait;\\nuse crate::*;\\n\\n#[repr(transparent)]\\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Ord, PartialOrd, Default)]\\npub struct ForbidFollowsData {\\n    pub prev_match_ids: u16, // Using a bitset\\n}\\n\\n#[derive(Debug)]\\npub struct ForbidFollows {\\n    pub(crate) match_ids: u16, // Using a bitset\\n}\\n\\n#[derive(Debug)]\\npub struct ForbidFollowsClear {}\\n\\n#[derive(Debug)]\\npub struct ForbidFollowsCheckNot {\\n    pub(crate) match_ids: u16,\\n}\\n\\nimpl DynCombinatorTrait for ForbidFollows {\\n    fn parse_dyn<'a, 'b>(&'a self, right_data: RightData, bytes: &'b [u8]) -> (Box<dyn ParserTrait<Self::Output> + 'a>, ParseResults<Self::Output>) where Self::Output: 'b {\\n        let (parser, parse_results) = self.parse(right_data, bytes);\\n        (Box::new(parser), parse_results)\\n    }\\n\\n    fn one_shot_parse_dyn<'a, 'b>(&'a self, right_data: RightData, bytes: &'b [u8]) -> UnambiguousParseResults<Self::Output> where Self::Output: 'b {\\n        self.one_shot_parse(right_data, bytes)\\n    }\\n}\\n\\nimpl CombinatorTrait for ForbidFollows {\\n    type Parser<'a> = FailParser;\\n    type Output = ();\\n\\n    fn one_shot_parse<'b>(&self, right_data: RightData, bytes: &'b [u8]) -> UnambiguousParseResults<Self::Output> where Self::Output: 'b {\\n        let mut right_data = right_data;\\n        right_data.get_inner_mut().get_fields1_mut().forbidden_consecutive_matches.prev_match_ids = self.match_ids;\\n        Ok(OneShotUpData::new(right_data, ())) // Add output\\n    }\\n    fn old_parse<'a, 'b>(&self, right_data: RightData, bytes: &'b [u8]) -> (Self::Parser<'a>, ParseResults<Self::Output>) where Self::Output: 'b {\\n        let mut right_data = right_data;\\n        right_data.get_inner_mut().get_fields1_mut().forbidden_consecutive_matches.prev_match_ids = self.match_ids;\\n        (FailParser, ParseResults::new_single(UpData::new(right_data, ()), true)) // Add output\\n    }\\n}\\n\\nimpl BaseCombinatorTrait for ForbidFollows {\\n    fn as_any(&self) -> &dyn std::any::Any where Self: 'static {\\n        self\\n    }\\n}\\n\\nimpl DynCombinatorTrait for ForbidFollowsClear {\\n    fn parse_dyn<'a, 'b>(&'a self, right_data: RightData, bytes: &'b [u8]) -> (Box<dyn ParserTrait<Self::Output> + 'a>, ParseResults<Self::Output>) where Self::Output: 'b {\\n        let (parser, parse_results) = self.parse(right_data, bytes);\\n        (Box::new(parser), parse_results)\\n    }\\n\\n    fn one_shot_parse_dyn<'a, 'b>(&'a self, right_data: RightData, bytes: &'b [u8]) -> UnambiguousParseResults<Self::Output> where Self::Output: 'b {\\n        self.one_shot_parse(right_data, bytes)\\n    }\\n}\\n\\nimpl CombinatorTrait for ForbidFollowsClear {\\n    type Parser<'a> = FailParser;\\n    type Output = ();\\n\\n    fn one_shot_parse<'b>(&self, right_data: RightData, bytes: &'b [u8]) -> UnambiguousParseResults<Self::Output> where Self::Output: 'b {\\n        Ok(OneShotUpData::new(right_data, ())) // Add output\\n    }\\n    fn old_parse<'a, 'b>(&self, right_data: RightData, bytes: &'b [u8]) -> (Self::Parser<'a>, ParseResults<Self::Output>) where Self::Output: 'b {\\n        let mut right_data = right_data;\\n        right_data.get_inner_mut().get_fields1_mut().forbidden_consecutive_matches.prev_match_ids = 0;\\n        (FailParser, ParseResults::new_single(UpData::new(right_data, ()), true)) // Add output\\n    }\\n}\\n\\nimpl BaseCombinatorTrait for ForbidFollowsClear {\\n    fn as_any(&self) -> &dyn std::any::Any where Self: 'static {\\n        self\\n    }\\n}\\n\\nimpl DynCombinatorTrait for ForbidFollowsCheckNot {\\n    fn parse_dyn<'a, 'b>(&'a self, right_data: RightData, bytes: &'b [u8]) -> (Box<dyn ParserTrait<Self::Output> + 'a>, ParseResults<Self::Output>) where Self::Output: 'b {\\n        let (parser, parse_results) = self.parse(right_data, bytes);\\n        (Box::new(parser), parse_results)\\n    }\\n\\n    fn one_shot_parse_dyn<'a, 'b>(&'a self, right_data: RightData, bytes: &'b [u8]) -> UnambiguousParseResults<Self::Output> where Self::Output: 'b {\\n        self.one_shot_parse(right_data, bytes)\\n    }\\n}\\n\\nimpl CombinatorTrait for ForbidFollowsCheckNot {\\n    type Parser<'a> = FailParser;\\n    type Output = ();\\n\\n    fn one_shot_parse<'b>(&self, right_data: RightData, bytes: &'b [u8]) -> UnambiguousParseResults<Self::Output> where Self::Output: 'b {\\n        Ok(OneShotUpData::new(right_data, ())) // Add output\\n    }\\n    fn old_parse<'a, 'b>(&self, right_data: RightData, bytes: &'b [u8]) -> (Self::Parser<'a>, ParseResults<Self::Output>) where Self::Output: 'b {\\n        let mut right_data = right_data;\\n        if right_data.get_fields1().forbidden_consecutive_matches.prev_match_ids & self.match_ids != 0 {\\n            (FailParser, ParseResults::empty_finished())\\n        } else {\\n            right_data.get_inner_mut().get_fields1_mut().forbidden_consecutive_matches.prev_match_ids = 0;\\n            (FailParser, ParseResults::new_single(UpData::new(right_data, ()), true)) // Add output\\n        }\\n    }\\n}\\n\\nimpl BaseCombinatorTrait for ForbidFollowsCheckNot {\\n    fn as_any(&self) -> &dyn std::any::Any where Self: 'static {\\n        self\\n    }\\n}\\n\\npub fn forbid_follows(match_ids: &[usize]) -> ForbidFollows { // Using a bitset\\n    let mut bitset = 0;\\n    for &id in match_ids {\\n        bitset |= 1 << TryInto::<u16>::try_into(id).unwrap();\\n    }\\n    ForbidFollows { match_ids: bitset }\\n}\\n\\npub fn forbid_follows_clear() -> ForbidFollowsClear {\\n    ForbidFollowsClear {}\\n}\\n\\npub fn forbid_follows_check_not(match_id: usize) -> ForbidFollowsCheckNot {\\n    let bitmask = 1 << match_id;\\n    ForbidFollowsCheckNot { match_ids: bitmask }\\n}\", \"src/_03_combinators/nullable/mod.rs\": \"\\n// src/_03_combinators/nullable/mod.rs\\nmod check_right_data;\\nmod eps_and_fail;\\nmod forbid_follows;\\n\\npub use check_right_data::*;\\npub use eps_and_fail::*;\\npub use forbid_follows::*;\", \"src/_03_combinators/unicode.rs\": \"\\n// src/_03_combinators/unicode.rs\\nuse crate::unicode_categories::{char_ranges_in_general_category, GeneralCategory};\\nuse crate::*;\\n\\npub fn get_unicode_general_category_bytestrings(general_category: GeneralCategory) -> Vec<Vec<u8>> {\\n    let mut result = Vec::new();\\n\\n    for (start, end) in char_ranges_in_general_category(general_category).iter().cloned() {\\n        for c in start..=end {\\n            let byte_len = c.len_utf8();\\n            let mut bytes = vec![0; byte_len];\\n            c.encode_utf8(&mut bytes);\\n            result.push(bytes.to_vec());\\n        }\\n    }\\n\\n    result\\n}\\n\\npub fn get_unicode_general_category_combinator(general_category: GeneralCategory)-> impl CombinatorTrait {\\n    let bytestrings = get_unicode_general_category_bytestrings(general_category);\\n    eat_bytestring_choice(bytestrings)\\n}\"} "
    },
    {
      "role": "user",
      "content": "/generate src/_03_combinators/wrappers/deferred.rs src/_03_combinators/wrappers/dyn_parser.rs src/_03_combinators/wrappers/mod.rs src/_03_combinators/wrappers/profile.rs"
    },
    {
      "role": "model",
      "content": "{\"src/_03_combinators/wrappers/deferred.rs\": \"\\n// src/_03_combinators/wrappers/deferred.rs\\nuse crate::BaseCombinatorTrait;\\nuse crate::*;\\nuse once_cell::unsync::OnceCell;\\n// src/combinators/deferred.rs\\n// src/combinators/deferred.rs\\nuse std::any::{Any, TypeId};\\nuse std::cell::RefCell;\\nuse std::collections::HashMap;\\nuse std::collections::HashSet;\\nuse std::fmt::{Debug, Formatter};\\nuse std::hash::{Hash, Hasher};\\nuse std::panic::Location;\\n\\nthread_local! {\\n    static DEFERRED_CACHE: RefCell<HashMap<CacheKey, CacheEntry>> = RefCell::new(HashMap::new());\\n}\\n\\n#[derive(Debug)]\\npub struct Deferred<'a, T: CombinatorTrait> {\\n    deferred_fn: Box<dyn DeferredFnTrait<T> + 'a>,\\n    inner: OnceCell<T>,\\n}\\n\\nstruct DeferredFn<T: CombinatorTrait, F: Fn() -> T> {\\n    pub f: F,\\n    pub key: CacheKey,\\n}\\n\\nimpl<T: CombinatorTrait + Clone, F: Fn() -> T> Debug for DeferredFn<T, F> {\\n    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {\\n        f.debug_tuple(\\\"DeferredFn\\\").field(&self.key).finish()\\n    }\\n}\\n\\n// todo: this trait is really messy. Any way to clean it up?\\n// Trait for evaluating the deferred function\\ntrait DeferredFnTrait<T: CombinatorTrait>: Debug {\\n    // todo: the fact that\\n    // we need this struct right now is dumb. Aim to remove it. But we don't want to have to return a (bool, T) tuple - that's even worse and it's what we're trying to avoid by using the struct.\\n    fn evaluate_to_combinator(&self) -> EvaluateToCombinatorResult<T>;\\n    fn get_addr(&self) -> usize;\\n}\\n\\nstruct EvaluateToCombinatorResult<T> {\\n    combinator: T,\\n    cache_hit: bool,\\n}\\n\\n#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\\nstruct CacheKey {\\n    addr: usize,\\n    // TODO: it really seems wrong to use TypeId here. It works fine with just addr when we use opt level 0.\\n    //  But at opt level 2, we get a collision between two keys with the same address but different typeids.\\n    //  Obviously something weird is going on with function pointers that I don't quite understand.\\n    type_id: TypeId,\\n}\\n\\n// CacheEntry struct to hold the CombinatorTrait and caller locations\\n#[derive(Debug)]\\nstruct CacheEntry {\\n    value: Box<dyn DynCombinatorTrait>,\\n    caller_locations: RefCell<HashSet<String>>,\\n}\\n\\nimpl<T: CombinatorTrait + Clone + 'static, F: Fn() -> T> DeferredFnTrait<T> for DeferredFn<T, F> {\\n    fn evaluate_to_combinator(&self) -> EvaluateToCombinatorResult<T> {\\n        DEFERRED_CACHE.with(|cache| {\\n            if cache.borrow().contains_key(&self.key) {\\n                count_hit!(\\\"deferred cache hit\\\");\\n                let borrowed = cache.borrow();\\n                let entry = borrowed.get(&self.key).unwrap();\\n                if let Some(value) = entry.value.as_any().downcast_ref::<T>() {\\n                    return EvaluateToCombinatorResult {\\n                        combinator: value.clone(),\\n                        cache_hit: true,\\n                    };\\n                } else {\\n                    // Richer error printing\\n                    eprintln!(\\\"Deferred Cache: {:#?}\\\", borrowed);\\n                    eprintln!(\\\"Key: {:?}\\\", self.key);\\n                    eprintln!(\\\"Conflicting Entry: {:?}\\\", entry);\\n                    eprintln!(\\\"Existing Type Name: {:?}\\\", BaseCombinatorTrait::type_name(&entry.value));\\n                    eprintln!(\\\"Expected Type Name: {}\\\", std::any::type_name::<T>());\\n                    panic!(\\\"Expected value at address {} to be of typeid {:?}, but it had typeid {:?}\\\", self.key.addr, TypeId::of::<T>(), entry.value.as_any().type_id());\\n                }\\n            } else {\\n                count_hit!(\\\"deferred cache miss\\\");\\n                let value = (self.f)();\\n                cache.borrow_mut().insert(self.key, CacheEntry {\\n                    value: Box::new(value.clone()),\\n                    caller_locations: RefCell::new(HashSet::new()),\\n                });\\n                return EvaluateToCombinatorResult {\\n                    combinator: value,\\n                    cache_hit: false,\\n                };\\n            }\\n        })\\n    }\\n    fn get_addr(&self) -> usize {\\n        self.key.addr\\n    }\\n}\\n\\nimpl<T: CombinatorTrait> PartialEq for Deferred<'_, T> {\\n    fn eq(&self, other: &Self) -> bool {\\n        std::ptr::eq(&self.deferred_fn, &other.deferred_fn)\\n    }\\n}\\n\\nimpl<T: CombinatorTrait> Eq for Deferred<'_, T> {}\\n\\nimpl<T: CombinatorTrait> Hash for Deferred<'_, T> {\\n    fn hash<H: Hasher>(&self, state: &mut H) {\\n        std::ptr::hash(&self.deferred_fn, state);\\n    }\\n}\\n\\nimpl<T: CombinatorTrait> DynCombinatorTrait for Deferred<'_, T> {\\n    fn parse_dyn<'a, 'b>(&'a self, right_data: RightData, bytes: &'b [u8]) -> (Box<dyn ParserTrait<Self::Output> + 'a>, ParseResults<Self::Output>) where Self::Output: 'b {\\n        let (parser, parse_results) = self.parse(right_data, bytes);\\n        (Box::new(parser), parse_results)\\n    }\\n\\n    fn one_shot_parse_dyn<'a, 'b>(&'a self, right_data: RightData, bytes: &'b [u8]) -> UnambiguousParseResults<Self::Output> where Self::Output: 'b {\\n        self.one_shot_parse(right_data, bytes)\\n    }\\n}\\n\\nimpl<T: CombinatorTrait> CombinatorTrait for Deferred<'_, T> {\\n    type Parser<'a> = T::Parser<'a> where Self: 'a;\\n    type Output = T::Output;\\n\\n    fn one_shot_parse<'b>(&self, right_data: RightData, bytes: &'b [u8]) -> UnambiguousParseResults<Self::Output> where Self::Output: 'b {\\n        let combinator = self.inner.get().expect(\\\"inner combinator not initialized\\\");\\n        combinator.one_shot_parse(right_data, bytes)\\n    }\\n\\n    fn old_parse<'a, 'b>(&self, right_data: RightData, bytes: &'b [u8]) -> (Self::Parser<'a>, ParseResults<Self::Output>) where Self::Output: 'b {\\n        // let combinator = self.inner.get_or_init(|| self.deferred_fn.evaluate_to_combinator());\\n        let combinator = self.inner.get().expect(\\\"inner combinator not initialized\\\");\\n        combinator.parse(right_data, bytes)\\n    }\\n}\\n\\nimpl<T: CombinatorTrait> BaseCombinatorTrait for Deferred<'_, T> {\\n    fn as_any(&self) -> &dyn Any where Self: 'static {\\n        self\\n    }\\n    fn apply_to_children(&self, f: &mut dyn FnMut(&dyn BaseCombinatorTrait)) {\\n        f(self.inner.get_or_init(|| self.deferred_fn.evaluate_to_combinator().combinator))\\n    }\\n    fn compile_inner(&self) {\\n        // Force evaluation and compilation of the inner combinator\\n        let _ = self.inner.get_or_init(|| {\\n            let result = self.deferred_fn.evaluate_to_combinator();\\n            if !result.cache_hit {\\n                result.combinator.compile_inner();\\n            }\\n            result.combinator\\n        });\\n    }\\n}\\n\\n// Public function for creating a Deferred combinator\\n#[track_caller]\\npub fn deferred<T: CombinatorTrait + 'static>(f: fn() -> T) -> Deferred<'static, StrongRef<T>> {\\n    let addr = f as *const () as usize;\\n    let location = Location::caller();\\n    let caller_location_str = location.to_string();\\n    let key = CacheKey {\\n        addr,\\n        type_id: TypeId::of::<T>(),\\n    };\\n    DEFERRED_CACHE.with(|cache| {\\n        let mut cache = cache.borrow_mut();\\n        if let Some(entry) = cache.get_mut(&key) {\\n            entry.caller_locations.borrow_mut().insert(caller_location_str);\\n        }\\n    });\\n    let f = move || StrongRef::new(f());\\n    Deferred {\\n        deferred_fn: Box::new(DeferredFn {\\n            f,\\n            key\\n        }),\\n        inner: OnceCell::new(),\\n    }\\n}\", \"src/_03_combinators/wrappers/dyn_parser.rs\": \"\\n// src/_03_combinators/wrappers/dyn_parser.rs\\nuse crate::*;\\nuse std::any::Any;\\n\\n#[derive(Debug)]\\npub struct DynCombinator<C: CombinatorTrait> {\\n    combinator: C,\\n}\\n\\nimpl<C: CombinatorTrait> BaseCombinatorTrait for DynCombinator<C> {\\n    fn as_any(&self) -> &dyn Any where Self: 'static {\\n        self\\n    }\\n}\\n\\nimpl<C: CombinatorTrait> DynCombinatorTrait for DynCombinator<C> {\\n    fn parse_dyn<'a, 'b>(&'a self, right_data: RightData, bytes: &'b [u8]) -> (Box<dyn ParserTrait<Self::Output> + 'a>, ParseResults<Self::Output>) where Self::Output: 'b {\\n        let (parser, parse_results) = self.parse(right_data, bytes);\\n        (Box::new(parser), parse_results)\\n    }\\n\\n    fn one_shot_parse_dyn<'a, 'b>(&'a self, right_data: RightData, bytes: &'b [u8]) -> UnambiguousParseResults<Self::Output> where Self::Output: 'b {\\n        self.one_shot_parse(right_data, bytes)\\n    }\\n}\\n\\nimpl<C: CombinatorTrait> CombinatorTrait for DynCombinator<C> {\\n    type Parser<'a> = Box<dyn ParserTrait<Self::Output> + 'a> where Self: 'a;\\n    type Output = C::Output;\\n\\n    fn one_shot_parse<'b>(&self, right_data: RightData, bytes: &'b [u8]) -> UnambiguousParseResults<Self::Output> where Self::Output: 'b {\\n        self.combinator.one_shot_parse(right_data, bytes)\\n    }\\n\\n    fn old_parse<'a, 'b>(&self, right_data: RightData, bytes: &'b [u8]) -> (Self::Parser<'a>, ParseResults<Self::Output>) where Self::Output: 'b {\\n        let (parser, parse_results) = self.combinator.old_parse(right_data, bytes);\\n        (Box::new(parser), parse_results)\\n    }\\n}\\n\\npub fn dyn_combinator<'a, C: CombinatorTrait + 'a>(combinator: C) -> Box<dyn DynCombinatorTrait + 'a> {\\n    Box::new(DynCombinator { combinator })\\n}\", \"src/_03_combinators/wrappers/mod.rs\": \"\\n// src/_03_combinators/wrappers/mod.rs\\nmod deferred;\\nmod dyn_parser;\\nmod profile;\\nmod reference;\\nmod symbol;\\nmod tag;\\n\\npub use deferred::*;\\npub use dyn_parser::*;\\npub use profile::*;\\npub use reference::*;\\npub use symbol::*;\\npub use tag::*;\", \"src/_03_combinators/wrappers/profile.rs\": \"use crate::BaseCombinatorTrait;\\nuse crate::*;\\nuse derivative::Derivative;\\nuse std::collections::HashMap;\\nuse std::sync::Mutex;\\nuse std::time::{Duration, Instant};\\n\\nlazy_static::lazy_static! {\\n    pub static ref GLOBAL_PROFILE_DATA: Mutex<ProfileDataInner> = Mutex::new(ProfileDataInner::default());\\n}\\n\\npub struct ProfileDataInner {\\n    pub(crate) timings: HashMap<String, Duration>,\\n    pub(crate) hit_counts: HashMap<String, usize>,\\n    tag_stack: Vec<String>,\\n    start_time: Instant,\\n}\\n\\nimpl Default for ProfileDataInner {\\n    fn default() -> Self {\\n        Self {\\n            timings: HashMap::new(),\\n            hit_counts: HashMap::new(),\\n            tag_stack: vec![\\\"root\\\".to_string()],\\n            start_time: Instant::now(),\\n        }\\n    }\\n}\\n\\nimpl ProfileDataInner {\\n    pub fn push_tag(tag: String) {\\n        let now = Instant::now();\\n        let mut profile_data = GLOBAL_PROFILE_DATA.lock().unwrap();\\n        let elapsed = now.duration_since(profile_data.start_time);\\n        if let Some(current_tag) = profile_data.tag_stack.last().cloned() {\\n            *profile_data.timings.entry(current_tag.clone()).or_default() += elapsed;\\n            *profile_data.hit_counts.entry(current_tag).or_default() += 1;\\n        }\\n        profile_data.tag_stack.push(tag);\\n        profile_data.start_time = Instant::now();\\n    }\\n\\n    pub fn pop_tag() {\\n        let now = Instant::now();\\n        let mut profile_data = GLOBAL_PROFILE_DATA.lock().unwrap();\\n        if let Some(tag) = profile_data.tag_stack.pop() {\\n            let elapsed = now.duration_since(profile_data.start_time);\\n            *profile_data.timings.entry(tag.clone()).or_default() += elapsed;\\n            *profile_data.hit_counts.entry(tag).or_default() += 1;\\n        }\\n        profile_data.start_time = Instant::now();\\n    }\\n\\n    pub fn count_hit(tag: String) {\\n        let mut profile_data = GLOBAL_PROFILE_DATA.lock().unwrap();\\n        *profile_data.hit_counts.entry(tag).or_default() += 1;\\n    }\\n}\\n\\npub fn clear_profile_data() {\\n    let mut profile_data = GLOBAL_PROFILE_DATA.lock().unwrap();\\n    profile_data.timings.clear();\\n    profile_data.hit_counts.clear();\\n    profile_data.tag_stack.clear();\\n    profile_data.start_time = Instant::now();\\n}\\n\\n#[macro_export]\\nmacro_rules! profile {\\n    ($tag:expr, $body:expr) => {{\\n        // $crate::ProfileDataInner::push_tag($tag.to_string());\\n        // let result = $body;\\n        // $crate::ProfileDataInner::pop_tag();\\n        // result\\n        $body\\n    }};\\n}\\n\\n#[macro_export]\\nmacro_rules! profile_block {\\n    ($body:expr) => {{\\n        // $crate::ProfileDataInner::push_tag(format!(\\\"{}:{}\\\", file!(), line!()));\\n        // let result = $body;\\n        // $crate::ProfileDataInner::pop_tag();\\n        // result\\n        $body\\n    }};\\n}\\n\\n#[macro_export]\\nmacro_rules! count_hit {\\n    ($tag:expr) => {\\n        // $crate::ProfileDataInner::count_hit($tag.to_string());\\n    };\\n}\\n\\n#[derive(Debug)]\\npub struct Profiled<T> {\\n    pub inner: T,\\n    pub tag: String,\\n}\\n\\n#[derive(Derivative)]\\n#[derivative(Debug)]\\npub struct ProfiledParser<P: ParserTrait> {\\n    pub inner: P,\\n    pub tag: String,\\n}\\n\\nimpl<T: CombinatorTrait> DynCombinatorTrait for Profiled<T> {\\n    fn parse_dyn<'a, 'b>(&'a self, right_data: RightData, bytes: &'b [u8]) -> (Box<dyn ParserTrait<Self::Output> + 'a>, ParseResults<Self::Output>) where Self::Output: 'b {\\n        let (parser, parse_results) = self.parse(right_data, bytes);\\n        (Box::new(parser), parse_results)\\n    }\\n\\n    fn one_shot_parse_dyn<'a, 'b>(&'a self, right_data: RightData, bytes: &'b [u8]) -> UnambiguousParseResults<Self::Output> where Self::Output: 'b {\\n        self.one_shot_parse(right_data, bytes)\\n    }\\n}\\n\\nimpl<T: CombinatorTrait> CombinatorTrait for Profiled<T> {\\n    type Parser<'a> = ProfiledParser<T::Parser<'a>> where Self: 'a;\\n    type Output = T::Output;\\n\\n    fn one_shot_parse<'b>(&self, right_data: RightData, bytes: &'b [u8]) -> UnambiguousParseResults<Self::Output> where Self::Output: 'b {\\n        profile!(&self.tag, self.inner.one_shot_parse(right_data, bytes))\\n    }\\n\\n    fn old_parse<'a, 'b>(&self, right_data: RightData, bytes: &'b [u8]) -> (Self::Parser<'a>, ParseResults<Self::Output>) where Self::Output: 'b {\\n        profile!(&self.tag, {\\n            let (parser, parse_results) = self.inner.parse(right_data, bytes);\\n            let parser = ProfiledParser { inner: parser, tag: self.tag.clone() };\\n            (parser, parse_results)\\n        })\\n    }\\n}\\n\\nimpl<T: CombinatorTrait> BaseCombinatorTrait for Profiled<T> {\\n    fn as_any(&self) -> &dyn std::any::Any where Self: 'static {\\n        self\\n    }\\n    fn apply_to_children(&self, f: &mut dyn FnMut(&dyn BaseCombinatorTrait)) {\\n        f(&self.inner);\\n    }\\n}\\n\\nimpl<P: ParserTrait> ParserTrait for ProfiledParser<P> {\\n    fn get_u8set(&self) -> U8Set {\\n        self.inner.get_u8set()\\n    }\\n\\n    fn parse<'b>(&mut self, bytes: &'b [u8]) -> ParseResults<P::Output> where P::Output: 'b {\\n        profile!(&self.tag, self.inner.parse(bytes))\\n    }\\n}\\n\\npub fn profile<T: IntoCombinator>(tag: &str, a: T)-> impl CombinatorTrait {\\n    // Profiled { inner: a.into_combinator(), tag: tag.to_string() }\\n    a.into_combinator()\\n}\\n\\npub fn profile_internal<'a, T: IntoCombinator>(tag: &str, a: T)-> impl CombinatorTrait {\\n    profile(tag, a)\\n}\"} "
    },
    {
      "role": "user",
      "content": "/generate src/_03_combinators/wrappers/reference.rs src/_03_combinators/wrappers/symbol.rs src/_03_combinators/wrappers/tag.rs"
    },
    {
      "role": "model",
      "content": "{\"src/_03_combinators/wrappers/reference.rs\": \"\\n// src/_03_combinators/wrappers/reference.rs\\nuse crate::BaseCombinatorTrait;\\nuse crate::*;\\nuse once_cell::unsync::OnceCell;\\nuse std::fmt::{Debug, Formatter};\\n// src/combinators/reference.rs\\nuse std::hash::{Hash, Hasher};\\nuse std::rc::{Rc, Weak};\\n\\npub struct WeakRef<T> {\\n    pub inner: Weak<OnceCell<T>>,\\n}\\n\\npub struct StrongRef<T> {\\n    pub inner: Rc<OnceCell<T>>,\\n}\\n\\nimpl<T> Debug for WeakRef<T> {\\n    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {\\n        f.debug_struct(\\\"WeakRef\\\").finish_non_exhaustive()\\n    }\\n}\\n\\nimpl<T: Debug> Debug for StrongRef<T> {\\n    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {\\n        f.debug_struct(\\\"StrongRef\\\").finish_non_exhaustive()\\n    }\\n}\\n\\nimpl<T> Clone for StrongRef<T> {\\n    fn clone(&self) -> Self {\\n        StrongRef {\\n            inner: self.inner.clone()\\n        }\\n    }\\n}\\n\\nimpl<T> Clone for WeakRef<T> {\\n    fn clone(&self) -> Self {\\n        WeakRef {\\n            inner: self.inner.clone()\\n        }\\n    }\\n}\\n\\nimpl<T> PartialEq for WeakRef<T> {\\n    fn eq(&self, other: &Self) -> bool {\\n        self.inner.ptr_eq(&other.inner)\\n    }\\n}\\n\\nimpl<T> Eq for WeakRef<T> {}\\n\\nimpl<T> Hash for WeakRef<T> {\\n    fn hash<H: Hasher>(&self, state: &mut H) {\\n        std::ptr::hash(&self.inner, state);\\n    }\\n}\\n\\nimpl<T> PartialEq for StrongRef<T> {\\n    fn eq(&self, other: &Self) -> bool {\\n        Rc::ptr_eq(&self.inner, &other.inner)\\n    }\\n}\\n\\nimpl<T> Eq for StrongRef<T> {}\\n\\nimpl<T> Hash for StrongRef<T> {\\n    fn hash<H: Hasher>(&self, state: &mut H) {\\n        std::ptr::hash(&self.inner, state);\\n    }\\n}\\n\\nimpl<T: CombinatorTrait> DynCombinatorTrait for WeakRef<T> {\\n    fn parse_dyn<'a, 'b>(&'a self, right_data: RightData, bytes: &'b [u8]) -> (Box<dyn ParserTrait<Self::Output> + 'a>, ParseResults<Self::Output>) where Self::Output: 'b {\\n        let (parser, parse_results) = self.parse(right_data, bytes);\\n        (Box::new(parser), parse_results)\\n    }\\n\\n    fn one_shot_parse_dyn<'a, 'b>(&'a self, right_data: RightData, bytes: &'b [u8]) -> UnambiguousParseResults<Self::Output> where Self::Output: 'b {\\n        self.one_shot_parse(right_data, bytes)\\n    }\\n}\\n\\nimpl<T: CombinatorTrait> CombinatorTrait for WeakRef<T> {\\n    type Parser<'a> = T::Parser<'a> where Self: 'a;\\n    type Output = T::Output;\\n\\n    fn one_shot_parse<'b>(&self, right_data: RightData, bytes: &'b [u8]) -> UnambiguousParseResults<Self::Output> where Self::Output: 'b {\\n        let combinator = self.get().unwrap();\\n        combinator.one_shot_parse(right_data, bytes)\\n    }\\n\\n    fn old_parse<'a, 'b>(&self, right_data: RightData, bytes: &'b [u8]) -> (Self::Parser<'a>, ParseResults<Self::Output>) where Self::Output: 'b {\\n        let combinator = self.get().unwrap();\\n        combinator.parse(right_data, bytes)\\n    }\\n}\\n\\nimpl<T: CombinatorTrait> BaseCombinatorTrait for WeakRef<T> {\\n    fn as_any(&self) -> &dyn std::any::Any where Self: 'static {\\n        self\\n    }\\n    fn apply_to_children(&self, f: &mut dyn FnMut(&dyn BaseCombinatorTrait)) {\\n        f(self.inner.upgrade().expect(\\\"WeakRef is already dropped\\\").get().expect(\\\"Combinator hasn't been set\\\"));\\n    }\\n}\\n\\nimpl<T: CombinatorTrait> DynCombinatorTrait for StrongRef<T> {\\n    fn parse_dyn<'a, 'b>(&'a self, right_data: RightData, bytes: &'b [u8]) -> (Box<dyn ParserTrait<Self::Output> + 'a>, ParseResults<Self::Output>) where Self::Output: 'b {\\n        let (parser, parse_results) = self.parse(right_data, bytes);\\n        (Box::new(parser), parse_results)\\n    }\\n\\n    fn one_shot_parse_dyn<'a, 'b>(&'a self, right_data: RightData, bytes: &'b [u8]) -> UnambiguousParseResults<Self::Output> where Self::Output: 'b {\\n        self.one_shot_parse(right_data, bytes)\\n    }\\n}\\n\\nimpl<T: CombinatorTrait> CombinatorTrait for StrongRef<T> {\\n    type Parser<'a> = T::Parser<'a> where Self: 'a;\\n    type Output = T::Output;\\n\\n    fn one_shot_parse<'b>(&self, right_data: RightData, bytes: &'b [u8]) -> UnambiguousParseResults<Self::Output> where Self::Output: 'b {\\n        let combinator = self.inner.get().unwrap();\\n        combinator.one_shot_parse(right_data, bytes)\\n    }\\n\\n    fn old_parse<'a, 'b>(&self, right_data: RightData, bytes: &'b [u8]) -> (Self::Parser<'a>, ParseResults<Self::Output>) where Self::Output: 'b {\\n        self.inner\\n            .get()\\n            .unwrap()\\n            .parse(right_data, bytes)\\n    }\\n}\\n\\nimpl<T: CombinatorTrait> BaseCombinatorTrait for StrongRef<T> {\\n    fn as_any(&self) -> &dyn std::any::Any where Self: 'static {\\n        self\\n    }\\n    fn apply_to_children(&self, f: &mut dyn FnMut(&dyn BaseCombinatorTrait)) {\\n        f(self.inner.get().unwrap());\\n    }\\n}\\n\\npub fn strong_ref<T>() -> StrongRef<T> {\\n    StrongRef {\\n        inner: Rc::new(OnceCell::new())\\n    }\\n}\\n\\nimpl<T> StrongRef<T> {\\n    pub fn set(&self, inner: T) {\\n        self.inner.set(inner).ok().expect(\\\"Cannot set value more than once\\\");\\n    }\\n\\n    pub fn downgrade(&self) -> WeakRef<T> {\\n        WeakRef {\\n            inner: Rc::downgrade(&self.inner)\\n        }\\n    }\\n\\n    pub fn new(inner: T) -> Self {\\n        let cell = OnceCell::new();\\n        cell.set(inner).ok().expect(\\\"Cannot set value more than once\\\");\\n        Self { inner: Rc::new(cell) }\\n    }\\n}\\n\\nimpl<T> WeakRef<T> {\\n    pub fn upgrade(&self) -> Option<StrongRef<T>> {\\n        self.inner.upgrade().map(|inner| StrongRef { inner })\\n    }\\n\\n    pub fn get(&self) -> Option<&T> {\\n        // Upgrade the weak reference to a strong reference\\n        let strong_ref = self.inner.upgrade()?;\\n\\n        // Safely access the inner Combinator\\n        // Note: We use unsafe code here to transmute the lifetime.\\n        // This is safe because the OnceCell guarantees that the value,\\n        // once set, will live as long as the Rc/Weak, which is 'static.\\n        unsafe {\\n            let combinator: &T = std::mem::transmute(strong_ref.get().unwrap());\\n            Some(combinator)\\n        }\\n    }\\n}\", \"src/_03_combinators/wrappers/symbol.rs\": \"\\n// src/_03_combinators/wrappers/symbol.rs\\nuse crate::{RightData, RightDataGetters};\\nuse crate::{BaseCombinatorTrait, DynCombinatorTrait, UnambiguousParseResults};\\nuse std::rc::Rc;\\n\\nuse crate::{CombinatorTrait, IntoCombinator, ParseResultTrait, ParseResults, ParserTrait};\\n#[derive(Debug)]\\npub struct Symbol<T> {\\n    pub value: Rc<T>,\\n}\\n\\nimpl<T> Clone for Symbol<T> {\\n    fn clone(&self) -> Self {\\n        Symbol { value: self.value.clone() }\\n    }\\n}\\n\\nimpl<T: CombinatorTrait> DynCombinatorTrait for Symbol<T> {\\n    fn parse_dyn<'a, 'b>(&'a self, right_data: RightData, bytes: &'b [u8]) -> (Box<dyn ParserTrait<Self::Output> + 'a>, ParseResults<Self::Output>) where Self::Output: 'b {\\n        let (parser, parse_results) = self.parse(right_data, bytes);\\n        (Box::new(parser), parse_results)\\n    }\\n\\n    fn one_shot_parse_dyn<'a, 'b>(&'a self, right_data: RightData, bytes: &'b [u8]) -> UnambiguousParseResults<Self::Output> where Self::Output: 'b {\\n        self.one_shot_parse(right_data, bytes)\\n    }\\n}\\n\\nimpl<T: CombinatorTrait> CombinatorTrait for Symbol<T> {\\n    type Parser<'a> = T::Parser<'a> where Self: 'a;\\n    type Output = T::Output;\\n\\n    fn one_shot_parse<'b>(&self, right_data: RightData, bytes: &'b [u8]) -> UnambiguousParseResults<Self::Output> where Self::Output: 'b {\\n        self.value.one_shot_parse(right_data, bytes)\\n    }\\n\\n    fn old_parse<'a, 'b>(&self, right_data: RightData, bytes: &'b [u8]) -> (Self::Parser<'a>, ParseResults<Self::Output>) where Self::Output: 'b {\\n        let (parser, parse_results) = self.value.parse(right_data, bytes);\\n        (parser, parse_results)\\n    }\\n}\\n\\nimpl<T: CombinatorTrait> BaseCombinatorTrait for Symbol<T> {\\n    fn as_any(&self) -> &dyn std::any::Any where Self: 'static {\\n        self\\n    }\\n    fn apply_to_children(&self, f: &mut dyn FnMut(&dyn BaseCombinatorTrait)) {\\n        f(self.value.as_ref());\\n    }\\n}\\n\\npub fn symbol<T: IntoCombinator>(value: T) -> Symbol<T::Output> {\\n    Symbol { value: Rc::new(value.into_combinator()) }\\n}\", \"src/_03_combinators/wrappers/tag.rs\": \"\\n// src/_03_combinators/wrappers/tag.rs\\nuse std::fmt::{Debug, Formatter};\\nuse std::panic::{catch_unwind, resume_unwind, AssertUnwindSafe};\\n\\nuse crate::BaseCombinatorTrait;\\nuse crate::*;\\n\\npub struct Tagged<T: CombinatorTrait> {\\n    pub inner: T,\\n    pub tag: String,\\n}\\n\\npub struct TaggedParser<P> {\\n    pub inner: P,\\n    pub tag: String,\\n}\\n\\nimpl<T: CombinatorTrait> Debug for Tagged<T> {\\n    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {\\n        f.debug_struct(\\\"Tagged\\\")\\n            .field(\\\"tag\\\", &self.tag)\\n            .finish_non_exhaustive()\\n    }\\n}\\n\\nimpl<P> Debug for TaggedParser<P> {\\n    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {\\n        f.debug_struct(\\\"TaggedParser\\\")\\n            .field(\\\"tag\\\", &self.tag)\\n            .finish_non_exhaustive()\\n    }\\n}\\n\\nimpl<T: CombinatorTrait> DynCombinatorTrait for Tagged<T> {\\n    fn parse_dyn<'a, 'b>(&'a self, right_data: RightData, bytes: &'b [u8]) -> (Box<dyn ParserTrait<Self::Output> + 'a>, ParseResults<Self::Output>) where Self::Output: 'b {\\n        let (parser, parse_results) = self.parse(right_data, bytes);\\n        (Box::new(parser), parse_results)\\n    }\\n\\n    fn one_shot_parse_dyn<'a, 'b>(&'a self, right_data: RightData, bytes: &'b [u8]) -> UnambiguousParseResults<Self::Output> where Self::Output: 'b {\\n        self.one_shot_parse(right_data, bytes)\\n    }\\n}\\n\\nimpl<'b, T: CombinatorTrait> CombinatorTrait for Tagged<T> where T: 'b {\\n    type Parser<'a> = TaggedParser<T::Parser<'a>> where Self: 'a;\\n    type Output = T::Output;\\n\\n    fn one_shot_parse<'b>(&self, right_data: RightData, bytes: &'b [u8]) -> UnambiguousParseResults<Self::Output> where Self::Output: 'b {\\n        self.inner.one_shot_parse(right_data, bytes)\\n    }\\n\\n    fn old_parse<'a, 'b>(&self, right_data: RightData, bytes: &'b [u8]) -> (Self::Parser<'a>, ParseResults<Self::Output>) where Self::Output: 'b {\\n        count_hit!(self.tag);\\n        let result = catch_unwind(AssertUnwindSafe(|| self.inner.parse(right_data, bytes)));\\n        match result {\\n            Ok((parser, parse_results)) => (\\n                TaggedParser { inner: parser, tag: self.tag.clone() },\\n                parse_results,\\n            ),\\n            Err(err) => {\\n                eprintln!(\\\"Panic caught in parser with tag: {}\\\", self.tag);\\n                resume_unwind(err);\\n            }\\n        }\\n    }\\n}\\n\\nimpl<T: CombinatorTrait> BaseCombinatorTrait for Tagged<T> {\\n    fn as_any(&self) -> &dyn std::any::Any where Self: 'static {\\n        self\\n    }\\n    fn apply_to_children(&self, f: &mut dyn FnMut(&dyn BaseCombinatorTrait)) {\\n        f(&self.inner);\\n    }\\n}\\n\\nimpl<P: ParserTrait> ParserTrait for TaggedParser<P> {\\n    fn get_u8set(&self) -> U8Set {\\n        self.inner.get_u8set()\\n    }\\n\\n    fn parse<'b>(&mut self, bytes: &'b [u8]) -> ParseResults<P::Output> where P::Output: 'b {\\n        self.inner.parse(bytes)\\n    }\\n}\\n\\npub fn tag<T: IntoCombinator + 'static>(tag: &'static str, a: T)-> impl CombinatorTrait where T::Output: 'static {\\n    // TODO: ffs\\n    Tagged { inner: profile(tag, a), tag: tag.to_string() }\\n    // Tagged { inner: a.into_combinator(), tag: tag.to_string() }\\n    // a.into_combinator()\\n}\"} "
    },
    {
      "role": "user",
      "content": "/generate src/_06_tests/utils.rs"
    },
    {
      "role": "model",
      "content": "{\"src/_06_tests/utils.rs\": \"use crate::{clear_profile_data, RightData, RightDataGetters, UnambiguousParseResults, UpData};\\nuse std::panic::{catch_unwind, AssertUnwindSafe};\\n\\nuse kdam::tqdm;\\n\\nuse crate::{profile, CombinatorTrait, CombinatorTraitExt, ParseResultTrait, ParseResults, ParserTrait, ParserTraitExt, Squash, GLOBAL_PROFILE_DATA};\\n\\nuse std::collections::HashMap;\\nuse std::fs::File;\\nuse std::io::{BufWriter, Write};\\nuse std::time::{Duration, Instant};\\n\\nconst VERBOSE: bool = false;\\n\\npub fn assert_parses<T: CombinatorTrait, S: ToString>(combinator: &T, input: S, desc: &str) {\\n    clear_profile_data();\\n    let input = input.to_string();\\n    println!(\\\"beginning assert_parses {}\\\", desc);\\n\\n    let mut timings = Vec::new();\\n\\n    let (mut parser, mut parse_results) = profile!(\\\"parser\\\", combinator.parser(RightData::default()));\\n\\n    let lines = input.lines().collect::<Vec<_>>();\\n    let num_lines = lines.len();\\n\\n    profile!(\\\"assert_parses main loop\\\", {\\n        for (line_number, line) in tqdm!(lines.iter().enumerate(), animation = \\\"fillup\\\", position = 0) {\\n            let line_start = Instant::now();\\n\\n            let line = if line_number != num_lines - 1 {\\n                format!(\\\"{}\\\\n\\\", line)\\n            } else {\\n                line.to_string()\\n            };\\n            let bytes = line.bytes().collect::<Vec<_>>();\\n\\n            for (char_number, byte) in bytes.iter().cloned().enumerate() {\\n                parse_results.squash();\\n                assert!(parser.get_u8set().contains(byte),\\n                    \\\"byte {:?} is not in any up_data: {:?}. Line: {:?}, Char: {:?}, Text: {:?}, u8set: {:?}\\\",\\n                    byte as char, parse_results, line_number, char_number, line, parser.get_u8set());\\n\\n                if line_number == lines.len() - 1 && char_number == bytes.len() - 1 {\\n                    timings.push((line.to_string(), Instant::now() - line_start));\\n                    break;\\n                }\\n\\n                if VERBOSE {\\n                    println!(\\\"line:char: {line_number}:{char_number}\\\");\\n                    println!(\\\"line: {line:?}\\\");\\n                }\\n\\n                parse_results = catch_unwind(AssertUnwindSafe(|| parser.step(byte)))\\n                    .expect(format!(\\\"Parser.step: Error at byte: {} on line: {} at char: {}\\\", byte as char, line_number, char_number).as_str());\\n\\n                parse_results.squash();\\n\\n                assert!(!parse_results.up_data_vec.is_empty() || !parser.get_u8set().is_empty(),\\n                    \\\"Parser didn't return any data at byte: {} on line: {} at char: {}\\\", byte as char, line_number, char_number);\\n                assert!(!parse_results.done(),\\n                    \\\"Parser finished prematurely at byte: {} on line: {} at char: {}\\\", byte as char, line_number, char_number);\\n            }\\n\\n            timings.push((line, Instant::now() - line_start));\\n        }\\n    });\\n\\n    print_profile_results();\\n\\n    print_timing_results(timings);\\n}\\n\\npub fn assert_parses_tight<T: CombinatorTrait, S: ToString>(combinator: &T, input: S, desc: &str) {\\n    clear_profile_data();\\n    let input = input.to_string();\\n    println!(\\\"beginning assert_parses_tight {}\\\", desc);\\n\\n    let (mut parser, mut parse_results) = combinator.parser(RightData::default());\\n\\n    let lines = input.lines().collect::<Vec<_>>();\\n    let num_lines = lines.len();\\n\\n    let start = Instant::now();\\n\\n    profile!(\\\"assert_parses_tight main loop\\\", {\\n        for (line_number, line) in lines.iter().enumerate() {\\n            let line = if line_number != num_lines - 1 {\\n                format!(\\\"{}\\\\n\\\", line)\\n            } else {\\n                line.to_string()\\n            };\\n            let bytes = line.bytes().collect::<Vec<_>>();\\n\\n            for (char_number, byte) in bytes.iter().cloned().enumerate() {\\n                if line_number == lines.len() - 1 && char_number == bytes.len() - 1 {\\n                    break;\\n                }\\n                parse_results = parser.step(byte);\\n            }\\n        }\\n    });\\n\\n    println!(\\\"assert_parses_tight took {:?}\\\", start.elapsed());\\n}\\n\\npub fn assert_parses_default<T: CombinatorTrait, S: ToString>(combinator: &T, input: S) {\\n    assert_parses(combinator, input, \\\"Parser failed unexpectedly\\\");\\n}\\n\\npub fn profile_parse<T: CombinatorTrait, S: ToString>(combinator: &T, input: S) {\\n    println!(\\\"beginning profile_parse\\\");\\n\\n    let (mut parser, mut parse_results) = combinator.parser(RightData::default());\\n\\n    for byte in tqdm!(input.to_string().bytes(), animation = \\\"fillup\\\", position = 0) {\\n        parse_results = parser.step(byte);\\n    }\\n\\n    print_profile_results();\\n}\\n\\n\\npub fn assert_parses_fast<T: CombinatorTrait, S: ToString>(combinator: &T, input: S) {\\n    let bytes = input.to_string().bytes().collect::<Vec<_>>();\\n    let start = Instant::now();\\n    let (parser, mut parse_results) = profile!(\\\"assert_parses_fast parse\\\", {\\n        combinator.parse(RightData::default(), &bytes)\\n    });\\n    let duration = start.elapsed();\\n    println!(\\\"assert_parses_fast parse took {:?}\\\", duration);\\n    parse_results.squash();\\n\\n    let max_position = parse_results.up_data_vec\\n        .iter()\\n        .max_by_key(|up_data| up_data.get_fields1().position)\\n        .expect(\\\"Expected at least one right data.\\\")\\n        .get_fields1().position;\\n\\n    let (line_number, char_number) = calculate_line_and_char_number(&bytes, max_position);\\n\\n    print_profile_results();\\n\\n    parse_results.squash();\\n\\n    println!(\\\"max_position: {max_position}, line_number: {line_number}, char_number: {char_number}\\\");\\n    assert!(parse_results.up_data_vec\\n        .iter()\\n        .max_by_key(|up_data| up_data.get_fields1().position)\\n        .expect(\\\"Expected at least one right data.\\\")\\n        .get_fields1().position == bytes.len(),\\n        \\\"Expected parser to finish with right data at the end position {}. parse_results: {:?}\\\", bytes.len(), parse_results);\\n}\\n\\npub fn assert_parses_fast_with_tolerance<T: CombinatorTrait, S: ToString>(combinator: &T, input: S, tolerance: usize) {\\n    let bytes = input.to_string().bytes().collect::<Vec<_>>();\\n    let (parser, mut parse_results) = combinator.parse(RightData::default(), &bytes);\\n    parse_results.squash();\\n\\n    let max_position = parse_results.up_data_vec\\n        .iter()\\n        .max_by_key(|up_data| up_data.get_fields1().position)\\n        .expect(\\\"Expected at least one right data.\\\")\\n        .get_fields1().position;\\n\\n    let (line_number, char_number) = calculate_line_and_char_number(&bytes, max_position);\\n\\n    print_profile_results();\\n\\n    assert!(parse_results.up_data_vec\\n        .iter()\\n        .max_by_key(|up_data| up_data.get_fields1().position)\\n        .expect(\\\"Expected at least one right data.\\\")\\n        .get_fields1().position >= bytes.len().saturating_sub(tolerance),\\n        \\\"Expected parser to finish with right data at the end position {}. parse_results: {:?}\\\", bytes.len(), parse_results);\\n}\\n\\npub fn assert_parses_one_shot<T: CombinatorTrait, S: ToString>(combinator: &T, input: S) {\\n    let bytes = input.to_string().bytes().collect::<Vec<_>>();\\n    let start = Instant::now();\\n    let parse_results = profile!(\\\"assert_parses_fast parse\\\", {\\n        combinator.one_shot_parse(RightData::default(), &bytes)\\n    });\\n    let one_shot_up_data = parse_results.expect(\\\"Error parsing input.\\\");\\n    let duration = start.elapsed();\\n    println!(\\\"assert_parses_fast parse took {:?}\\\", duration);\\n\\n    let max_position = one_shot_up_data.get_fields1().position;\\n    let (line_number, char_number) = calculate_line_and_char_number(&bytes, max_position);\\n\\n    print_profile_results();\\n\\n    println!(\\\"max_position: {max_position}, line_number: {line_number}, char_number: {char_number}\\\");\\n\\n    assert!(one_shot_up_data.get_fields1().position == bytes.len(),\\n        \\\"Expected parser to finish with right data at the end position {}. right_data: {:?}\\\", bytes.len(), one_shot_up_data);\\n}\\n\\npub fn assert_parses_one_shot_with_result<T: CombinatorTrait, S: ToString>(combinator: &T, input: S, expected_result: UnambiguousParseResults<T::Output>) {\\n    let bytes = input.to_string().bytes().collect::<Vec<_>>();\\n    let start = Instant::now();\\n    let parse_results = profile!(\\\"assert_parses_fast parse\\\", {\\n        combinator.one_shot_parse(RightData::default(), &bytes)\\n    });\\n    let duration = start.elapsed();\\n    println!(\\\"assert_parses_fast parse took {:?}\\\", duration);\\n\\n    print_profile_results();\\n\\n    assert_eq!(parse_results, expected_result, \\\"Expected parse result {:?}, but got {:?}\\\", expected_result, parse_results);\\n}\\n\\npub fn assert_fails<T: CombinatorTrait, S: ToString>(combinator: &T, input: S, desc: &str) {\\n    let input = input.to_string();\\n    println!(\\\"beginning assert_fails {}\\\", desc);\\n    let (mut parser, ParseResults { .. }) = combinator.parser(RightData::default());\\n\\n    let lines = input.lines().collect::<Vec<_>>();\\n    let num_lines = lines.len();\\n    for (line_number, line) in tqdm!(lines.iter().enumerate(), animation = \\\"fillup\\\", position = 0) {\\n        let line = if line_number != num_lines - 1 {\\n            format!(\\\"{}\\\\n\\\", line)\\n        } else {\\n            line.to_string()\\n        };\\n        let bytes = line.bytes().collect::<Vec<_>>();\\n        for (char_number, byte) in tqdm!(bytes.iter().cloned().enumerate(), animation = \\\"fillup\\\", position = 1) {\\n            let u8set = parser.get_u8set();\\n            if !u8set.contains(byte) {\\n                println!(\\\"byte {:?} is not in the u8set: {:?}\\\", byte as char, u8set);\\n                return;\\n            }\\n\\n            if line_number == lines.len() - 1 && char_number == bytes.len() - 1 {\\n                break;\\n            }\\n\\n            let ParseResults {\\n                up_data_vec: up_data,\\n                ..\\n            } = parser.step(byte).squashed();\\n\\n            if !up_data.is_empty() || !parser.get_u8set().is_empty() {\\n                panic!(\\\"Parser succeeded at byte: {} on line: {} at char: {}\\\", byte as char, line_number, char_number);\\n            }\\n        }\\n    }\\n\\n    panic!(\\\"{}\\\", desc);\\n}\\n\\npub fn assert_fails_default<T: CombinatorTrait, S: ToString>(combinator: &T, input: S) {\\n    assert_fails(combinator, input, \\\"Parser succeeded unexpectedly\\\");\\n}\\n\\npub fn assert_fails_fast<T: CombinatorTrait, S: ToString>(combinator: &T, input: S) {\\n    let (mut parser, _) = combinator.parser(RightData::default());\\n    let bytes = input.to_string().bytes().collect::<Vec<_>>();\\n    let parse_results = parser.parse(&bytes);\\n    assert!(parse_results.done() && parse_results.up_data_vec.iter().max_by_key(|up_data| up_data.get_fields1().position).map_or(true, |up_data| up_data.get_fields1().position == bytes.len()), \\\"Expected parser to fail at the end. parse_results: {:?}\\\", parse_results);\\n}\\n\\n// Helper functions to reduce code duplication\\n\\nfn print_profile_results() {\\n    let profile_data = GLOBAL_PROFILE_DATA.lock().unwrap();\\n    let total_time = profile_data.timings.iter().map(|(_, duration)| *duration).sum::<Duration>();\\n    println!(\\\"Total time: {:?}\\\", total_time);\\n\\n    // Print profile results\\n    let mut profile_vec: Vec<(String, Duration)> = profile_data.timings.iter().map(|(tag, duration)| (tag.clone(), *duration)).collect::<Vec<_>>();\\n    profile_vec.sort_by(|(_, duration_a), (_, duration_b)| duration_b.partial_cmp(duration_a).unwrap());\\n    println!(\\\"Profile results:\\\");\\n    for (tag, duration) in profile_vec.clone() {\\n        let percent = duration.as_secs_f64() / total_time.as_secs_f64() * 100.0;\\n        println!(\\\"{:>9} {:6.2}% {}\\\", format!(\\\"{:.3?}\\\", duration), percent, tag);\\n    }\\n    println!(\\\"Hit counts:\\\");\\n    let total_hit_count = profile_data.hit_counts.values().sum::<usize>();\\n    let mut hit_counts = profile_data.hit_counts.iter().collect::<Vec<_>>();\\n    hit_counts.sort_by(|(_, hit_count_a), (_, hit_count_b)| hit_count_b.partial_cmp(hit_count_a).unwrap());\\n    for (tag, hit_count) in hit_counts.clone() {\\n        let percent = *hit_count as f64 / total_hit_count as f64 * 100.0;\\n        println!(\\\"{:>9} {:6.2}% {}\\\", format!(\\\"{:.3?}\\\", hit_count), percent, tag);\\n    }\\n    // Duration per hit\\n    println!(\\\"Duration per hit:\\\");\\n    let mut duration_per_hit: HashMap<String, Duration> = HashMap::new();\\n    for (tag, hits) in profile_data.hit_counts.iter() {\\n        if let Some(duration) = profile_data.timings.get(tag) {\\n            duration_per_hit.insert(tag.clone(), *duration / *hits as u32);\\n        }\\n    }\\n    let mut duration_per_hit: Vec<(String, Duration)> = duration_per_hit.into_iter().collect::<Vec<_>>();\\n    duration_per_hit.sort_by(|(_, duration_a), (_, duration_b)| duration_b.partial_cmp(duration_a).unwrap());\\n    for (tag, duration) in duration_per_hit.clone() {\\n        let percent = duration.as_secs_f64() / total_time.as_secs_f64() * 100.0;\\n        println!(\\\"{:>9} {:6.2}% {}\\\", format!(\\\"{:.3?}\\\", duration), percent, tag);\\n    }\\n    drop(profile_data);\\n}\\n\\nfn calculate_line_and_char_number(bytes: &[u8], max_position: usize) -> (usize, usize) {\\n    let mut line_number = 0;\\n    let mut char_number = 0;\\n    for byte in bytes[0..max_position].iter().cloned() {\\n        if byte == b'\\\\n' {\\n            line_number += 1;\\n            char_number = 0;\\n        } else {\\n            char_number += 1;\\n        }\\n    }\\n    (line_number, char_number)\\n}\\n\\nfn print_timing_results(timings: Vec<(String, Duration)>) {\\n    // Print timing results\\n    let mut timing_vec: Vec<(String, std::time::Duration)> = timings.into_iter().collect();\\n\\n    // Get 90th percentile\\n    let mut timing_vec_sorted: Vec<(String, std::time::Duration)> = timing_vec.iter().cloned().collect();\\n    timing_vec_sorted.sort_by(|(line_a, duration_a), (line_b, duration_b)| {\\n        let time_per_char_a = duration_a.as_secs_f64() / line_a.len() as f64;\\n        let time_per_char_b = duration_b.as_secs_f64() / line_b.len() as f64;\\n        time_per_char_b.partial_cmp(&time_per_char_a).unwrap()\\n    });\\n    let threshold = timing_vec_sorted[timing_vec_sorted.len() / 10].1;\\n\\n    if VERBOSE {\\n        println!(\\\"Execution time profile:\\\");\\n        for (desc, duration) in timing_vec.clone() {\\n            let duration_secs = duration.as_secs_f64();\\n            let time_per_char = duration_secs / desc.len() as f64 * 1000.0;\\n            let emphasis = if duration > threshold { \\\" * \\\" } else { \\\"   \\\" };\\n            let bold = if duration > threshold { \\\"\\\\x1b[1m\\\" } else { \\\"\\\" };\\n            let reset = if bold.is_empty() { \\\"\\\" } else { \\\"\\\\x1b[0m\\\" };\\n            println!(\\\"{}{:<15}{:<10}{:?}{}s\\\",\\n                     emphasis,\\n                     format!(\\\"{:.3}ms/char\\\", time_per_char),\\n                     format!(\\\"{:.3}s\\\", duration_secs),\\n                     bold,\\n                     desc,\\n            );\\n        }\\n    }\\n\\n    // Save to CSV\\n    let mut csv_file = BufWriter::new(File::create(\\\"timings.csv\\\").unwrap());\\n    csv_file.write_all(\\\"index,text,duration\\\\n\\\".as_bytes()).unwrap();\\n    for (i, (line, duration)) in timing_vec.iter().enumerate() {\\n        // Escape quotes and newlines in the text\\n        let line = line.replace(\\\"\\\\\\\"\\\", \\\"\\\\\\\"\\\\\\\"\\\");\\n        let line = line.replace(\\\"\\\\n\\\", \\\"\\\\\\\\n\\\");\\n        csv_file.write_all(format!(\\\"{},\\\\\\\"{}\\\\\\\",{}\\\\n\\\", i, line, duration.as_secs_f64()).as_bytes()).unwrap();\\n    }\\n    if VERBOSE {\\n        println!(\\\"Saved timings to timings.csv\\\");\\n    }\\n}\"\n} "
    }
  ],
  "prefill_message": null
}