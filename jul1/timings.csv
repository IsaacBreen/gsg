index,text,duration
0,"from __future__ import annotations\n",0.006794
1,"\n",0.000736458
2,"import abc\n",0.006504667
3,"import logging\n",0.011562958
4,"from collections import defaultdict\n",0.00643775
5,"from dataclasses import dataclass\n",0.006524292
6,"from enum import Enum, auto\n",0.0061335
7,"from io import StringIO\n",0.007725
8,"from typing import Self, Iterable, Callable, Any\n",0.00660225
9,"\n",0.000582958
10,"import itertools\n",0.005142709
11,"from tqdm import tqdm\n",0.00774975
12,"\n",0.000519666
13,"\n",0.000904625
14,"class Node(abc.ABC):\n",0.005029958
15,"    @abc.abstractmethod\n",0.005418125
16,"    def decompose_on_left_recursion(self, ref: Ref) -> tuple[Node, Node]:\n",0.013044041
17,"        raise NotImplementedError\n",0.019183959
18,"\n",0.002457417
19,"    @abc.abstractmethod\n",0.0127865
20,"    def replace_left_refs(self, replacements: dict[Ref, Node]) -> Node:\n",0.021611
21,"        raise NotImplementedError\n",0.014937209
22,"\n",0.002102
23,"    @abc.abstractmethod\n",0.010528875
24,"    def simplify(self) -> Node:\n",0.005207167
25,"        raise NotImplementedError\n",0.012724541
26,"\n",0.001658917
27,"\n",0.003087584
28,"class RuleType(Enum):\n",0.016173958
29,"    LEFT_RECURSIVE = auto()\n",0.018153083
30,"    NULLABLE = auto()\n",0.012031083
31,"    NORMAL = auto()\n",0.012181958
32,"\n",0.005267542
33,"\n",0.001714667
34,"def is_nullable(node: Node, nullable_rules: set[Ref]) -> bool:\n",0.047014875
35,"    match node:\n",0.008805375
36,"        case Ref(_):\n",0.002712792
37,"            return node in nullable_rules\n",0.025069375
38,"        case Term(_):\n",0.012637292
39,"            return False\n",0.015248916
40,"        case EpsExternal(_):\n",0.021873083
41,"            return True\n",0.009532917
42,"        case Lookahead(child):\n",0.014251375
43,"            return True\n",0.009857959
44,"        case Seq(children):\n",0.012762459
45,"            return all(is_nullable(child, nullable_rules) for child in children)\n",0.027708041
46,"        case Choice(children):\n",0.011103417
47,"            return any(is_nullable(child, nullable_rules) for child in children)\n",0.027916041
48,"        case Repeat1(child):\n",0.010042333
49,"            return is_nullable(child, nullable_rules)\n",0.029063584
50,"        case _:\n",0.007021583
51,"            raise ValueError(f""Unknown node type: {type(node)}"")\n",0.016613958
52,"\n",0.001697959
53,"\n",0.001846166
54,"def is_null(node: Node, null_rules: set[Ref]) -> bool:\n",0.049675541
55,"    match node:\n",0.008632
56,"        case Ref(_):\n",0.00652675
57,"            return node in null_rules\n",0.018429125
58,"        case Term(_):\n",0.012625958
59,"            return False\n",0.01242875
60,"        case EpsExternal(_):\n",0.017943042
61,"            return True\n",0.011535167
62,"        case Lookahead(child):\n",0.012314667
63,"            return True\n",0.01153175
64,"        case Seq(children):\n",0.011130583
65,"            return all(is_null(child, null_rules) for child in children)\n",0.027942917
66,"        case Choice(children):\n",0.013371833
67,"            return all(is_null(child, null_rules) for child in children)\n",0.034866042
68,"        case Repeat1(child):\n",0.011212042
69,"            return is_null(child, null_rules)\n",0.024338917
70,"        case _:\n",0.007267125
71,"            raise ValueError(f""Unknown node type: {type(node)}"")\n",0.020048417
72,"\n",0.002890208
73,"\n",0.002452291
74,"def update_dict(original: dict, updates: dict) -> bool:\n",0.057620125
75,"    common_keys = set(original.keys()) & set(updates.keys())\n",0.028865958
76,"    updated = False\n",0.008822625
77,"    for key in common_keys:\n",0.009145333
78,"        if original[key] != updates[key]:\n",0.018400917
79,"            updated = True\n",0.012446875
80,"    original.update(updates)\n",0.057880458
81,"    return updated\n",0.007802584
82,"\n",0.001263791
83,"\n",0.001349625
84,"def update_set(original: set, updates: set) -> bool:\n",0.026235166
85,"    initial_len = len(original)\n",0.017481916
86,"    original.update(updates)\n",0.019662542
87,"    return len(original) != initial_len\n",0.0147605
88,"\n",0.00121675
89,"\n",0.001143
90,"def add_to_set(s: set, element) -> bool:\n",0.017753417
91,"    if element not in s:\n",0.007596958
92,"        s.add(element)\n",0.013060459
93,"        return True\n",0.009476167
94,"    return False\n",0.014777292
95,"\n",0.003338125
96,"\n",0.002606166
97,"def get_nullable_rules(rules: dict[Ref, Node]) -> set[Ref]:\n",0.032132959
98,"    # Assume all rules are nullable\n",0.004345292
99,"    nullable_rules = set(rules.keys())\n",0.018918083
100,"    # Keep trying until we can't find anymore\n",0.003984209
101,"    while True:\n",0.006097792
102,"        prev_len = len(nullable_rules)\n",0.018814291
103,"        for ref, node in rules.items():\n",0.013450708
104,"            if not is_nullable(node, nullable_rules):\n",0.021293583
105,"                nullable_rules -= {ref}\n",0.020391875
106,"        if len(nullable_rules) == prev_len:\n",0.044478125
107,"            break\n",0.009732916
108,"    return nullable_rules\n",0.026181875
109,"\n",0.001365958
110,"\n",0.001478541
111,"def get_null_rules(rules: dict[Ref, Node]) -> set[Ref]:\n",0.025472667
112,"    # Assume all rules are null\n",0.005644417
113,"    null_rules = set(rules.keys())\n",0.018179834
114,"    # Keep trying until we can't find anymore\n",0.006926625
115,"    while True:\n",0.007139625
116,"        prev_len = len(null_rules)\n",0.020328292
117,"        for ref, node in rules.items():\n",0.0164435
118,"            if not is_null(node, null_rules):\n",0.021162417
119,"                null_rules -= {ref}\n",0.018232666
120,"        if len(null_rules) == prev_len:\n",0.038559667
121,"            break\n",0.009590875
122,"    return null_rules\n",0.021695584
123,"\n",0.001168125
124,"\n",0.001325458
125,"def get_firsts(node: Node, nullable_rules: set[Ref]) -> set[Ref | Term | EpsExternal]:\n",0.044876458
126,"    if isinstance(node, Term):\n",0.020403792
127,"        return {node}\n",0.01298125
128,"    elif isinstance(node, Ref):\n",0.029527083
129,"        return {node}\n",0.011613833
130,"    elif isinstance(node, EpsExternal):\n",0.033309542
131,"        return {node}\n",0.011856208
132,"    elif isinstance(node, Lookahead):\n",0.033579333
133,"        return set()\n",0.010123
134,"    elif isinstance(node, Seq):\n",0.027048917
135,"        result = set()\n",0.011659625
136,"        for child in node.children:\n",0.013987709
137,"            result.update(get_firsts(child, nullable_rules))\n",0.03516825
138,"            if not is_nullable(child, nullable_rules):\n",0.025631458
139,"                break\n",0.010084458
140,"        return result\n",0.023817708
141,"    elif isinstance(node, Choice):\n",0.029901791
142,"        result = set()\n",0.011597125
143,"        for child in node.children:\n",0.013306958
144,"            result.update(get_firsts(child, nullable_rules))\n",0.036774084
145,"        return result\n",0.016460375
146,"    elif isinstance(node, Repeat1):\n",0.031458875
147,"        return get_firsts(node.child, nullable_rules)\n",0.023025083
148,"    else:\n",0.007520291
149,"        raise ValueError(f""Unknown node type: {type(node)}"")\n",0.024568542
150,"\n",0.002686959
151,"\n",0.0027135
152,"def first_refs(node: Node, nullable_rules: set[Ref]) -> set[Ref]:\n",0.090664333
153,"    return {ref for ref in get_firsts(node, nullable_rules) if isinstance(ref, Ref)}\n",0.027592209
154,"\n",0.001135209
155,"\n",0.000958167
156,"def is_left_recursive(node: Node, rules: dict[Ref, Node], seen: set[Ref] = None) -> bool:\n",0.040373334
157,"    if seen is None:\n",0.005696084
158,"        seen = set()\n",0.008200917
159,"    firsts = first_refs(node, seen)\n",0.025724792
160,"    for ref in firsts:\n",0.006536167
161,"        if ref in seen:\n",0.006651958
162,"            return True\n",0.009563292
163,"        if ref not in rules:\n",0.013286708
164,"            # If it's all capitalized, assume it's a token\n",0.003018375
165,"            if ref.name[0].isupper():\n",0.008783208
166,"                return True\n",0.01017375
167,"            raise ValueError(f""Unknown rule: {ref}"")\n",0.027303
168,"        if is_left_recursive(rules[ref], rules, seen | {ref}):\n",0.050734583
169,"            return True\n",0.010149333
170,"    return False\n",0.018428333
171,"\n",0.001009916
172,"\n",0.001053875
173,"def infer_rule_types(rules: dict[Ref, Node]) -> dict[Ref, RuleType]:\n",0.035534667
174,"    nullable_rules = get_nullable_rules(rules)\n",0.021021708
175,"    rule_types = {}\n",0.01026825
176,"    for ref, node in rules.items():\n",0.011597667
177,"        if ref in nullable_rules:\n",0.007712292
178,"            assert not is_left_recursive(node, rules)\n",0.020511875
179,"            rule_types[ref] = RuleType.NULLABLE\n",0.025094625
180,"        elif is_left_recursive(node, rules):\n",0.033866583
181,"            rule_types[ref] = RuleType.LEFT_RECURSIVE\n",0.025185916
182,"        else:\n",0.010224458
183,"            rule_types[ref] = RuleType.NORMAL\n",0.0224085
184,"    return rule_types\n",0.021765333
185,"\n",0.001158625
186,"\n",0.001050458
187,"def iter_nodes(node: Node) -> Iterable[Node]:\n",0.015543875
188,"    yield node\n",0.006708
189,"    match node:\n",0.0056105
190,"        case Seq(children) | Choice(children):\n",0.009252292
191,"            for child in children:\n",0.010534292
192,"                yield from iter_nodes(child)\n",0.014558584
193,"        case Repeat1(child):\n",0.014023166
194,"            yield from iter_nodes(child)\n",0.013922709
195,"        case EpsExternal(_) | Term(_) | Ref(_):\n",0.014060625
196,"            pass\n",0.006709542
197,"        case Lookahead(child):\n",0.010443333
198,"            yield from iter_nodes(child)\n",0.013196291
199,"        case _:\n",0.006453916
200,"            raise ValueError(f""Unknown node type: {type(node)}"")\n",0.016111084
201,"\n",0.001595083
202,"def validate_rules(rules: dict[Ref, Node]) -> None:\n",0.029133417
203,"    for ref, node in rules.items():\n",0.012361834
204,"        for child in iter_nodes(node):\n",0.014003209
205,"            assert isinstance(child, Node)\n",0.020932459
206,"    rule_types = infer_rule_types(rules)\n",0.05320825
207,"    for ref, rule_type in tqdm(rule_types.items(), desc=""Validating rules""):\n",0.021257791
208,"        firsts = first_refs(rules[ref], get_nullable_rules(rules))\n",0.027249459
209,"        def get_rule_type(ref: Ref, rule_types: dict[Ref, RuleType]) -> RuleType:\n",0.022117166
210,"            # If it's all capitalized, assume it's a token\n",0.004583916
211,"            if ref not in rules:\n",0.00775075
212,"                if ref.name[0].isupper():\n",0.010385167
213,"                    return RuleType.NORMAL\n",0.014506834
214,"            return rule_types[ref]\n",0.035689916
215,"        if rule_type == RuleType.LEFT_RECURSIVE:\n",0.021975584
216,"            if any(get_rule_type(first_ref, rule_types) == RuleType.NULLABLE for first_ref in firsts):\n",0.032014292
217,"                raise ValueError(f""Firsts for left-recursive rule must not be nullable. Found {firsts} for {rules[ref]}"")\n",0.026843916
218,"        elif rule_type == RuleType.NULLABLE:\n",0.034513167
219,"            if any(get_rule_type(first_ref, rule_types) == RuleType.LEFT_RECURSIVE for first_ref in firsts):\n",0.036079875
220,"                raise ValueError(f""Firsts for nullable rule must not be left-recursive. Found {firsts} for {rules[ref]}"")\n",0.03054325
221,"        elif rule_type == RuleType.NORMAL:\n",0.037627
222,"            if any(get_rule_type(first_ref, rule_types) == RuleType.LEFT_RECURSIVE for first_ref in firsts):\n",0.038106792
223,"                raise ValueError(f""Firsts for non-nullable rule must not be left-recursive. Found {firsts} for {rules[ref]}"")\n",0.0338455
224,"        else:\n",0.017550666
225,"            raise ValueError(f""Unknown rule type: {rule_type}"")\n",0.026776292
226,"\n",0.003499917
227,"\n",0.00375225
228,"def resolve_left_recursion_for_rule[T: Node](node: T, ref: Ref, replacements: dict[Ref, Node]) -> Node:\n",0.18681675
229,"    # Resolve indirect left recursion\n",0.008479125
230,"    node.replace_left_refs(replacements)\n",0.028095292
231,"    # Resolve direct left recursion\n",0.005908708
232,"    first, recursive = node.decompose_on_left_recursion(ref)\n",0.026193834
233,"    return seq(choice(first), repeat0(choice(recursive))).simplify()\n",0.03220775
234,"\n",0.001423584
235,"\n",0.001118333
236,"def resolve_left_recursion(rules: dict[Ref, Node]) -> dict[Ref, Node]:\n",0.031645208
237,"    replacements = {}\n",0.013466
238,"    for ref, node in rules.items():\n",0.009509166
239,"        replacements[ref] = resolve_left_recursion_for_rule(node, ref, replacements)\n",0.038603292
240,"    return replacements\n",0.013620292
241,"\n",0.001297084
242,"\n",0.001341541
243,"def intersperse_separator_for_node(node: Node, separator: Node, nullable_rules: set[Ref]) -> Node:\n",0.052040083
244,"    try:\n",0.004586709
245,"        match node:\n",0.007182417
246,"            case Seq([]):\n",0.00257775
247,"                return node\n",0.008769166
248,"            case Seq(children):\n",0.011044667
249,"                # Actually, as long as we have a single non-nullable sequent, we're good.\n",0.003317541
250,"                try:\n",0.005483166
251,"                    i = [is_nullable(child, nullable_rules) for child in children].index(False)\n",0.0354645
252,"                except ValueError as e:\n",0.011862084
253,"                    e.add_note(f""There must be at least one non-nullable sequent in {node}"")\n",0.016680167
254,"                    raise\n",0.014107292
255,"\n",0.0016515
256,"                # Insert a suffix for all children before i, and a prefix for all children after i.\n",0.011146625
257,"                for j, child in enumerate(children):\n",0.037127
258,"                    if j < i:\n",0.007536333
259,"                        children[j] = inject_suffix_on_nonnull_for_node(child, separator, nullable_rules)\n",0.050702292
260,"                    elif j == i:\n",0.022474541
261,"                        children[j] = intersperse_separator_for_node(child, separator, nullable_rules)\n",0.053443625
262,"                    else:\n",0.019115584
263,"                        children[j] = inject_prefix_on_nonnull_for_node(child, separator, nullable_rules)\n",0.052428083
264,"                return seq(*children)\n",0.033829166
265,"\n",0.001113042
266,"            case Choice(children):\n",0.012192458
267,"                return Choice([intersperse_separator_for_node(child, separator, nullable_rules) for child in children])\n",0.049974292
268,"            case Repeat1(child):\n",0.012796041
269,"                return sep1(intersperse_separator_for_node(child, separator, nullable_rules), separator)\n",0.05254375
270,"            case Ref(_) | Term(_) | EpsExternal(_):\n",0.01737725
271,"                return node\n",0.009592291
272,"            case Lookahead(child):\n",0.012903625
273,"                return lookahead(intersperse_separator_for_node(child, separator, nullable_rules))\n",0.048228208
274,"            case _:\n",0.008047417
275,"                raise ValueError(f""Unexpected node: {node}"")\n",0.016320959
276,"    except ValueError as e:\n",0.019981
277,"        e.add_note(f""Error while interspersing separator in {node}"")\n",0.019316667
278,"        raise\n",0.017981417
279,"\n",0.001775417
280,"\n",0.001632458
281,"def inject_prefix_on_nonnull_for_node(node: Node, prefix: Node, nullable_rules: set[Ref]) -> Node:\n",0.093064708
282,"    try:\n",0.005283125
283,"        if not is_nullable(node, nullable_rules):\n",0.020447833
284,"            return seq(prefix, intersperse_separator_for_node(node, prefix, nullable_rules))\n",0.047912167
285,"        match node:\n",0.014969292
286,"            case Choice(children):\n",0.008405875
287,"                return Choice([inject_prefix_on_nonnull_for_node(child, prefix, nullable_rules) for child in children])\n",0.050208791
288,"            case Seq(children):\n",0.013265417
289,"                children = [inject_prefix_on_nonnull_for_node(child, prefix, nullable_rules) for child in children]\n",0.063122666
290,"                return seq(*children)\n",0.015215459
291,"            case EpsExternal(_):\n",0.013868
292,"                return node\n",0.011172333
293,"            case Lookahead(child):\n",0.014446292
294,"                return node\n",0.011239625
295,"            case _:\n",0.0094125
296,"                raise ValueError(f""Unexpected nullable node: {node}"")\n",0.023510875
297,"    except ValueError as e:\n",0.028949959
298,"        e.add_note(f""Error while adding prefix in {node}"")\n",0.0231185
299,"        raise\n",0.019763708
300,"\n",0.001898625
301,"\n",0.001715583
302,"def inject_suffix_on_nonnull_for_node(node: Node, suffix: Node, nullable_rules: set[Ref]) -> Node:\n",0.139605042
303,"    try:\n",0.006441667
304,"        if not is_nullable(node, nullable_rules):\n",0.02390075
305,"            return seq(intersperse_separator_for_node(node, suffix, nullable_rules), suffix)\n",0.055477125
306,"        match node:\n",0.017048041
307,"            case Choice(children):\n",0.009446042
308,"                return Choice([inject_suffix_on_nonnull_for_node(child, suffix, nullable_rules) for child in children])\n",0.059124834
309,"            case Seq(children):\n",0.014879334
310,"                children = [inject_suffix_on_nonnull_for_node(child, suffix, nullable_rules) for child in children]\n",0.072403625
311,"                return seq(*children)\n",0.017270667
312,"            case EpsExternal(_):\n",0.01523675
313,"                return node\n",0.01245225
314,"            case Lookahead(child):\n",0.016141583
315,"                return node\n",0.012398459
316,"            case _:\n",0.011189666
317,"                raise ValueError(f""Unexpected nullable node: {node}"")\n",0.029855
318,"    except ValueError as e:\n",0.0331765
319,"        e.add_note(f""Error while adding suffix in {node}"")\n",0.02893725
320,"        raise\n",0.02429425
321,"\n",0.00237725
322,"def intersperse_separator(rules: dict[Ref, Node], separator: Node) -> dict[Ref, Node]:\n",0.1506265
323,"    nullable_rules = get_nullable_rules(rules)\n",0.029223375
324,"    new_rules = {}\n",0.011927208
325,"    for ref, node in rules.items():\n",0.009530375
326,"        try:\n",0.004771209
327,"            new_rules[ref] = intersperse_separator_for_node(node, separator, nullable_rules).simplify()\n",0.049402208
328,"        except ValueError as e:\n",0.008361084
329,"            e.add_note(f""Error while interspersing separator for rule {prettify_rule(ref, node)}"")\n",0.022055417
330,"            raise\n",0.010396584
331,"    return new_rules\n",0.019176083
332,"\n",0.001095042
333,"\n",0.001295375
334,"def get_firsts_for_node(node: Node, nullable_rules: set[Ref]) -> set[Ref | Term | EpsExternal]:\n",0.036150625
335,"    match node:\n",0.007380416
336,"        case Ref(_):\n",0.003104208
337,"            return {node}\n",0.011676084
338,"        case Term(_):\n",0.008864625
339,"            return {node}\n",0.012152959
340,"        case EpsExternal(_):\n",0.011042583
341,"            return {node}\n",0.012149125
342,"        case Lookahead(child):\n",0.011965125
343,"            return set()\n",0.01069325
344,"        case Seq(children):\n",0.01140575
345,"            result = set()\n",0.011365625
346,"            for child in children:\n",0.012649834
347,"                result.update(get_firsts_for_node(child, nullable_rules))\n",0.045524833
348,"                if not is_nullable(child, nullable_rules):\n",0.025781833
349,"                    break\n",0.009751209
350,"            return result\n",0.026612916
351,"        case Choice(children):\n",0.011639459
352,"            result = set()\n",0.012065458
353,"            for child in children:\n",0.01355175
354,"                result.update(get_firsts_for_node(child, nullable_rules))\n",0.046429291
355,"            return result\n",0.01911325
356,"        case Repeat1(child):\n",0.011183542
357,"            return get_firsts_for_node(child, nullable_rules)\n",0.025790834
358,"        case _:\n",0.007582167
359,"            raise ValueError(f""Unknown node type: {type(node)}"")\n",0.02002775
360,"\n",0.002088875
361,"\n",0.002669916
362,"def get_lasts_for_node(node: Node, nullable_rules: set[Ref]) -> set[Ref | Term | EpsExternal]:\n",0.097887125
363,"    match node:\n",0.007584542
364,"        case Ref(_):\n",0.00345625
365,"            assert isinstance(node, Ref)\n",0.020706083
366,"            return {node}\n",0.013652
367,"        case Term(_):\n",0.01026375
368,"            assert isinstance(node, Term)\n",0.021848125
369,"            return {node}\n",0.013435541
370,"        case EpsExternal(_):\n",0.012225292
371,"            assert isinstance(node, EpsExternal)\n",0.025429875
372,"            return {node}\n",0.013257791
373,"        case Lookahead(child):\n",0.013659666
374,"            return set()\n",0.011655166
375,"        case Seq(children):\n",0.012108084
376,"            result = set()\n",0.012750417
377,"            for child in reversed(children):\n",0.0198745
378,"                result.update(get_lasts_for_node(child, nullable_rules))\n",0.049463584
379,"                if not is_nullable(child, nullable_rules):\n",0.029758084
380,"                    break\n",0.011669333
381,"            return result\n",0.030111958
382,"        case Choice(children):\n",0.014153667
383,"            result = set()\n",0.013017792
384,"            for child in children:\n",0.014458875
385,"                result.update(get_lasts_for_node(child, nullable_rules))\n",0.050619375
386,"            return result\n",0.020383084
387,"        case Repeat1(child):\n",0.012532041
388,"            return get_lasts_for_node(child, nullable_rules)\n",0.028013417
389,"        case _:\n",0.007917292
390,"            raise ValueError(f""Unknown node type: {type(node)}"")\n",0.023107042
391,"\n",0.002420959
392,"\n",0.002364334
393,"def get_definite_lasts_for_node(node: Node, nullable_rules: set[Ref]) -> set[Ref | Term | EpsExternal]:\n",0.116313042
394,"    match node:\n",0.00785225
395,"        case Ref(_):\n",0.003948458
396,"            assert isinstance(node, Ref)\n",0.019936666
397,"            return {node}\n",0.013639334
398,"        case Term(_):\n",0.011488875
399,"            assert isinstance(node, Term)\n",0.025519083
400,"            return {node}\n",0.015844708
401,"        case EpsExternal(_):\n",0.0140025
402,"            assert isinstance(node, EpsExternal)\n",0.029284833
403,"            return {node}\n",0.015243959
404,"        case Lookahead(child):\n",0.015120958
405,"            return set()\n",0.013405041
406,"        case Seq(children):\n",0.014650958
407,"            result = set()\n",0.014872792
408,"            for child in reversed(children):\n",0.023077291
409,"                result.update(get_lasts_for_node(child, nullable_rules))\n",0.054850083
410,"                if not is_nullable(child, nullable_rules):\n",0.033602583
411,"                    break\n",0.012695958
412,"            return result\n",0.029840416
413,"        case Choice(children):\n",0.015390917
414,"            result = set()\n",0.0156735
415,"            for child in children:\n",0.017588583
416,"                result.update(get_lasts_for_node(child, nullable_rules))\n",0.052905167
417,"            return result\n",0.021885708
418,"        case Repeat1(child):\n",0.014501125
419,"            return get_lasts_for_node(child, nullable_rules)\n",0.031298667
420,"        case _:\n",0.008684708
421,"            raise ValueError(f""Unknown node type: {type(node)}"")\n",0.025846542
422,"\n",0.002379333
423,"\n",0.002383958
424,"def get_firsts2(rules: dict[Ref, Node]) -> dict[Ref, set[Ref | Term | EpsExternal]]:\n",0.083623167
425,"    firsts: dict[Ref, set[Ref | Term | EpsExternal]] = {}\n",0.019973291
426,"    nullable_rules = get_nullable_rules(rules)\n",0.01710875
427,"    for ref, node in tqdm(rules.items(), desc=""Computing firsts""):\n",0.013978583
428,"        firsts[ref] = get_firsts_for_node(node, nullable_rules)\n",0.031524042
429,"    # Substitute firsts for refs repeatedly until there are no more changes\n",0.003290417
430,"    while True:\n",0.011555541
431,"        old_firsts = firsts.copy()\n",0.014714083
432,"        for ref in firsts:\n",0.008180125
433,"            for first in list(firsts[ref]):\n",0.01440525
434,"                if first in firsts:\n",0.007743167
435,"                    firsts[ref].update(firsts[first])\n",0.029935583
436,"        if not update_dict(firsts, old_firsts):\n",0.05507325
437,"            break\n",0.007151708
438,"    return firsts\n",0.017515708
439,"\n",0.001018833
440,"\n",0.001307
441,"def get_lasts(rules: dict[Ref, Node]) -> dict[Ref, set[Ref | Term | EpsExternal]]:\n",0.029133167
442,"    lasts: dict[Ref, set[Ref | Term | EpsExternal]] = {}\n",0.013683875
443,"    nullable_rules = get_nullable_rules(rules)\n",0.017214208
444,"    for ref, node in tqdm(rules.items(), desc=""Computing lasts""):\n",0.013520458
445,"        lasts[ref] = get_lasts_for_node(node, nullable_rules)\n",0.026937792
446,"    # Substitute lasts for refs repeatedly\n",0.002846708
447,"    while True:\n",0.01063725
448,"        old_lasts = lasts.copy()\n",0.012473875
449,"        for ref in lasts:\n",0.007801583
450,"            for last in list(lasts[ref]):\n",0.013809083
451,"                if last in lasts:\n",0.0074105
452,"                    lasts[ref].update(lasts[last])\n",0.027224041
453,"        if not update_dict(lasts, old_lasts):\n",0.054017333
454,"            break\n",0.007114167
455,"    return lasts\n",0.016264958
456,"\n",0.001123208
457,"\n",0.000975875
458,"def collect_follows_for_node(node: Node, nullable_rules: set[Ref]) -> dict[Ref | Term | EpsExternal, set[Ref | Term | EpsExternal]]:\n",0.042638958
459,"    match node:\n",0.006424875
460,"        case Ref(_):\n",0.00239375
461,"            return {}\n",0.007821541
462,"        case Term(_):\n",0.007308041
463,"            return {}\n",0.007920416
464,"        case EpsExternal(_):\n",0.00881125
465,"            return {}\n",0.007793666
466,"        case Lookahead(child):\n",0.009952042
467,"            return {}\n",0.008075708
468,"        case Seq(children):\n",0.009358209
469,"            result: dict[Ref | Term | EpsExternal, set[Ref | Term | EpsExternal]] = {}\n",0.020788166
470,"            for i, child in enumerate(children):\n",0.016334083
471,"                lasts_for_child = get_lasts_for_node(child, nullable_rules)\n",0.033957625
472,"                rest = Seq(children[i + 1:])\n",0.018460458
473,"                firsts_for_rest = get_firsts_for_node(rest, nullable_rules)\n",0.035914625
474,"                for last in lasts_for_child:\n",0.016004167
475,"                    result.setdefault(last, set()).update(firsts_for_rest)\n",0.042743291
476,"            return result\n",0.02433275
477,"        case Choice(children):\n",0.009769458
478,"            result: dict[Ref | Term | EpsExternal, set[Ref | Term | EpsExternal]] = {}\n",0.020218834
479,"            for child in children:\n",0.010227666
480,"                result.update(collect_follows_for_node(child, nullable_rules))\n",0.043110292
481,"            return result\n",0.016400792
482,"        case Repeat1(child):\n",0.009190791
483,"            lasts = get_lasts_for_node(child, nullable_rules)\n",0.023385459
484,"            firsts = get_firsts_for_node(child, nullable_rules)\n",0.024968958
485,"            result: dict[Ref | Term | EpsExternal, set[Ref | Term | EpsExternal]] = {}\n",0.0205675
486,"            for last in lasts:\n",0.009028583
487,"                result[last] = firsts\n",0.018325375
488,"            return result\n",0.016413125
489,"        case _:\n",0.00613575
490,"            raise ValueError(f""Unknown node type: {type(node)}"")\n",0.014523292
491,"\n",0.001736291
492,"\n",0.001548208
493,"def gather_all_leaves(rules: dict[Ref, Node]) -> set[Ref | Term | EpsExternal]:\n",0.038646084
494,"    result = set()\n",0.008299708
495,"    for ref, node in rules.items():\n",0.010122708
496,"        result.add(ref)\n",0.012175417
497,"        result.update(x for x in iter_nodes(node) if isinstance(x, Ref | Term | EpsExternal))\n",0.030316042
498,"    return result\n",0.012319708
499,"\n",0.001093667
500,"\n",0.000985334
501,"def get_follows(rules: dict[Ref, Node]) -> dict[Ref | Term | EpsExternal, set[Ref | Term | EpsExternal]]:\n",0.035601
502,"    follow_sets: dict[Ref, set[Ref | Term | EpsExternal]] = {}\n",0.018012583
503,"    nullable_rules = get_nullable_rules(rules)\n",0.017002042
504,"    for ref, node in rules.items():\n",0.009266042
505,"        for leaf, follow_set in collect_follows_for_node(node, nullable_rules).items():\n",0.027965
506,"            follow_sets.setdefault(leaf, set()).update(follow_set)\n",0.033802917
507,"    firsts_for_node = {}\n",0.032364083
508,"    for ref, node in rules.items():\n",0.009325666
509,"        firsts_for_node[ref] = get_firsts_for_node(node, nullable_rules)\n",0.034687375
510,"    for leaf in gather_all_leaves(rules):\n",0.02253375
511,"        follow_sets.setdefault(leaf, set())\n",0.021019166
512,"        firsts_for_node.setdefault(leaf, set())\n",0.025904583
513,"    # Substitute follow sets for refs repeatedly\n",0.002903625
514,"    while True:\n",0.010375583
515,"        updated = False\n",0.009403417
516,"        for ref, follow_set in follow_sets.items():\n",0.014813125
517,"            queue = list(follow_set)\n",0.015950875
518,"            while len(queue) > 0:\n",0.012339083
519,"                node = queue.pop()\n",0.011465625
520,"                if isinstance(node, Ref) and node in rules:\n",0.02315275
521,"                    firsts = firsts_for_node[node]\n",0.022200375
522,"                    new_follows = firsts - follow_set\n",0.026433959
523,"                    queue.extend(new_follows)\n",0.030687916
524,"                    updated |= update_set(follow_set, new_follows)\n",0.031553291
525,"        for ref, node in rules.items():\n",0.044948041
526,"            # The follow set of a rule should inherit the follow set of its lasts and vice versa\n",0.003799917
527,"            lasts_for_rule = get_lasts_for_node(node, nullable_rules)\n",0.029856208
528,"            for last in lasts_for_rule:\n",0.013904125
529,"                updated |= update_set(follow_sets[last], follow_sets[ref])\n",0.025558333
530,"                updated |= update_set(follow_sets[ref], follow_sets[last])\n",0.031031
531,"        if not updated:\n",0.019191542
532,"            break\n",0.007349917
533,"    return follow_sets\n",0.021152917
534,"\n",0.001194666
535,"\n",0.00116875
536,"def map_left(node: Node, f: Callable[[Node], Node], nullable_rules: set[Ref]) -> Node:\n",0.0354405
537,"    node = f(node)\n",0.0080495
538,"    match node:\n",0.005123625
539,"        case Seq(children):\n",0.004210542
540,"            children = children.copy()\n",0.013752625
541,"            for i, child in enumerate(children):\n",0.016232833
542,"                children[i] = map_left(child, f, nullable_rules)\n",0.027319417
543,"                if not is_nullable(child, nullable_rules):\n",0.02243675
544,"                    break\n",0.0081365
545,"            return Seq(children)\n",0.03460875
546,"        case Choice(children):\n",0.009644541
547,"            return Choice([map_left(child, f, nullable_rules) for child in children])\n",0.02451125
548,"        case Repeat1(child):\n",0.009122208
549,"            return Repeat1(map_left(child, f, nullable_rules))\n",0.02251325
550,"        case _:\n",0.006191416
551,"            return node\n",0.008255709
552,"\n",0.001509041
553,"\n",0.001541667
554,"def map_all_for_node(node: Node, f: Callable[[Node], Node]) -> Node:\n",0.033808333
555,"    match node:\n",0.00642425
556,"        case Seq(children):\n",0.004432333
557,"            node = Seq([map_all_for_node(child, f) for child in children])\n",0.023465666
558,"        case Choice(children):\n",0.00997025
559,"            node = Choice([map_all_for_node(child, f) for child in children])\n",0.025859584
560,"        case Repeat1(child):\n",0.009191875
561,"            node = Repeat1(map_all_for_node(child, f))\n",0.024218334
562,"        case _:\n",0.006152583
563,"            node = node\n",0.00784525
564,"    node = f(node)\n",0.013155791
565,"    return node\n",0.005571542
566,"\n",0.001031166
567,"\n",0.0009865
568,"def map_all(rules: dict[Ref, Node], f: Callable[[Node], Node]) -> dict[Ref, Node]:\n",0.030378542
569,"    return {ref: map_all_for_node(node, f) for ref, node in rules.items()}\n",0.019413542
570,"\n",0.000981791
571,"\n",0.000955959
572,"def ensure_lasts_for_node(node: Node, includes: set[Ref | Term | EpsExternal], nullable_rules: set[Ref]) -> Node:\n",0.041020333
573,"    match node:\n",0.006433667
574,"        case Seq(children):\n",0.004208125
575,"            raise NotImplementedError\n",0.010597333
576,"        case Choice(children):\n",0.009776334
577,"            return Choice([ensure_lasts_for_node(child, includes, nullable_rules) for child in children])\n",0.034964
578,"        case Repeat1(child):\n",0.009174959
579,"            return seq(repeat0(child), ensure_lasts_for_node(child, includes, nullable_rules))\n",0.036681625
580,"        case Ref(_) | Term(_) | EpsExternal(_):\n",0.01303775
581,"            return node\n",0.008278708
582,"\n",0.00154125
583,"\n",0.001471792
584,"def ensure_firsts_for_node(node: Node, includes: set[Ref | Term | EpsExternal], nullable_rules: set[Ref]) -> Node:\n",0.061486916
585,"    raise NotImplementedError\n",0.008936958
586,"\n",0.001036208
587,"\n",0.000954083
588,"def forbid_lasts_for_node(node: Node, excludes: set[Ref | Term | EpsExternal], nullable_rules: set[Ref]) -> Node:\n",0.0408175
589,"    all_leaves = set(leaf for leaf in iter_nodes(node) if isinstance(leaf, Ref | Term | EpsExternal))\n",0.026444625
590,"    includes = all_leaves - excludes\n",0.010797833
591,"    return ensure_lasts_for_node(node, includes, nullable_rules)\n",0.019282334
592,"\n",0.001014959
593,"\n",0.001000125
594,"def forbid_firsts_for_node(node: Node, excludes: set[Ref | Term | EpsExternal], nullable_rules: set[Ref]) -> Node:\n",0.040896583
595,"    all_leaves = set(leaf for leaf in iter_nodes(node) if isinstance(leaf, Ref | Term | EpsExternal))\n",0.028028458
596,"    includes = all_leaves - excludes\n",0.010978541
597,"    return ensure_firsts_for_node(node, includes, nullable_rules)\n",0.0194525
598,"\n",0.000996875
599,"\n",0.000985333
600,"def forbid_follows_for_node(node: Node, first: Ref | Term | EpsExternal, forbidden_follows: set[Ref | Term | EpsExternal], nullable_rules: set[Ref], null_rules: set[Ref]) -> Node:\n",0.069114625
601,"    try:\n",0.004291458
602,"        match node:\n",0.006899667
603,"            case Seq(children):\n",0.004506167
604,"                children = children.copy()\n",0.0143115
605,"                for i, child in enumerate(children):\n",0.0175575
606,"                    lasts_for_child = get_lasts_for_node(child, nullable_rules)\n",0.035228
607,"                    # Decide whether to trigger\n",0.008707834
608,"                    if first in lasts_for_child:\n",0.015712959
609,"                        # Put the subsequent `children[i + 1:]` in a new sequence called `rest`, and call the current one (`children[i]`) `child`.\n",0.004032791
610,"                        #\n",0.003245
611,"                        # Replace the rest of this node with `seq(child, rest)`.\n",0.003577583
612,"                        #\n",0.003231625
613,"                        # Rewrite `seq(child, rest)` as a `choice(seq(child0, rest0), seq(child1, rest` where:\n",0.003742584
614,"                        #\n",0.00314325
615,"                        # - `child0` is a variant of `child` that hits `first` last and `rest0` is a variant of `rest` that doesn't hit anything in `forbidden_follows` first\n",0.004079417
616,"                        # - `child1` is a variant of `child` that doesn't hit `first` last\n",0.003588375
617,"                        #\n",0.003145
618,"                        # To make it clearer how this works, we can explicitly write out all four cases for `seq(child, rest)`:\n",0.003878709
619,"                        #\n",0.003149958
620,"                        # 1. `child` hits `first` last and `rest` hits anything in `forbidden_follows` first\n",0.003710667
621,"                        # 2. `child` hits `first` last and `rest` hits doesn't hit anything in `forbidden_follows` first\n",0.003744833
622,"                        # 4. `child` doesn't hit `first` last and `rest` hits anything in `forbidden_follows` first\n",0.003731417
623,"                        # 3. `child` doesn't hit `first` last and `rest` doesn't hit anything in `forbidden_follows` first\n",0.003711833
624,"                        #\n",0.003210458
625,"                        # The case we want to eliminate is case 1 where a `forbidden_follow` follows the `first`. So, we eliminate case 1.\n",0.003821292
626,"                        #\n",0.003198459
627,"                        # To show how case 3 and 4 can be merged, let's denote\n",0.003476875
628,"                        #\n",0.00312225
629,"                        # - '`child` hits `first` last' by 'A'\n",0.0033815
630,"                        # - '`child` doesn't hit `first` last' by 'not A'\n",0.003403416
631,"                        # - '`rest` hits anything in `forbidden_follows` first' by 'B'.\n",0.003499
632,"                        # - '`rest` doesn't hit anything in `forbidden_follows` first' by 'not B'.\n",0.003636291
633,"                        #\n",0.003140458
634,"                        # Case 3 is of the form 'not A and B', while case 4 is of the form 'not A and not B', so we can merge them into a single case\n",0.003938167
635,"                        # of the form:\n",0.003178625
636,"                        #\n",0.003227584
637,"                        # '(not A and B) or (not A and not B)' which is equivalent to\n",0.003567958
638,"                        # 'not A and (B or not B)', which is equivalent to\n",0.003491875
639,"                        # 'not A'\n",0.00317825
640,"                        #\n",0.003101
641,"                        # 'not A' is just '`child` doesn't hit `first` last'. So, putting our merged version of case 3 and 4 together with case 1 gives us:\n",0.00396225
642,"                        #\n",0.003173083
643,"                        # - `child0` is a variant of `child` that hits `first` last and `rest0` is a variant of `rest` that doesn't hit anything in `forbidden_follows` first\n",0.004087709
644,"                        # - `child1` is a variant of `child` that doesn't hit `first` last\n",0.003522166
645,"                        rest = Seq(children[i + 1:])\n",0.017828667
646,"\n",0.002111083
647,"                        child0 = forbid_lasts_for_node(child, forbidden_follows, nullable_rules)\n",0.057203125
648,"                        child1 = ensure_lasts_for_node(child, forbidden_follows, nullable_rules)\n",0.052424542
649,"\n",0.002072917
650,"                        rest0 = ensure_firsts_for_node(rest, forbidden_follows, nullable_rules)\n",0.051930167
651,"\n",0.002148458
652,"                        new_node = choice(\n",0.022474542
653,"                            seq(child0, rest0),\n",0.02474825
654,"                            seq(child1, rest),\n",0.019465458
655,"                        )\n",0.010570667
656,"                        new_node = forbid_follows_for_node(new_node, first, forbidden_follows, nullable_rules, null_rules)\n",0.071211208
657,"                        children = [children[:i], new_node]\n",0.035008875
658,"                        return Seq(children)\n",0.024163375
659,"                return Seq(children)\n",0.039975708
660,"            case Choice(children):\n",0.011407292
661,"                return Choice([forbid_follows_for_node(child, first, forbidden_follows, nullable_rules, null_rules) for child in children])\n",0.055378583
662,"            case Repeat1(child):\n",0.010971708
663,"                return Repeat1(forbid_follows_for_node(child, first, forbidden_follows, nullable_rules, null_rules))\n",0.05631775
664,"            case Ref(_) | Term(_) | EpsExternal(_):\n",0.014743833
665,"                return node\n",0.008491083
666,"            case Lookahead(_):\n",0.010546708
667,"                return node\n",0.008990541
668,"            case _:\n",0.007813417
669,"                raise ValueError(f""Unexpected node: {node}"")\n",0.013103834
670,"    except ValueError as e:\n",0.012110083
671,"        e.add_note(f""Error while forbidding follows for {node} with first {first} and forbidden follows {forbidden_follows}"")\n",0.032245334
672,"        raise\n",0.012788917
673,"\n",0.001618875
674,"\n",0.00178125
675,"def forbid_follows(rules: dict[Ref, Node], forbidden_follows_table: dict[Ref | Term | EpsExternal, set[Ref | Term | EpsExternal]]) -> dict[Ref, Node]:\n",0.103473125
676,"    nullable_rules = get_nullable_rules(rules)\n",0.021132833
677,"    null_rules = get_null_rules(rules)\n",0.016971167
678,"    firsts = get_firsts2(rules)\n",0.014032875
679,"    lasts = get_lasts(rules)\n",0.012362542
680,"\n",0.001212917
681,"    # Expand the forbidden follows table\n",0.00426225
682,"    while True:\n",0.00651125
683,"        updated = False\n",0.011281584
684,"        for first, forbidden_follows in list(forbidden_follows_table.items()):\n",0.038679167
685,"            for ref, last_set in lasts.items():\n",0.016437667
686,"                if first in last_set:\n",0.010615834
687,"                    # if len(last_set) > 1:\n",0.004988666
688,"                    #     raise ValueError(f""Cannot forbid follows for {ref} with first {first} and forbidden follows {forbidden_follows} because the last set {last_set} for this rule has more than one last (how would we disambiguate?)"")\n",0.036262625
689,"                    # The rule for ref can end with the first for this row in the forbidden follows table.\n",0.016409792
690,"                    # Any follows that are forbidden Æ’or this first must also be forbidden for this ref.\n",0.016026792
691,"                    updated |= update_set(forbidden_follows_table.setdefault(ref, set()), forbidden_follows)\n",0.060333709
692,"            for forbidden_follow in list(forbidden_follows):\n",0.090381375
693,"                if forbidden_follow in firsts:\n",0.015928
694,"                    updated |= update_set(forbidden_follows, firsts[forbidden_follow])\n",0.042650958
695,"        if not updated:\n",0.0270545
696,"            break\n",0.008791625
697,"\n",0.002030084
698,"    for ref in tqdm(rules.keys(), desc=""Forbidding follows""):\n",0.040963625
699,"        for first, forbidden_follows in forbidden_follows_table.items():\n",0.033809042
700,"            rules[ref] = forbid_follows_for_node(rules[ref], first, forbidden_follows, nullable_rules, null_rules)\n",0.061278542
701,"        rules[ref] = rules[ref].simplify()\n",0.042867541
702,"    return rules\n",0.012464667
703,"\n",0.00105125
704,"\n",0.001027042
705,"@dataclass\n",0.005221
706,"class Seq(Node):\n",0.002897583
707,"    children: list[Node]\n",0.011858875
708,"\n",0.001099667
709,"    def decompose_on_left_recursion(self, ref: Ref) -> tuple[Node, Node]:\n",0.016791459
710,"        if len(self.children) == 0:\n",0.01209525
711,"            return self, fail()\n",0.012138916
712,"        else:\n",0.010517959
713,"            first, recursive = self.children[0].decompose_on_left_recursion(ref)\n",0.033271916
714,"            return Seq([first, *self.children[1:]]), Seq([recursive, *self.children[1:]])\n",0.028905625
715,"\n",0.002217958
716,"    def replace_left_refs(self, replacements: dict[Ref, Node]) -> Node:\n",0.052233125
717,"        if len(self.children) == 0:\n",0.011574709
718,"            return self\n",0.010191208
719,"        else:\n",0.010328375
720,"            self.children[0] = self.children[0].replace_left_refs(replacements)\n",0.036187375
721,"            return self\n",0.011842834
722,"\n",0.002528792
723,"    def simplify(self) -> Node:\n",0.022374042
724,"        # Simplify children\n",0.004489875
725,"        children = [child.simplify() for child in self.children]\n",0.02537475
726,"        # If there are any fail() children, then the whole thing is fail()\n",0.008089084
727,"        if any(child == fail() for child in children):\n",0.015700083
728,"            return fail()\n",0.011121625
729,"        # Remove any eps() children\n",0.007773
730,"        children = [child for child in children if child != eps()]\n",0.037880167
731,"\n",0.001756833
732,"        _children = []\n",0.011000917
733,"        for child in children:\n",0.010753666
734,"            if isinstance(child, Seq):\n",0.0173215
735,"                _children.extend(child.children)\n",0.024170333
736,"            else:\n",0.013414458
737,"                _children.append(child)\n",0.021775667
738,"        children = _children\n",0.032521
739,"\n",0.001587083
740,"        # Merge any subsequences like these into `Repeat1(A)`\n",0.007193041
741,"        #   - A Choice([Repeat1(A), Eps()])\n",0.006013625
742,"        #   - Choice([Repeat1(A), Eps()]) A\n",0.006120458
743,"        #   - A Repeat1(A)\n",0.004908875
744,"        #   - Repeat1(A) A\n",0.004885
745,"        # Keep going until there's no more changes.\n",0.006879208
746,"        while True:\n",0.008133834
747,"            for (ix, x), (iy, y) in zip(enumerate(children), enumerate(children[1:], start=1)):\n",0.042907834
748,"                match (x, y):\n",0.01217125
749,"                    case (A1, Choice([Repeat1(A2), Seq([])])) if A1 == A2:\n",0.016235708
750,"                        children[ix] = Repeat1(A1)\n",0.027564084
751,"                        children.pop(iy)\n",0.0296255
752,"                    case (Choice([Repeat1(A2), Seq([])]), A1) if A1 == A2:\n",0.050219167
753,"                        children[iy] = Repeat1(A1)\n",0.027339792
754,"                        children.pop(ix)\n",0.030000166
755,"                    case (A1, Repeat1(A2)) if A1 == A2:\n",0.037006458
756,"                        children[ix] = Repeat1(A1)\n",0.027456875
757,"                        children.pop(iy)\n",0.030142958
758,"                    case (Repeat1(A2), A1) if A1 == A2:\n",0.038981958
759,"                        children[iy] = Repeat1(A1)\n",0.027076416
760,"                        children.pop(ix)\n",0.029681042
761,"                    case _:\n",0.020763208
762,"                        continue\n",0.014635375
763,"                break\n",0.021567208
764,"            else:\n",0.014235917
765,"                break\n",0.00936675
766,"\n",0.002695042
767,"        match children:\n",0.025650125
768,"            case []:\n",0.002790375
769,"                return eps()\n",0.011513583
770,"            case [child]:\n",0.021282708
771,"                return child\n",0.01182575
772,"            case _:\n",0.010002166
773,"                return Seq(children)\n",0.016002334
774,"\n",0.002233875
775,"    def __str__(self) -> str:\n",0.021025583
776,"        match self:\n",0.008602917
777,"            case Seq([]):\n",0.00409825
778,"                return '\u001b[90meps\u001b[0m()'\n",0.010569834
779,"            case Seq([x0, Choice([Repeat1(Seq([sep, x1])), Seq([])])]) if x0 == x1:\n",0.00460925
780,"                return f'\u001b[32msep1\u001b[0m({str(x0)}, {str(sep)})'\n",0.013883208
781,"            case default:\n",0.001249042
782,"                return f'\u001b[32mseq\u001b[0m({"", "".join(str(child) for child in self.children)})'\n",0.027778083
783,"\n",0.000077792
784,"\n",0.000110542
785,"class DumbHashable[T]:\n",0.001116666
786,"    value: T\n",0.000628959
787,"    def __init__(self, value: T): self.value = value\n",0.002505792
788,"    def __hash__(self): return hash(type(self.value))\n",0.002573083
789,"    def __eq__(self, other): return self.value == other.value\n",0.002920708
790,"\n",0.000074167
791,"\n",0.000071875
792,"@dataclass\n",0.00053675
793,"class Choice(Node):\n",0.000956459
794,"    children: list[Node]\n",0.001329625
795,"\n",0.000066084
796,"    def decompose_on_left_recursion(self, ref: Ref) -> tuple[Node, Node]:\n",0.003475583
797,"        firsts, recursives = [], []\n",0.001708209
798,"        for child in self.children:\n",0.001699291
799,"            first, recursive = child.decompose_on_left_recursion(ref)\n",0.003446375
800,"            firsts.append(first)\n",0.001551792
801,"            recursives.append(recursive)\n",0.001934375
802,"        return Choice(firsts), Choice(recursives)\n",0.002339792
803,"\n",0.00007525
804,"    def replace_left_refs(self, replacements: dict[Ref, Node]) -> Node:\n",0.003372208
805,"        if len(self.children) == 0:\n",0.001696
806,"            return self\n",0.001172083
807,"        else:\n",0.000679542
808,"            self.children = [child.replace_left_refs(replacements) for child in self.children]\n",0.004467458
809,"            return self\n",0.001133708
810,"\n",0.000063584
811,"    def simplify(self) -> Node:\n",0.001503333
812,"        # Simplify children\n",0.00132025
813,"        children = [child.simplify() for child in self.children]\n",0.003050834
814,"        # Remove any fail() children\n",0.001741167
815,"        children = [child for child in children if child != fail()]\n",0.0031845
816,"        _children = []\n",0.001104291
817,"        for child in children:\n",0.001464833
818,"            if isinstance(child, Choice):\n",0.002104041
819,"                _children.extend(child.children)\n",0.002322167
820,"            else:\n",0.000864667
821,"                _children.append(child)\n",0.001883209
822,"        children = _children\n",0.001386291
823,"        if len(children) == 1:\n",0.001458667
824,"            return children[0]\n",0.001462375
825,"\n",0.000161209
826,"        # Merge any choices of sequences with a shared prefix.\n",0.002948
827,"        # It's hard to find the optimal merge strategy, but we do our best by employing a greedy strategy.\n",0.005274042
828,"        # Convert each child into a list of sequents. If the child is not a sequence, wrap it in a singleton list.\n",0.005362125
829,"        # Group each child sequence by its first element.\n",0.002667458
830,"        # For each group, merge on their longest common prefix.\n",0.002979958
831,"        # Recursively simplify the new children.\n",0.002341083
832,"        # Ignore the order of children.\n",0.001856791
833,"        def group_by_first_element(sequences: list[list[Node]]) -> dict[DumbHashable, list[list[Node]]]:\n",0.004874583
834,"            groups = defaultdict(list)\n",0.001818959
835,"            for seq in sequences:\n",0.001569917
836,"                groups[DumbHashable(seq[0])].append(seq)\n",0.002647791
837,"            return groups\n",0.001208666
838,"\n",0.000071125
839,"        sequences = []\n",0.001083125
840,"        for child in children:\n",0.001482792
841,"            if isinstance(child, Seq):\n",0.001946375
842,"                if len(child.children) > 0:\n",0.002064458
843,"                    sequences.append(child.children)\n",0.002464291
844,"            else:\n",0.000852833
845,"                sequences.append([child])\n",0.001984291
846,"\n",0.000082166
847,"        groups = group_by_first_element(sequences)\n",0.002359167
848,"        new_children = []\n",0.001212708
849,"        for first, group in groups.items():\n",0.002072917
850,"            if len(group) == 1:\n",0.001535625
851,"                new_children.append(seq(*group[0]))\n",0.002403542
852,"            else:\n",0.000855291
853,"                prefixes = []\n",0.001407208
854,"                for i in range(min(len(g) for g in group)):\n",0.002765125
855,"                    if len(set(DumbHashable(g[i]) for g in group)) == 1:\n",0.003369292
856,"                        prefixes.append(group[0][i])\n",0.002441875
857,"                    else:\n",0.001211584
858,"                        break\n",0.001443834
859,"                suffixes = [g[len(prefixes):] for g in group]\n",0.002853208
860,"                new_children.append(seq(*prefixes, Choice([seq(*suffix) for suffix in suffixes])))\n",0.004588375
861,"\n",0.000069625
862,"        new_children = [child.simplify() for child in new_children]\n",0.003169125
863,"\n",0.000070709
864,"        if eps() in children:\n",0.001407208
865,"            new_children.append(eps())\n",0.001822167
866,"\n",0.000077917
867,"        if len(new_children) == 1:\n",0.001626541
868,"            return new_children[0]\n",0.001671708
869,"\n",0.000073125
870,"        return Choice(new_children)\n",0.001673
871,"\n",0.000075709
872,"    def copy(self) -> Self:\n",0.001307958
873,"        return Choice([child.copy() for child in self.children])\n",0.003061208
874,"\n",0.0000765
875,"    def __str__(self) -> str:\n",0.001412917
876,"        match self:\n",0.000964375
877,"            case Choice([]):\n",0.001359
878,"                return '\u001b[90mfail\u001b[0m()'\n",0.002902667
879,"            case Choice([Repeat1(child), Seq([])]):\n",0.002429375
880,"                return f'\u001b[32mrepeat0\u001b[0m({str(child)})'\n",0.010824125
881,"            case Choice([Seq([x0, Choice([Repeat1(Seq([sep, x1])), Seq([])])]), Seq([])]) if x0 == x1:\n",0.004853834
882,"                return f'\u001b[32msep0\u001b[0m({str(x0)}, {str(sep)})'\n",0.013576667
883,"            case Choice([child, Seq([])]):\n",0.00201225
884,"                return f'\u001b[32mopt\u001b[0m({str(child)})'\n",0.011713083
885,"            case default:\n",0.00128975
886,"                return f'\u001b[33mchoice\u001b[0m({"", "".join(str(child) for child in self.children)})'\n",0.028332333
887,"\n",0.000112209
888,"\n",0.000073459
889,"@dataclass\n",0.000546167
890,"class Repeat1(Node):\n",0.001099833
891,"    child: Node\n",0.000759542
892,"\n",0.000160959
893,"    def decompose_on_left_recursion(self, ref: Ref) -> tuple[Node, Node]:\n",0.003442208
894,"        return seq(self.child, repeat0(self.child)).decompose_on_left_recursion(ref)\n",0.003949709
895,"\n",0.00006475
896,"    def replace_left_refs(self, replacements: dict[Ref, Node]) -> Node:\n",0.00333575
897,"        return seq(self.child, repeat0(self.child)).replace_left_refs(replacements)\n",0.003877292
898,"\n",0.000187584
899,"    def simplify(self) -> Node:\n",0.001509958
900,"        self.child = self.child.simplify()\n",0.002885417
901,"        return self if self.child != fail() else fail()\n",0.002668458
902,"\n",0.000162167
903,"    def copy(self) -> Self:\n",0.001476042
904,"        return Repeat1(self.child.copy())\n",0.001992292
905,"\n",0.000071042
906,"    def __str__(self) -> str:\n",0.001413416
907,"        return f'\u001b[35mrepeat1\u001b[0m({str(self.child)})'\n",0.012701
908,"\n",0.000069541
909,"\n",0.00009525
910,"@dataclass(frozen=True)\n",0.00127875
911,"class Ref(Node):\n",0.000926333
912,"    name: str\n",0.000686458
913,"\n",0.000087791
914,"    def decompose_on_left_recursion(self, ref: Ref) -> tuple[Node, Node]:\n",0.00342025
915,"        if self == ref:\n",0.001122709
916,"            return fail(), eps()\n",0.001535208
917,"        else:\n",0.000659
918,"            return self, fail()\n",0.00147975
919,"\n",0.000072125
920,"    def replace_left_refs(self, replacements: dict[Ref, Node]) -> Node:\n",0.00329675
921,"        return replacements.get(self, self)\n",0.002031375
922,"\n",0.000062042
923,"    def simplify(self) -> Node:\n",0.001481959
924,"        return self\n",0.000929833
925,"\n",0.0000615
926,"    def copy(self) -> Self:\n",0.001299542
927,"        return Ref(self.name)\n",0.001388292
928,"\n",0.000076625
929,"    def __str__(self) -> str:\n",0.001387458
930,"        return f'ref(\u001b[31m{repr(self.name)}\u001b[0m)'\n",0.012181334
931,"\n",0.000070167
932,"\n",0.000071792
933,"@dataclass(frozen=True)\n",0.0011485
934,"class Term[T](Node):\n",0.000989708
935,"    value: T\n",0.000617
936,"\n",0.000068708
937,"    def decompose_on_left_recursion(self, ref: Ref) -> tuple[Node, Node]:\n",0.003480708
938,"        return self, fail()\n",0.001303708
939,"\n",0.000092042
940,"    def replace_left_refs(self, replacements: dict[Ref, Node]) -> Node:\n",0.003321458
941,"        return self\n",0.000945041
942,"\n",0.000421
943,"    def simplify(self) -> Node:\n",0.001550375
944,"        return self\n",0.000936916
945,"\n",0.000062583
946,"    def copy(self) -> Self:\n",0.001305334
947,"        return Term(self.value)\n",0.001515417
948,"\n",0.00006975
949,"    def __str__(self) -> str:\n",0.001397333
950,"        return f'term(\u001b[36m{repr(self.value)}\u001b[0m)'\n",0.01244975
951,"\n",0.000070583
952,"\n",0.000074334
953,"@dataclass(frozen=True)\n",0.00115575
954,"class EpsExternal[T](Node):\n",0.001326292
955,"    data: T\n",0.000581291
956,"\n",0.000063875
957,"    def decompose_on_left_recursion(self, ref: Ref) -> tuple[Node, Node]:\n",0.00347075
958,"        return self, fail()\n",0.001320541
959,"\n",0.000121333
960,"    def replace_left_refs(self, replacements: dict[Ref, Node]) -> Node:\n",0.0033085
961,"        return self\n",0.000937583
962,"\n",0.0000725
963,"    def simplify(self) -> Node:\n",0.001477584
964,"        return self\n",0.000928625
965,"\n",0.000063292
966,"    def copy(self) -> Self:\n",0.001334208
967,"        return EpsExternal(self.data)\n",0.001757625
968,"\n",0.000063084
969,"    def __str__(self) -> str:\n",0.001403458
970,"        return f'eps(\u001b[36m{repr(self.data)}\u001b[0m)'\n",0.011738625
971,"\n",0.000075334
972,"\n",0.000071625
973,"@dataclass\n",0.000527666
974,"class Lookahead(Node):\n",0.001082625
975,"    child: Node\n",0.000754375
976,"\n",0.000075958
977,"    def decompose_on_left_recursion(self, ref: Ref) -> tuple[Node, Node]:\n",0.003455916
978,"        return self, fail()\n",0.001324625
979,"\n",0.0000715
980,"    def replace_left_refs(self, replacements: dict[Ref, Node]) -> Node:\n",0.003327667
981,"        return self\n",0.000944875
982,"\n",0.000063042
983,"    def simplify(self) -> Node:\n",0.001484542
984,"        self.child = self.child.simplify()\n",0.001983666
985,"        return self if self.child != fail() else fail()\n",0.002620375
986,"\n",0.000063208
987,"    def copy(self) -> Self:\n",0.001299083
988,"        return Lookahead(self.child.copy())\n",0.002033459
989,"\n",0.00006225
990,"    def __str__(self) -> str:\n",0.001469959
991,"        return f'\u001b[35mlookahead\u001b[0m({str(self.child)})'\n",0.011904916
992,"\n",0.00007475
993,"# Core combinators\n",0.000911375
994,"def seq(*children: Node) -> Seq: return Seq(list(children))\n",0.002815958
995,"def choice(*children: Node) -> Choice: return Choice(list(children))\n",0.003194041
996,"def repeat1(child: Node) -> Repeat1: return Repeat1(child)\n",0.002717042
997,"def ref(name: str) -> Ref: return Ref(name)\n",0.002107167
998,"def term(value: str) -> Term: return Term(value)\n",0.002277584
999,"def eps_external[T](data: T) -> EpsExternal[T]: return EpsExternal(data)\n",0.003399708
1000,"def lookahead(child: Node) -> Lookahead: return Lookahead(child)\n",0.003021375
1001,"\n",0.000295625
1002,"\n",0.000128
1003,"# Derived combinators\n",0.001029333
1004,"def eps() -> Seq: return Seq([])\n",0.001571542
1005,"def fail() -> Choice: return Choice([])\n",0.001846541
1006,"def opt(child: Node) -> Node: return choice(child, eps())\n",0.00268675
1007,"def repeat0(child: Node) -> Node: return opt(repeat1(child))\n",0.002824917
1008,"def sep1(child: Node, sep: Node) -> Node: return seq(child, repeat0(seq(sep, child)))\n",0.003959834
1009,"def sep0(child: Node, sep: Node) -> Node: return opt(sep1(child, sep))\n",0.003356542
1010,"\n",0.000341291
1011,"\n",0.0000755
1012,"def prettify_rule(ref: Ref, node: Node) -> str:\n",0.002245584
1013,"    s = StringIO()\n",0.000883959
1014,"    if isinstance(node, Choice):\n",0.001574625
1015,"        match node:\n",0.000947708
1016,"            case Choice([]):\n",0.001465459
1017,"                s.write(f'{ref} -> {node}\n')\n",0.00778225
1018,"            case Choice([Repeat1(child), Seq([])]):\n",0.019176375
1019,"                s.write(f'{ref} -> {node}\n')\n",0.018429292
1020,"            case Choice([Seq([x0, Choice([Repeat1(Seq([sep, x1])), Seq([])])]), Seq([])]) if x0 == x1:\n",0.035002875
1021,"                s.write(f'{ref} -> {node}\n')\n",0.019949375
1022,"            case Choice([child, Seq([])]):\n",0.018910541
1023,"                s.write(f'{ref} -> {node}\n')\n",0.021204125
1024,"            case default:\n",0.014574333
1025,"                s.write(f'{ref} -> \u001b[33mchoice\u001b[0m(\n')\n",0.024605125
1026,"                for child in node.children:\n",0.026115292
1027,"                    s.write(f'    {child},\n')\n",0.026111709
1028,"                s.write(')\n')\n",0.033929125
1029,"    elif isinstance(node, Seq) and len(node.children) >= 2:\n",0.085737958
1030,"        s.write(f'{ref} -> \u001b[32mseq\u001b[0m(\n')\n",0.016885334
1031,"        for child in node.children:\n",0.043368708
1032,"            s.write(f'    {child},\n')\n",0.026463291
1033,"        s.write(')\n')\n",0.041459417
1034,"    else:\n",0.024112333
1035,"        s.write(f'{ref} -> {node}\n')\n",0.029491167
1036,"    return s.getvalue().strip()\n",0.059643417
1037,"\n",0.002035834
1038,"\n",0.001623208
1039,"def prettify_rules(rules: dict[Ref, Node]):\n",0.024871375
1040,"    s = StringIO()\n",0.011088833
1041,"    for ref, node in rules.items():\n",0.01688075
1042,"        s.write(prettify_rule(ref, node) + '\n')\n",0.036537667
1043,"    print(s.getvalue().strip())\n",0.0571245
1044,"\n",0.001379375
1045,"\n",0.00194325
1046,"if __name__ == '__main__':\n",0.016035542
1047,"    def make_rules(**kwargs):\n",0.012529
1048,"        return {Ref(name): kwargs[name] for name in kwargs}\n",0.044836666
1049,"\n",0.002014417
1050,"\n",0.00185625
1051,"    # Show off the pretty-printing\n",0.017655458
1052,"    rules = make_rules(\n",0.02696175
1053,"        A=seq(term('a'), term('b')),\n",0.052653458
1054,"        B=choice(term('x'), term('y')),\n",0.049499
1055,"        C=repeat1(term('c')),\n",0.029076709
1056,"        D=ref('A'),\n",0.023841292
1057,"        E=eps(),\n",0.038233833
1058,"        F=fail(),\n",0.026759625
1059,"        G=opt(term('g')),\n",0.040780083
1060,"        H=repeat0(term('h')),\n",0.046843959
1061,"        I=sep1(term('i'), term(',')),\n",0.071448417
1062,"        J=sep0(term('j'), term(';'))\n",0.06758275
1063,"    )\n",0.006424334
1064,"    prettify_rules(rules)\n",0.02469625
1065,"    print()\n",0.010203333
1066,"\n",0.001371166
1067,"    # Resolve left recursion\n",0.013609334
1068,"    rules = make_rules(\n",0.017556541
1069,"        A=choice(seq(ref('A'), term('a')), term('b')),\n",0.054681583
1070,"    )\n",0.003923542
1071,"    print(infer_rule_types(rules))\n",0.032368792
1072,"    validate_rules(rules)\n",0.02330225
1073,"\n",0.001365666
1074,"    rules = resolve_left_recursion(rules)\n",0.031301959
1075,"    prettify_rules(rules)\n",0.024876333
1076,"    print(infer_rule_types(rules))\n",0.032487041
1077,"    validate_rules(rules)\n",0.02324475
1078,"    print()\n",0.010192083
1079,"\n",0.001932333
1080,"    # Test nullable rules\n",0.012570125
1081,"    rules = make_rules(\n",0.017920875
1082,"        A=choice(seq(ref('B')), term('b')),\n",0.0368005
1083,"        B=choice(term('a'), eps()),\n",0.032934875
1084,"    )\n",0.004185542
1085,"    nullable_rules = get_nullable_rules(rules)\n",0.0368395
1086,"    print(f""Nullable rules: {nullable_rules}"")\n",0.045880375
1087,"    assert nullable_rules == {Ref('A'), Ref('B')}\n",0.088628959
1088,"\n",0.001609167
1089,"    # Test simplifying with common prefixes\n",0.024018458
1090,"    expr = choice(\n",0.016660166
1091,"        seq(term('a'), term('b'), term('c')),\n",0.067344209
1092,"        seq(term('a'), term('b'), term('d')),\n",0.063579417
1093,"        seq(term('b'), term('c'), term('d')),\n",0.062173
1094,"        seq(term('b'), term('d')),\n",0.041768667
1095,"        term('e'),\n",0.019795042
1096,"        eps(),\n",0.032283292
1097,"    )\n",0.006759917
1098,"    print(expr)\n",0.014853958
1099,"    print(expr.simplify())\n",0.022202542
1100,"\n",0.0015475
1101,"    rules = make_rules(\n",0.018350458
1102,"        A=seq(opt(ref('B')), term('a')),\n",0.03611425
1103,"    )\n",0.004098416
1104,"    prettify_rules(rules)\n",0.025245084
1105,"    prettify_rules(resolve_left_recursion(rules))\n",0.048164166
1106,"\n",0.001563416
1107,"    # Test interspersing separators\n",0.017191584
1108,"    rules = make_rules(\n",0.018123458
1109,"        A=seq(term('a'), seq(opt(term('b'))), opt(term('c')), term('d')),\n",0.128128625
1110,"    )\n",0.004075041
1111,"    prettify_rules(rules)\n",0.0259745
1112,"    prettify_rules(intersperse_separator(rules, ref('WS')))\n",0.062202542
1113,"\n",0.001477084
1114,"    # Test get_follows\n",0.011896583
1115,"    rules = make_rules(\n",0.019275542
1116,"        A=seq(ref('B'), ref('C')),\n",0.0414485
1117,"        B=choice(term('a'), term('b')),\n",0.044364541
1118,"        C=choice(term('c'), term('d')),\n",0.045194
1119,"    )\n",0.0046385
1120,"    prettify_rules(rules)\n",0.027286959
1121,"    print(""follow sets:"")\n",0.024256875
1122,"    print(get_follows(rules))\n",0.093684917
1123,"    print()\n",0.012188041
1124,"\n",0.001567417
1125,"    # Test forbid_follows\n",0.013896041
1126,"    rules = make_rules(\n",0.019779542
1127,"        A=seq(ref('A'), opt(ref('B')), ref('C')),\n",0.077581458
1128,"        fstring=repeat1(ref('fstring_middle')),\n",0.033197209
1129,"        fstring_middle=choice(ref('fstring_replacement_field'), ref('FSTRING_MIDDLE')),\n",0.06961
1130,"    )\n",0.004607416
1131,"    forbidden_follows_table = {\n",0.037635209
1132,"        ref('A'): {ref('B')},\n",0.036812541
1133,"        ref('FSTRING_MIDDLE'): {ref('FSTRING_MIDDLE')},\n",0.029774333
1134,"    }\n",0.003369708
1135,"    # todo: uncomment this when we've completed forbid_follows\n",0.029802417
1136,"    # print(""after forbidding follows:"")\n",0.02564475
1137,"    # prettify_rules(forbid_follows(rules, forbidden_follows_table))\n",0.041617375
1138,"    # print()\n",0.014817083
1139,"\n",0.005168666
1140,"    # Test get_follows more\n",0.019671833
1141,"    rules = make_rules(\n",0.061598917
1142,"        params=repeat1(ref('param')),\n",0.0776275
1143,"        param=ref('NAME'),\n",0.040301667
1144,"    )\n",0.015211833
1145,"    prettify_rules(rules)\n",0.02714525
1146,"    print(""follow sets:"")\n",0.02396175
1147,"    for r, follow_set in get_follows(rules).items():\n",0.122994208
1148,"        print(f'{r} -> {follow_set}')\n",0.042030791
1149,"    assert ref('NAME') in get_follows(rules)[ref('NAME')]\n",0.148503584
1150,"    print()\n",0.039477041
1151,"\n",0.001921666
1152,"    rules = make_rules(\n",0.01598825
1153,"        block=seq(opt(ref('WS')), ref('DEDENT')),\n",0.036752
1154,"    )\n",0.00336625
1155,"    forbidden_follows_table = {\n",0.03440825
1156,"        ref('WS'): {ref('DEDENT')},\n",0.039120458
1157,"    }\n",0.003798334
1158,"    # todo: uncomment this when we've completed forbid_follows\n",0.03319375
1159,"    # print(""after forbidding follows:"")\n",0.028346333
1160,"    # prettify_rules(forbid_follows(rules, forbidden_follows_table))\n",0.044175125
1161,"    # print()\n",0.015851458
1162,"\n",0.0046275
1163,"    rules = make_rules(\n",0.059278042
1164,"        A=seq(opt(ref('B')), ref('B')),\n",0.088986292
1165,"    )\n",0.00807525
1166,"    for r, follow_set in get_follows(rules).items():\n",0.04500275
1167,"        print(f'{r} -> {follow_set}')\n",0.041113834
1168,"    assert ref('B') in get_follows(rules)[ref('B')]\n",0.145316792
1169,"\n",0.005569083
1170,"    rules = make_rules(\n",0.057334042
1171,"        fstring=repeat1(seq(opt(ref('WS')), ref('fstring_middle'))),\n",0.124189292
1172,"        fstring_middle=ref('FSTRING_MIDDLE'),\n",0.057105959
1173,"    )\n",0.01702625
1174,"    prettify_rules(rules)\n",0.025336833
1175,"    print(""follow sets:"")\n",0.022381625
1176,"    for r, follow_set in get_follows(rules).items():\n",0.120243875
1177,"        print(f'{r} -> {follow_set}')\n",0.043768042
1178,"    assert ref('FSTRING_MIDDLE') in get_follows(rules)[ref('fstring_middle')]",0.176278125
